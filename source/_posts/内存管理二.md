---
title: 内存管理二
date: 2022-07-05 17:32:38
tags:
---

> 一、定时器的循环引入
>
> 二、copy、mutableCopy
>
> 三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}
>
> 四、其他注意事项

<!--more-->

### 一、定时器的循环引入

我们以`NSTimer`举例，`CADisplayLink`遇到同样的问题，解决方案也一样。

#### 1.`NSTimer`的循环引入

使用`NSTimer`，写法通常如下：

```objectivec
#import "ViewController.h"
#import "ViewController1.h"

@interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    
    ViewController1 *vc = [[ViewController1 alloc] init];
    [self.navigationController pushViewController:vc animated:YES];
}

@end
```

```objectivec
#import "ViewController1.h"

@interface ViewController1 ()

@property (nonatomic, strong) NSTimer *timer;

@end

@implementation ViewController1

- (void)viewDidLoad {
    [super viewDidLoad];
    
    // 创建timer
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(test) userInfo:nil repeats:YES];
}

- (void)test {
    
    NSLog(@"11");
}

- (void)dealloc {
    
    NSLog(@"%s", __func__);
    
    // 退出界面时，使timer失效从而销毁
    [self.timer invalidate];
}

@end
```

运行代码，点击`ViewController`进入`ViewController1`，此时`timer`跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回`ViewController`，正常情况下`ViewController1`应该会销毁，并触发`dealloc`方法，`timer`也跟着失效并且销毁。但实际情况却是`ViewController1`没有销毁，也没有触发`dealloc`方法，`timer`还一直跑着，这是因为`timer`和`ViewController1`形成了循环引用，导致内存泄漏。

查看`timer`的创建方法，可以知道：**`timer`会强引用`target`，**也就是说`timer`确实强引用着`ViewController1`。

![creatTimer](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png)

而`ViewController`又强引用着`timer`。

![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png)

那怎么打破`NSTimer`的循环引用呢？我们知道`__weak`是专门用来打破循环引用的，那它是不是也能打破`NSTimer`的循环引用？

```objectivec
- (void)viewDidLoad {
    [super viewDidLoad];
    
    // 尝试用__weak打破NSTimer的循环引用
    __weak typeof(self) weakSelf = self;
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(test) userInfo:nil repeats:YES];
}
```

运行，发现没有效果，那为什么`__weak`不能打破`NSTimer`的循环引用？毫无疑问`__weak`的确是把`self`搞成了弱指针，但因为`NSTimer`内部有一个强指针类型的`target`变量

```objectivec
@property (nonatomic, strong) id target;
```

来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用`target`，所以用`__weak`不能打破`NSTimer`的循环引用。

那再试试另一条引用线吧，让`ViewController1`弱引用`timer`。

```objectivec
@interface ViewController1 ()

// 尝试用weak修饰timer来打破NSTimer的循环引用
@property (nonatomic, weak) NSTimer *timer;

@end
```

运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对`NSTimer`的说明，可以知道：**把`timer`添加到RunLoop之后，RunLoop会强引用`timer`，并且建议我们不必自己强引用`timer`，而解除RunLoop对`timer`强引用的唯一方式就是调用`timer`的`invalidate`方法使`timer`失效从而销毁。**

![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png)

![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png)

也就是说，实际的引用关系如下：

![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png)

所以我们**使用`weak`修饰`timer`是正确的，**但这还是不能打破`NSTimer`的循环引用——更准确地说，这可以解决`NSTimer`的循环引用，但还是没有解决`NSTimer`内存泄漏的问题。因为`[self.timer invalidate]`的调用——即`timer`的销毁——最好就是发生在`ViewController1`销毁时，而`ViewController1`要想销毁就必须得`timer`先销毁，还是内存泄漏。

倒腾来倒腾去，还是得**从`timer`强引用`target`这条引用线下手，把它搞成弱引用，`__weak`不起作用，那我们想想别的方案呗。**

#### 2、打破`NSTimer`的循环引用

- 方案一：使用block的方式创建`timer`

```objectivec
- (void)viewDidLoad {
    [super viewDidLoad];

    __weak typeof(self) weakSelf = self;
    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
        
        [weakSelf test];
    }];
}
```

为什么能解决呢？因为此时`timer`是强引用block的，而`__weak`可以打破block的循环引用，所以block是弱引用`self`的，所以最终的效果就类似于`timer`弱引用`self`。解决是能解决，但用这种方式创建`timer`要iOS10.0以后才能使用。

- 方案二：创建一个中间对象——代理

  我们可以把方案一的思路自己实现一下嘛，**即创建一个中间对象（方案一的中间对象就是block嘛），把这个中间对象作为`timer`的`target`参数传进去，让`timer`强引用这个中间对象，而让这个中间对象弱引用`ViewController1`，这样`ViewController1`就能正常释放，`NSTimer`就能正常调用失效方法，RunLoop就能正常解除对`NSTimer`的强引用，`NSTimer`就能正常解除对中间对象的强引用，内存泄漏就解决了。**当然**由于中间对象没有`target`——即`ViewController1`——的方法，所以我们还要做一步消息转发。**

```objectivec
-----------INETimerProxy.h-----------

#import <Foundation/Foundation.h>

@interface INETimerProxy : NSObject

+ (instancetype)proxyWithTarget:(id)target;

@end


-----------INETimerProxy.m-----------

#import "INETimerProxy.h"

@interface INETimerProxy ()

/// 弱引用target所指向的对象
@property (nonatomic, weak) id target;

@end

@implementation INETimerProxy

+ (instancetype)proxyWithTarget:(id)target {
    
    INETimerProxy *proxy = [[INETimerProxy alloc] init];
    proxy.target = target;
    return proxy;
}

// 直接消息转发
- (id)forwardingTargetForSelector:(SEL)aSelector {
    
    return self.target;
}

@end
```

```objectivec
-----------ViewController1.m-----------

#import "INETimerProxy.h"

- (void)viewDidLoad {
    [super viewDidLoad];

    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:[INETimerProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];
}
```

为了提高消息转发效率，我们可以让代理直接继承自`NSProxy`，而不是`NSObject`。**`NSProxy`是专门用来做消息转发的，继承自`NSObject`的类调用方法时会走方法查找 --> 动态方法解析 --> 直接消息转发、完整消息转发这套流程，而继承自`NSProxy`的类调用方法时只会走方法查找 --> 完整消息转发这两个流程，消息转发效率更高，所以以后但凡要做消息转发就直接继承自`NSProxy`好了，而不是`NSObject`。**

```objectivec
-----------INETimerProxy.h-----------

#import <Foundation/Foundation.h>

@interface INETimerProxy : NSProxy

+ (instancetype)proxyWithTarget:(id)target;

@end


-----------INETimerProxy.m-----------

#import "INETimerProxy.h"

@interface INETimerProxy ()

/// 弱引用target所指向的对象
@property (nonatomic, weak) id target;

@end

@implementation INETimerProxy

+ (instancetype)proxyWithTarget:(id)target {
    
    // NSProxy类是没有init方法的，alloc后就可以直接使用
    INETimerProxy *proxy = [INETimerProxy alloc];
    proxy.target = target;
    return proxy;
}

// 完整消息转发
- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {
    
    return [self.target methodSignatureForSelector:sel];
}

- (void)forwardInvocation:(NSInvocation *)invocation {
    
    [invocation invokeWithTarget:self.target];
}

@end
```

### 二、`copy`、`mutableCopy`

#### 1、深拷贝与浅拷贝

> - **深拷贝，是指内容拷贝，会产生新的对象，新对象的引用计数为1；浅拷贝，是指指针拷贝，不会产生新的对象，旧对象的引用计数加1，浅拷贝其实就是`retain`，深拷贝的话新对象和旧对象互不影响，浅拷贝的话改变一个另一个也跟着变了。**
> - **只有不可变对象的不可变拷贝是浅拷贝，其它的都是深拷贝。**

