{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by 下午3.31.26.svg","path":"images/cc-by 下午3.31.26.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b4e9149442e77bb97f61ded2e3801f8918022788","modified":1654671315642},{"_id":"source/CNAME","hash":"f43e0f14d22cd3208184e6982f5aeb3f2cfe5ed8","modified":1652455899210},{"_id":"source/_posts/.DS_Store","hash":"1075ee21affc471a6b247441b332194aa305a671","modified":1656645212876},{"_id":"source/_posts/hello-world.md","hash":"9148bef9b5cd61eadf2297c32af1cb470da1b04d","modified":1657179083200},{"_id":"source/_posts/理解指针.md","hash":"57211705a5d0eec817175c25298a158b035db9e3","modified":1658027091749},{"_id":"source/about/index.md","hash":"8563513b318b033597b33994ae4bdd670b96c91a","modified":1654833464229},{"_id":"source/tags/index.md","hash":"10ad19761cefe3c79994a1c707c3949c58ced5b2","modified":1652581034025},{"_id":"source/uploads/.DS_Store","hash":"558099c2317749b8bb3969038346dd1e12e54bb9","modified":1654827959652},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1652425454387},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1652425454387},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1652425454387},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1652425454391},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1652425454390},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1652425454391},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1652425454391},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1652425454391},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1652425454399},{"_id":"themes/next/_config.yml","hash":"a676f96714a36d919eb30dc2dd3532032042497c","modified":1658114112709},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1652425454392},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1652425454440},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1652425454388},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1652425454388},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1652425454389},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1652425454389},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1652425454389},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1652425454389},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1652425454390},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1652425454390},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1652425454390},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1652425454390},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1652425454390},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1652425454393},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1652425454393},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1652425454393},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1652425454394},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1652425454394},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1652425454394},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1652425454394},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1652425454395},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1652425454399},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1652425454395},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1652425454400},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1652425454400},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1652425454400},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1652425454401},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1652425454400},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1652425454401},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1652425454402},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1652425454402},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1652425454401},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1652425454403},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1652425454403},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1652425454403},{"_id":"themes/next/languages/tr.yml","hash":"2b041eeb8bd096f549464f191cfc1ea0181daca4","modified":1652425454404},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1652425454403},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1652425454404},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1652425454405},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1652425454404},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1652425454405},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1652425454405},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1652425454402},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1652425454406},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1652425454405},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1652425454439},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1652425454438},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1652425454439},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1652425454439},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1652425454440},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1652425454388},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1652425454472},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1652425454388},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1652425454389},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1652425454396},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1652425454389},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1652425454397},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1652425454438},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1652425454397},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1652425454397},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1652425454398},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1652425454398},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1652425454399},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1652425454398},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1652425454399},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1652425454396},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1652425454396},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1652425454395},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1652425454406},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1652425454407},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1652425454407},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1652425454407},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1652425454408},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1652425454411},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1652425454412},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1652425454417},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1652425454416},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1652425454417},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1652425454422},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1652425454424},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1652425454423},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1652425454426},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1652425454429},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1652425454430},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1652425454396},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1652425454440},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1652425454444},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1652425454453},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1652425454445},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1652425454458},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1652425454458},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1652425454458},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1652425454471},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1652425454465},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1652425454459},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1652425454472},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1652425454473},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1652425454472},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1652425454473},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1652425454473},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1652425454474},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1652425454473},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1652425454474},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1652425454474},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1652425454474},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1652425454475},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1652425454509},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1652425454515},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1652425454516},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1652425454516},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1652425454516},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1652425454517},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1652425454516},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1652425454517},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1652425454517},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1652425454518},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1652425454518},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1652425454518},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1652425454520},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1652425454521},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1652425454521},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1652425454521},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1652425454522},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1652425454521},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1652425454524},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1652425454523},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1652425454526},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1652425454525},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1652425454409},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1652425454408},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1652425454409},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1652425454409},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1652425454410},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1652425454410},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1652425454411},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1652425454410},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1652425454412},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1652425454411},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1652425454413},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1652425454413},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1652425454413},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1652425454414},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1652425454414},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1652425454414},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1652425454415},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1652425454416},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1652425454423},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1652425454422},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1652425454431},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1652425454423},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1652425454423},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1652425454423},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1652425454425},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1652425454424},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1652425454426},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1652425454425},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1652425454425},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1652425454426},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1652425454428},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1652425454427},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1652425454427},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1652425454428},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1652425454428},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1652425454430},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1652425454429},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1652425454430},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1652425454432},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1652425454431},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1652425454430},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1652425454432},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1652425454434},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1652425454434},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1652425454435},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1652425454432},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1652425454435},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1652425454441},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1652425454436},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1652425454438},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1652425454441},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1652425454441},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1652425454442},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1652425454442},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1652425454442},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1652425454443},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1652425454443},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1652425454443},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1652425454444},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1652425454444},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1652425454514},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1652425454514},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1652425454514},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1652425454515},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1652425454524},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1652425454515},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1652425454525},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1652425454530},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1652425454531},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1652425454475},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1652425454476},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1652425454475},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1652425454480},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1652425454493},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1652425454504},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1652425454493},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1652425454503},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1652425454504},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1652425454505},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1652425454505},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1652425454506},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1652425454506},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1652425454508},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1652425454509},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1652425454511},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1652425454511},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1652425454511},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1652425454511},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1652425454512},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1652425454512},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1652425454512},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1652425454513},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1652425454513},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1652425454527},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1652425454513},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1652425454513},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1652425454513},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1652425454476},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1652425454528},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1652425454476},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1652425454477},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1652425454477},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1652425454477},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1652425454477},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1652425454478},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1652425454478},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1652425454478},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1652425454478},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1652425454480},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1652425454480},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1652425454481},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1652425454480},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1652425454481},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1652425454481},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1652425454490},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1652425454491},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1652425454490},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1652425454491},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1652425454491},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1652425454491},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1652425454492},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1652425454492},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1652425454492},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1652425454493},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1652425454492},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1652425454495},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1652425454503},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1652425454503},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1652425454495},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1652425454504},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1652425454505},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1652425454504},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1652425454505},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1652425454506},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1652425454507},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1652425454507},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1652425454507},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1652425454507},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1652425454508},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1652425454508},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1652425454527},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1652425454529},{"_id":"public/about/index.html","hash":"68d9422ef54eef304f153e94d3818f05bb4a2562","modified":1658114396629},{"_id":"public/tags/index.html","hash":"3bf731b7abfb0c2bca1d4c72b2fbca537c917fdb","modified":1658114396629},{"_id":"public/archives/index.html","hash":"d3b1702bae524edae090b074fdcc36c60164607f","modified":1658114837325},{"_id":"public/archives/2022/index.html","hash":"e486a5313081eaacf847dc30d04411eebc4afcef","modified":1658114396629},{"_id":"public/archives/2022/05/index.html","hash":"2cf4acc280117196d9a5b7269316d46ba6fcee4a","modified":1657166195070},{"_id":"public/archives/2022/06/index.html","hash":"3f2fe345b67902be18ad57407c7afaa90aab4b20","modified":1657773602909},{"_id":"public/tags/技术/index.html","hash":"587df277b50fe8a67768342d60780da2faa7e304","modified":1657166195070},{"_id":"public/index.html","hash":"fdc99f6f4dea11810adc2592fa50d8d427d1e127","modified":1658114837325},{"_id":"public/2022/06/07/理解指针/index.html","hash":"cb335f1560988fb32b21cb8ab53d5d340758e4e4","modified":1657773602909},{"_id":"public/2022/05/16/hello-world/index.html","hash":"59d72413df80c1f5426b06aedab3f74f6e6a07dd","modified":1657166195070},{"_id":"public/CNAME","hash":"f43e0f14d22cd3208184e6982f5aeb3f2cfe5ed8","modified":1654841605240},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1654841605240},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1654841605240},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1654841605240},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1654841605240},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1654841605240},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1654841605240},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1654841605240},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1654841605240},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1654841605240},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1654841605240},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1654841605240},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1654841605240},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1654841605240},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1654841605240},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1654841605240},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1654841605240},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1654841605240},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1654841605240},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1654841605240},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1654841605240},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1654841605240},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1654841605240},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1654841605240},{"_id":"public/css/main.css","hash":"f57e50bca44cf451c6f39caca3d4d6db5c1e97ec","modified":1654841605240},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1654841605240},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1654841605240},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1654841605240},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1654841605240},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1654841605240},{"_id":"source/_posts/内存管理一.md","hash":"4b5cd3e950aa882f20487323e87c14eee7634dc4","modified":1658027108623},{"_id":"public/2022/06/22/内存管理一/index.html","hash":"718e7d17464ed1b1edcc1a28b75fb7b92ee60efb","modified":1657773602909},{"_id":"themes/next/layout/.DS_Store","hash":"8cff284546b7e636fcdb25a8f0c5849c6634f6bb","modified":1657087459665},{"_id":"themes/next/docs/.DS_Store","hash":"c97624fc53ed4478299657965a0ea3a64e0820b7","modified":1657087454659},{"_id":"themes/next/source/.DS_Store","hash":"c74e0d5e1f05bc90d5c9141a1f67f65693f730f8","modified":1657087459667},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"b36802665beb1a44d0141f7d69bfe54bfab25193","modified":1657087459669},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"70475c98f050de840e9e85a1e0ce31805b570a2b","modified":1657087454662},{"_id":"themes/next/scripts/.DS_Store","hash":"cada1f9f4a02bbfdc2ca0ede9a6d231ff3127d63","modified":1657087459664},{"_id":"themes/next/.DS_Store","hash":"80caf8113bc0745a2967c6c2a4d67f46ad4d2394","modified":1657087459670},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"35936b49b976bd4adf5c52397c3dea4151a7ac51","modified":1657087459668},{"_id":"themes/next/source/images/cc-by 下午3.31.26.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1652425454518},{"_id":"themes/next/source/css/.DS_Store","hash":"d81525b890c2a770b7b8323930cfe91dd547cc62","modified":1657087459663},{"_id":"themes/next/source/images/.DS_Store","hash":"46746c5e99737c05634372ba5ed0e83c5d5f76a6","modified":1656487971596},{"_id":"themes/next/source/lib/.DS_Store","hash":"7e2d86f40e97c75ff97072824226e105088c57fc","modified":1657087459666},{"_id":"public/images/cc-by 下午3.31.26.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1656645635407},{"_id":"source/_posts/内存管理二.md","hash":"c01ee1c5f9d591a902e08fcac01d5c72e08665e1","modified":1658027100277},{"_id":"public/archives/2022/07/index.html","hash":"2a490fc5407f4d7787c53a95eb58968aab58790e","modified":1658114396629},{"_id":"public/2022/07/05/内存管理二/index.html","hash":"4ade8214af61fa026a98c96f4db89a92fdb96437","modified":1657773602909},{"_id":"source/_posts/【Runtime系列】一、Runtime是什么？.md","hash":"d4eedeaf84f3816e51d7ed99f860a27cb721a465","modified":1657089048849},{"_id":"source/_posts/【Runtime系列】Runtime是什么？.md","hash":"d4eedeaf84f3816e51d7ed99f860a27cb721a465","modified":1657089048849},{"_id":"public/2022/07/06/【Runtime系列】Runtime是什么？/index.html","hash":"d7ebec32ccf2ee09eb80cd64016c0c530f15a182","modified":1657089499873},{"_id":"source/_posts/Runtime是什么？.md","hash":"2fa637f020788f90c9da5a9177cef7f5d1545c50","modified":1658053845725},{"_id":"public/2022/07/06/Runtime是什么？/index.html","hash":"73d505f3bd02c5dd0061577be0287a02141799d1","modified":1657509195543},{"_id":"public/tags/Runtime系列/index.html","hash":"c5e082e668bd0c45441376f0f91a7a89bf4b0f06","modified":1658114837325},{"_id":"public/tags/内存管理系列/index.html","hash":"725816c9afadc59e685c051c3d257ae07a6d564f","modified":1658114396629},{"_id":"public/2022/07/06/hello-world/index.html","hash":"749875fdb9c3445044db62233ca664913921bd48","modified":1657178846525},{"_id":"public/tags/博客/index.html","hash":"db257c47482e61388ee1458d7d5e80a14f1ca5e1","modified":1658114396629},{"_id":"public/2015/06/22/hello-world/index.html","hash":"6c504a49a84592eb3351f96b0484a2e0d42e715a","modified":1658114396629},{"_id":"public/archives/2015/index.html","hash":"9efd16635931c463a51252c323b9d91abb338301","modified":1658114396629},{"_id":"public/archives/2015/06/index.html","hash":"1c8c707cf7efd82e521a5d5aaf726dafdbd11377","modified":1658114396629},{"_id":"source/_posts/RunLoop.md","hash":"ed4c7adc1decf987cd67803eb09b0a492adc3e19","modified":1658027141748},{"_id":"public/2022/07/10/RunLoop/index.html","hash":"adb1848420da4feea84b112b505112c1dd24ffda","modified":1657805195716},{"_id":"public/tags/RunLoop/index.html","hash":"7fe73d8c7eb670f1c58e8e0adda8c32b9567225e","modified":1658114396629},{"_id":"source/_posts/对象、类、元类、分类的本质.md","hash":"633a36415d3695f21f74a76e3625b3724df328b6","modified":1658027082884},{"_id":"public/2022/07/13/Runtime是什么？/index.html","hash":"15589bb2a15cc6ad08da082adaeec9d1e404cbd9","modified":1657805195716},{"_id":"public/2022/07/13/对象、类、元类、分类的本质/index.html","hash":"443991954fcc4d78819c5ab959b5efd47a1d9c51","modified":1657805195716},{"_id":"source/_posts/Runtime：isa指针和superClass指针的指向，methods、cache成员变量详解.md","hash":"ece645246ac8ca47c63c2a4d47c1b014d1837fd2","modified":1658114823833},{"_id":"public/2022/07/13/Runtime：isa指针和superClass指针的指向，methods、cache成员变量详解/index.html","hash":"97e97daa70068339260736b6378f65dbad0fb8d2","modified":1658114396629},{"_id":"source/_posts/消息发送.md","hash":"57e5272c55b8e5d31428aa22209e8ae044ae2f25","modified":1658027120646},{"_id":"source/_posts/实际应用.md","hash":"8217b169e59441531b9585ced2cebb94dffc4955","modified":1658056652320},{"_id":"public/2021/07/13/Runtime是什么？/index.html","hash":"eed465f128e7f36fb71512c9952205b3bfadd810","modified":1658114396629},{"_id":"public/2021/07/17/实际应用/index.html","hash":"c94bf26ede4a201bcc16a2da45d90b2e5232d0ad","modified":1658108024656},{"_id":"public/archives/2021/index.html","hash":"9d294a4b510a694fff4a8d5998ff178738274d94","modified":1658114837325},{"_id":"public/archives/2021/06/index.html","hash":"103e27a0a59d6d8aa370eff8f27ee0e19dddeb23","modified":1658114396629},{"_id":"public/archives/2021/07/index.html","hash":"c7a1aeff600a1f478f84eadccee95dbe439fe53c","modified":1658114837325},{"_id":"public/2021/07/13/对象、类、元类、分类的本质/index.html","hash":"9fae9072efe3dc94afdfa2831972c3d8ae573441","modified":1658114837325},{"_id":"public/2021/07/10/RunLoop/index.html","hash":"380742e528df4c84846fc12e11aa5b0ce62b676c","modified":1658114837325},{"_id":"public/2021/06/22/内存管理一/index.html","hash":"0bf8f96076f5551ab76665bd67f2b38c32d392ab","modified":1658114396629},{"_id":"public/2021/07/05/内存管理二/index.html","hash":"656f14b8634b8233771fffa9dc35a12b850af47a","modified":1658114396629},{"_id":"public/2021/06/07/理解指针/index.html","hash":"7c019466e79d28d716294f03cdb4d5cbb7c7eb61","modified":1658114396629},{"_id":"source/_posts/Runtime实际应用.md","hash":"1163aa370ef6aaa6dbc4321dade2e6e2d5d1197e","modified":1658112925161},{"_id":"public/2021/07/17/Runtime实际应用/index.html","hash":"0e612abd5ffab4d69af89dabebc60d249503afce","modified":1658114837325},{"_id":"public/2021/07/12/Runtime：isa指针和superClass指针的指向，methods、cache成员变量详解/index.html","hash":"b02ac9d541a8d97453dd16fa40f30740e6a8a413","modified":1658114837325}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2022-05-15T02:15:52.000Z","comments":0,"_content":"\n\n\n用blog记录知识，记录生活。\n\n技术要严谨，生活要精彩。\n\n![tangsan](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/tangsan.png)","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-05-15 10:15:52\ncomments: false\n---\n\n\n\n用blog记录知识，记录生活。\n\n技术要严谨，生活要精彩。\n\n![tangsan](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/tangsan.png)","updated":"2022-06-10T03:57:44.229Z","path":"about/index.html","layout":"page","_id":"cl481yqwr000036fy16gbfyxn","content":"<p>用blog记录知识，记录生活。</p>\n<p>技术要严谨，生活要精彩。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/tangsan.png\" alt=\"tangsan\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>用blog记录知识，记录生活。</p>\n<p>技术要严谨，生活要精彩。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/tangsan.png\" alt=\"tangsan\"></p>\n"},{"title":"tags","date":"2022-05-15T02:14:38.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-05-15 10:14:38\ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-05-15T02:17:14.025Z","path":"tags/index.html","layout":"page","_id":"cl481yqwx000236fy0q3ibymu","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","date":"2015-06-21T16:00:00.000Z","_content":"\nhexo创建发布博客流程\n\n<!--more-->\n\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2015-06-22\ntags: 博客\n---\n\nhexo创建发布博客流程\n\n<!--more-->\n\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2022-07-07T07:31:23.200Z","_id":"cl481yqwv000136fy4lk172zm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>hexo创建发布博客流程</p>\n<span id=\"more\"></span>\n\n\n\n<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>hexo创建发布博客流程</p>","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"理解指针","date":"2021-06-07T07:54:39.000Z","_content":"\n### 一、引言：\n\n日常开发中，我们经常遇到指针，同时指针也是C语言里极为重要的一个知识点，今天我们就来把它彻底弄明白。\n\n<!--more-->\n\n\n\n### 二：正文\n\n#### 变量与变量值:\n\n```\n    //数据类型（int） 变量名（a） = 值（10）\n    int a = 10;\n```\n\n变量：变量是一个**抽象概念**，可以理解为允许存放数据的空间。当声明一个变量，计算机就会分配空间存放数据。变量可以通过变量名访问。\n\n变量值：变量里面存储的数据即为变量值，变量值可以为数值、字符等类型。\n\n\n\n#### 指针：\n\n**指针：**是一种<u>变量</u>，它的值是一个**内存地址**。（从三个方面分析指针：指针的类型、指针所指向的类型、指针的值）\n\n**指针类型：**`数据类型 *`，int *：整形数据类型的指针； char *： 字符数据类型的指针； void *：无数据类型的指针；等等...\n\n**取地址运算：**`&变量 ` ，取得的结果是变量的**首**地址，是一个**值**（eg：x10db5640）。\n\n**取变量运算：**`*指针变量`，取得的结果是一个变量。\n\n\n\n1.整形数据类型指针：\n\n```\n- (void)testIntExample {\n    \n    //int类型变量a赋值为10\n    int a = 10;\n    //int*类型的指针变量b赋值为&a\n    int *b = &a;\n    //int类型变量c赋值为*b\n    int c = *b;\n    \n    printf(\"变量b---值：%d 地址：%p\",*b,b);\n    printf(\"变量c---值：%d 地址：%p\",c,&c);\n    \n    打印结果：\n    变量b---值：10 地址：0x10db5641c\n    变量c---值：10 地址：0x10db5640c\n}\n```\n\n解读：指针变量b的类型是：int *，指针变量b所指向的变量类型是int类型，b的值是一个地址：0x10db5641c。\n\n\n\n2.字符数据类型指针：\n\n```\n- (void)testCharExample {\n\n    char *a = \"blog\";\n    char *b = a;\n    char *c = b;\n    \n    printf(\"变量b所指变量的值：%s 变量b所指变量的首地址：%p 变量b的地址：%p\",b,b,&b);\n    printf(\"变量c所指变量的值：%s 变量c所指变量的首地址：%p 变量c的地址：%p\",c,c,&c);\n    \n    打印结果：\n\t\t变量b所指变量的值：blog 变量b所指变量的首地址：0x10a951bfc 变量b的地址：0x10a76f410\n\t\t变量c所指变量的值：blog 变量c所指变量的首地址：0x10a951bfc 变量c的地址：0x10a76f408\n}\n```\n\n解读：char*类型指针 变量a 指向char类型变量blog，a的值是 变量blog的首地址0x10a951bfc。\n\n\n\n3.指针与数组：\n\n```\n- (void)testArrayExample {\n    \n    int arr[] = {4,12,34,6,7,788};\n    int *a = arr;//得到的是arr的首地址\n    int *b = &arr[0];//得到的是arr数组第一个元素的地址\n    int *c = arr + 1;//得到的是arr数组第二个元素的地址\n    int *d = &arr[0] + 1;//得到的是arr数组第二个元素的地址\n\n    printf(\"a:%p---b:%p\",a,b);//可以得出a和b是相等的\n    printf(\"c:%p---d:%p\",c,d);//可以得出c和d是相等的\n    printf(\"num:%ld\",c-a);//可以得出c和a之间有几个元素\n    printf(\"数组中第一个元素的字节数：%ld\",sizeof(arr[0]));//获取数组第一个元素的字节数\n    \n    *c = 99;\n    printf(\"arr+1: %d---%p\",*c,c);\n\n    //打印结果：\n    a:0x106f54410---b:0x106f54410\n    c:0x106f54414---d:0x106f54414\n    num:1\n    数组中第一个元素的字节数：4\n    arr+1: 99---0x106f54414\n}\n```\n\n解读：\n\n1）arr 表示arr[]数组的首地址\n\n2）指针c - 指针a，能获取到两个指针之间有几个元素\n\n3）指针变量加减一个整数,p(指针)(+/-)n(整数)计算方式为：指针地址 (+/-) n * 变量占有的字节数\n\n4）sizeof的用法：\n\n- 每种类型的数据在内存单元中占有的字节数是固定的,因此sizeof(arr)/sizeof(arr[0]) = 数组的元素的个数\n- sizeof(arr)：获取的是数组总共占有多少字节\n- sizeof(arr[0])：获取的是数组中一个元素占有的字节数\n\n5）数组变量保存的是地址,但数组变量中保存的地址是不能改变的,注意说的是指针地址不能变,但是指针指向的值是可以变的,因此数组变量应称为指针常量，可以改变数组中地址中存储的值。\n\n\n\n#### OC 应用场景示例：\n\n```\n//采用这种方式传参，可以获取到error的值\n- (void)testErrorExample {\n\n    NSError *err = nil;\n    [self handleResponseCode:400 error:&err];\n    \n    NSLog(@\"err---%p--%@\",err,err);\n    \n    //指针运算符&和*是从右往左运算,他们的优先级相同。*&err和err一样。\n    NSLog(@\"*&err---%p--%@\",*&err,*&err);\n    \n    //打印结果\n    err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 \"(null)\" UserInfo={data=99}\n    *&err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 \"(null)\" UserInfo={data=99}\n    \n}\n\n- (void)handleResponseCode:(NSInteger)code error:(NSError **)error{\n    if (code != 0) {\n        *error = [NSError errorWithDomain:NSCocoaErrorDomain code:100 userInfo:@{@\"data\":@\"99\"}];\n    }\n}\n```\n\n\n\n### 三、扩展\n\n1. 操作系统分为32位和64位，32位的最多只能支持4GB的内存，因为计算机底层并不使用十进制，使用的是二进制，32位的二进制只能支持4G个编号，这意味着操作系统只能为4GB的内存单元编号，因此32位的操作系统最多只能支持4GB的内存，多余的内存不会有编号,因此无法将数据存入这些内存单元中。\n\n2. 指针存储于栈区，不同数据类型的指针大小都相等，因为他们的值都是一个地址，并且长度也相同。32位操作系统中，指针大小是4个字节，64位操作系统中指针大小是8个字节。\n\n   ```\n   //下面代码是在64位操作系统演示\n   -(void)testGetPointerNum {\n       \n       char *a = \"myBlog\";\n       \n       int num1 = 1234325;\n       int *b = &num1;\n       \n       double num2 = 3232.434;\n       double *c = &num2;\n       \n       printf(\"char *类型指针变量a所占字节数：%ld\",sizeof(a));\n       printf(\"int *类型指针变量b所占字节数：%ld\",sizeof(b));\n       printf(\"double *类型指针变量c所占字节数：%ld\",sizeof(c));\n       \n       //打印结果\n       char *类型指针变量a所占字节数：8\n       int *类型指针变量b所占字节数：8\n       double *类型指针变量c所占字节数：8\n   }\n   ```\n\n3. 结构体数据类型变量的大小：`对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。`\n\n   ```\n   - (void)testStructExample {\n       \n       struct Data1{\n           int a;\n           char b;\n           char c;\n       };\n       \n       struct Data2{\n           char c;\n           int a;\n           char b;\n       };\n       \n       struct Data1 p1;\n       p1.a = 1;\n       p1.b = 'd';\n       p1.c = 'f';\n       \n       struct Data2 p2;\n       p2.a = 1;\n       p2.b = 'd';\n       p2.c = 'f';\n       \n       printf(\"p1结构体占用的字节个数为：%ld\",sizeof(p1));\n       printf(\"p2结构体占用的字节个数为：%ld\",sizeof(p2));\n       \n       //打印结果\n       p1结构体占用的字节个数为：8\n       p2结构体占用的字节个数为：12\n   }\n   ```\n\n   解读：\n\n   ![结构体内存结构示意图](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n   你可以看到，在 Data1 中，首先是 int 类型的 a 变量，占用了第一个存储单元，然后 b 和 c 占用了第二个存储单元的前两个字节。再看 Data2，由于 Data2 不同于 Data1 的字段顺序，b 占用了第一个存储单元的第一个字节，剩余的 3 个字节不够存放一个 int 类型变量的，所以按照上面我们讲的规则“当本存储单元不够安放的时候，就从下个存储单元的头部开始安放”， a 变量就单独占用了第二个存储单元，c 自己占用第三个存储单元的第一个字节。所以，虽然在数据表示上，Data1 和 Data2 是等价的，可 Data2 却占用了更多的存储空间，相比于 Data1 造成了 50% 的空间浪费。由此可见，在设计结构体的时候，不仅要设计新的结构体类型中所包含的数据字段，还需要关注各个字段之间的顺序排布。\n\n4. 32位操作系统内存与地址分布图：\n\n![内存空间布局](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png)\n\n5. 64位操作系统常用数据类型占用的内存大小：\n\n   |     常用数据类型      | 占用内存大小（字节） |\n   | :-------------------: | :------------------: |\n   |  char、unsigned char  |          1           |\n   |         bool          |          1           |\n   | short、unsigned short |          2           |\n   |   int、unsigned int   |          4           |\n   |  long、unsigned long  |          8           |\n   |         float         |          4           |\n   |        double         |          8           |\n   |         指针          |          8           |\n\n","source":"_posts/理解指针.md","raw":"---\ntitle: 理解指针\ndate: 2021-06-07 15:54:39\ntags: 内存管理系列\n---\n\n### 一、引言：\n\n日常开发中，我们经常遇到指针，同时指针也是C语言里极为重要的一个知识点，今天我们就来把它彻底弄明白。\n\n<!--more-->\n\n\n\n### 二：正文\n\n#### 变量与变量值:\n\n```\n    //数据类型（int） 变量名（a） = 值（10）\n    int a = 10;\n```\n\n变量：变量是一个**抽象概念**，可以理解为允许存放数据的空间。当声明一个变量，计算机就会分配空间存放数据。变量可以通过变量名访问。\n\n变量值：变量里面存储的数据即为变量值，变量值可以为数值、字符等类型。\n\n\n\n#### 指针：\n\n**指针：**是一种<u>变量</u>，它的值是一个**内存地址**。（从三个方面分析指针：指针的类型、指针所指向的类型、指针的值）\n\n**指针类型：**`数据类型 *`，int *：整形数据类型的指针； char *： 字符数据类型的指针； void *：无数据类型的指针；等等...\n\n**取地址运算：**`&变量 ` ，取得的结果是变量的**首**地址，是一个**值**（eg：x10db5640）。\n\n**取变量运算：**`*指针变量`，取得的结果是一个变量。\n\n\n\n1.整形数据类型指针：\n\n```\n- (void)testIntExample {\n    \n    //int类型变量a赋值为10\n    int a = 10;\n    //int*类型的指针变量b赋值为&a\n    int *b = &a;\n    //int类型变量c赋值为*b\n    int c = *b;\n    \n    printf(\"变量b---值：%d 地址：%p\",*b,b);\n    printf(\"变量c---值：%d 地址：%p\",c,&c);\n    \n    打印结果：\n    变量b---值：10 地址：0x10db5641c\n    变量c---值：10 地址：0x10db5640c\n}\n```\n\n解读：指针变量b的类型是：int *，指针变量b所指向的变量类型是int类型，b的值是一个地址：0x10db5641c。\n\n\n\n2.字符数据类型指针：\n\n```\n- (void)testCharExample {\n\n    char *a = \"blog\";\n    char *b = a;\n    char *c = b;\n    \n    printf(\"变量b所指变量的值：%s 变量b所指变量的首地址：%p 变量b的地址：%p\",b,b,&b);\n    printf(\"变量c所指变量的值：%s 变量c所指变量的首地址：%p 变量c的地址：%p\",c,c,&c);\n    \n    打印结果：\n\t\t变量b所指变量的值：blog 变量b所指变量的首地址：0x10a951bfc 变量b的地址：0x10a76f410\n\t\t变量c所指变量的值：blog 变量c所指变量的首地址：0x10a951bfc 变量c的地址：0x10a76f408\n}\n```\n\n解读：char*类型指针 变量a 指向char类型变量blog，a的值是 变量blog的首地址0x10a951bfc。\n\n\n\n3.指针与数组：\n\n```\n- (void)testArrayExample {\n    \n    int arr[] = {4,12,34,6,7,788};\n    int *a = arr;//得到的是arr的首地址\n    int *b = &arr[0];//得到的是arr数组第一个元素的地址\n    int *c = arr + 1;//得到的是arr数组第二个元素的地址\n    int *d = &arr[0] + 1;//得到的是arr数组第二个元素的地址\n\n    printf(\"a:%p---b:%p\",a,b);//可以得出a和b是相等的\n    printf(\"c:%p---d:%p\",c,d);//可以得出c和d是相等的\n    printf(\"num:%ld\",c-a);//可以得出c和a之间有几个元素\n    printf(\"数组中第一个元素的字节数：%ld\",sizeof(arr[0]));//获取数组第一个元素的字节数\n    \n    *c = 99;\n    printf(\"arr+1: %d---%p\",*c,c);\n\n    //打印结果：\n    a:0x106f54410---b:0x106f54410\n    c:0x106f54414---d:0x106f54414\n    num:1\n    数组中第一个元素的字节数：4\n    arr+1: 99---0x106f54414\n}\n```\n\n解读：\n\n1）arr 表示arr[]数组的首地址\n\n2）指针c - 指针a，能获取到两个指针之间有几个元素\n\n3）指针变量加减一个整数,p(指针)(+/-)n(整数)计算方式为：指针地址 (+/-) n * 变量占有的字节数\n\n4）sizeof的用法：\n\n- 每种类型的数据在内存单元中占有的字节数是固定的,因此sizeof(arr)/sizeof(arr[0]) = 数组的元素的个数\n- sizeof(arr)：获取的是数组总共占有多少字节\n- sizeof(arr[0])：获取的是数组中一个元素占有的字节数\n\n5）数组变量保存的是地址,但数组变量中保存的地址是不能改变的,注意说的是指针地址不能变,但是指针指向的值是可以变的,因此数组变量应称为指针常量，可以改变数组中地址中存储的值。\n\n\n\n#### OC 应用场景示例：\n\n```\n//采用这种方式传参，可以获取到error的值\n- (void)testErrorExample {\n\n    NSError *err = nil;\n    [self handleResponseCode:400 error:&err];\n    \n    NSLog(@\"err---%p--%@\",err,err);\n    \n    //指针运算符&和*是从右往左运算,他们的优先级相同。*&err和err一样。\n    NSLog(@\"*&err---%p--%@\",*&err,*&err);\n    \n    //打印结果\n    err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 \"(null)\" UserInfo={data=99}\n    *&err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 \"(null)\" UserInfo={data=99}\n    \n}\n\n- (void)handleResponseCode:(NSInteger)code error:(NSError **)error{\n    if (code != 0) {\n        *error = [NSError errorWithDomain:NSCocoaErrorDomain code:100 userInfo:@{@\"data\":@\"99\"}];\n    }\n}\n```\n\n\n\n### 三、扩展\n\n1. 操作系统分为32位和64位，32位的最多只能支持4GB的内存，因为计算机底层并不使用十进制，使用的是二进制，32位的二进制只能支持4G个编号，这意味着操作系统只能为4GB的内存单元编号，因此32位的操作系统最多只能支持4GB的内存，多余的内存不会有编号,因此无法将数据存入这些内存单元中。\n\n2. 指针存储于栈区，不同数据类型的指针大小都相等，因为他们的值都是一个地址，并且长度也相同。32位操作系统中，指针大小是4个字节，64位操作系统中指针大小是8个字节。\n\n   ```\n   //下面代码是在64位操作系统演示\n   -(void)testGetPointerNum {\n       \n       char *a = \"myBlog\";\n       \n       int num1 = 1234325;\n       int *b = &num1;\n       \n       double num2 = 3232.434;\n       double *c = &num2;\n       \n       printf(\"char *类型指针变量a所占字节数：%ld\",sizeof(a));\n       printf(\"int *类型指针变量b所占字节数：%ld\",sizeof(b));\n       printf(\"double *类型指针变量c所占字节数：%ld\",sizeof(c));\n       \n       //打印结果\n       char *类型指针变量a所占字节数：8\n       int *类型指针变量b所占字节数：8\n       double *类型指针变量c所占字节数：8\n   }\n   ```\n\n3. 结构体数据类型变量的大小：`对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。`\n\n   ```\n   - (void)testStructExample {\n       \n       struct Data1{\n           int a;\n           char b;\n           char c;\n       };\n       \n       struct Data2{\n           char c;\n           int a;\n           char b;\n       };\n       \n       struct Data1 p1;\n       p1.a = 1;\n       p1.b = 'd';\n       p1.c = 'f';\n       \n       struct Data2 p2;\n       p2.a = 1;\n       p2.b = 'd';\n       p2.c = 'f';\n       \n       printf(\"p1结构体占用的字节个数为：%ld\",sizeof(p1));\n       printf(\"p2结构体占用的字节个数为：%ld\",sizeof(p2));\n       \n       //打印结果\n       p1结构体占用的字节个数为：8\n       p2结构体占用的字节个数为：12\n   }\n   ```\n\n   解读：\n\n   ![结构体内存结构示意图](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n   你可以看到，在 Data1 中，首先是 int 类型的 a 变量，占用了第一个存储单元，然后 b 和 c 占用了第二个存储单元的前两个字节。再看 Data2，由于 Data2 不同于 Data1 的字段顺序，b 占用了第一个存储单元的第一个字节，剩余的 3 个字节不够存放一个 int 类型变量的，所以按照上面我们讲的规则“当本存储单元不够安放的时候，就从下个存储单元的头部开始安放”， a 变量就单独占用了第二个存储单元，c 自己占用第三个存储单元的第一个字节。所以，虽然在数据表示上，Data1 和 Data2 是等价的，可 Data2 却占用了更多的存储空间，相比于 Data1 造成了 50% 的空间浪费。由此可见，在设计结构体的时候，不仅要设计新的结构体类型中所包含的数据字段，还需要关注各个字段之间的顺序排布。\n\n4. 32位操作系统内存与地址分布图：\n\n![内存空间布局](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png)\n\n5. 64位操作系统常用数据类型占用的内存大小：\n\n   |     常用数据类型      | 占用内存大小（字节） |\n   | :-------------------: | :------------------: |\n   |  char、unsigned char  |          1           |\n   |         bool          |          1           |\n   | short、unsigned short |          2           |\n   |   int、unsigned int   |          4           |\n   |  long、unsigned long  |          8           |\n   |         float         |          4           |\n   |        double         |          8           |\n   |         指针          |          8           |\n\n","slug":"理解指针","published":1,"updated":"2022-07-17T03:04:51.749Z","_id":"cl481yqwy000336fy52h5hp7d","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一、引言：\"><a href=\"#一、引言：\" class=\"headerlink\" title=\"一、引言：\"></a>一、引言：</h3><p>日常开发中，我们经常遇到指针，同时指针也是C语言里极为重要的一个知识点，今天我们就来把它彻底弄明白。</p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"二：正文\"><a href=\"#二：正文\" class=\"headerlink\" title=\"二：正文\"></a>二：正文</h3><h4 id=\"变量与变量值\"><a href=\"#变量与变量值\" class=\"headerlink\" title=\"变量与变量值:\"></a>变量与变量值:</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据类型（int） 变量名（a） = 值（10）</span><br><span class=\"line\">int a = 10;</span><br></pre></td></tr></table></figure>\n\n<p>变量：变量是一个<strong>抽象概念</strong>，可以理解为允许存放数据的空间。当声明一个变量，计算机就会分配空间存放数据。变量可以通过变量名访问。</p>\n<p>变量值：变量里面存储的数据即为变量值，变量值可以为数值、字符等类型。</p>\n<h4 id=\"指针：\"><a href=\"#指针：\" class=\"headerlink\" title=\"指针：\"></a>指针：</h4><p><strong>指针：</strong>是一种<u>变量</u>，它的值是一个<strong>内存地址</strong>。（从三个方面分析指针：指针的类型、指针所指向的类型、指针的值）</p>\n<p><strong>指针类型：</strong><code>数据类型 *</code>，int *：整形数据类型的指针； char *： 字符数据类型的指针； void *：无数据类型的指针；等等…</p>\n<p><strong>取地址运算：</strong><code>&amp;变量 </code> ，取得的结果是变量的<strong>首</strong>地址，是一个<strong>值</strong>（eg：x10db5640）。</p>\n<p><strong>取变量运算：</strong><code>*指针变量</code>，取得的结果是一个变量。</p>\n<p>1.整形数据类型指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testIntExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //int类型变量a赋值为10</span><br><span class=\"line\">    int a = 10;</span><br><span class=\"line\">    //int*类型的指针变量b赋值为&amp;a</span><br><span class=\"line\">    int *b = &amp;a;</span><br><span class=\"line\">    //int类型变量c赋值为*b</span><br><span class=\"line\">    int c = *b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;变量b---值：%d 地址：%p&quot;,*b,b);</span><br><span class=\"line\">    printf(&quot;变量c---值：%d 地址：%p&quot;,c,&amp;c);</span><br><span class=\"line\">    </span><br><span class=\"line\">    打印结果：</span><br><span class=\"line\">    变量b---值：10 地址：0x10db5641c</span><br><span class=\"line\">    变量c---值：10 地址：0x10db5640c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：指针变量b的类型是：int *，指针变量b所指向的变量类型是int类型，b的值是一个地址：0x10db5641c。</p>\n<p>2.字符数据类型指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testCharExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    char *a = &quot;blog&quot;;</span><br><span class=\"line\">    char *b = a;</span><br><span class=\"line\">    char *c = b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;变量b所指变量的值：%s 变量b所指变量的首地址：%p 变量b的地址：%p&quot;,b,b,&amp;b);</span><br><span class=\"line\">    printf(&quot;变量c所指变量的值：%s 变量c所指变量的首地址：%p 变量c的地址：%p&quot;,c,c,&amp;c);</span><br><span class=\"line\">    </span><br><span class=\"line\">    打印结果：</span><br><span class=\"line\">\t\t变量b所指变量的值：blog 变量b所指变量的首地址：0x10a951bfc 变量b的地址：0x10a76f410</span><br><span class=\"line\">\t\t变量c所指变量的值：blog 变量c所指变量的首地址：0x10a951bfc 变量c的地址：0x10a76f408</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：char*类型指针 变量a 指向char类型变量blog，a的值是 变量blog的首地址0x10a951bfc。</p>\n<p>3.指针与数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testArrayExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int arr[] = &#123;4,12,34,6,7,788&#125;;</span><br><span class=\"line\">    int *a = arr;//得到的是arr的首地址</span><br><span class=\"line\">    int *b = &amp;arr[0];//得到的是arr数组第一个元素的地址</span><br><span class=\"line\">    int *c = arr + 1;//得到的是arr数组第二个元素的地址</span><br><span class=\"line\">    int *d = &amp;arr[0] + 1;//得到的是arr数组第二个元素的地址</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;a:%p---b:%p&quot;,a,b);//可以得出a和b是相等的</span><br><span class=\"line\">    printf(&quot;c:%p---d:%p&quot;,c,d);//可以得出c和d是相等的</span><br><span class=\"line\">    printf(&quot;num:%ld&quot;,c-a);//可以得出c和a之间有几个元素</span><br><span class=\"line\">    printf(&quot;数组中第一个元素的字节数：%ld&quot;,sizeof(arr[0]));//获取数组第一个元素的字节数</span><br><span class=\"line\">    </span><br><span class=\"line\">    *c = 99;</span><br><span class=\"line\">    printf(&quot;arr+1: %d---%p&quot;,*c,c);</span><br><span class=\"line\"></span><br><span class=\"line\">    //打印结果：</span><br><span class=\"line\">    a:0x106f54410---b:0x106f54410</span><br><span class=\"line\">    c:0x106f54414---d:0x106f54414</span><br><span class=\"line\">    num:1</span><br><span class=\"line\">    数组中第一个元素的字节数：4</span><br><span class=\"line\">    arr+1: 99---0x106f54414</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：</p>\n<p>1）arr 表示arr[]数组的首地址</p>\n<p>2）指针c - 指针a，能获取到两个指针之间有几个元素</p>\n<p>3）指针变量加减一个整数,p(指针)(+/-)n(整数)计算方式为：指针地址 (+/-) n * 变量占有的字节数</p>\n<p>4）sizeof的用法：</p>\n<ul>\n<li>每种类型的数据在内存单元中占有的字节数是固定的,因此sizeof(arr)/sizeof(arr[0]) = 数组的元素的个数</li>\n<li>sizeof(arr)：获取的是数组总共占有多少字节</li>\n<li>sizeof(arr[0])：获取的是数组中一个元素占有的字节数</li>\n</ul>\n<p>5）数组变量保存的是地址,但数组变量中保存的地址是不能改变的,注意说的是指针地址不能变,但是指针指向的值是可以变的,因此数组变量应称为指针常量，可以改变数组中地址中存储的值。</p>\n<h4 id=\"OC-应用场景示例：\"><a href=\"#OC-应用场景示例：\" class=\"headerlink\" title=\"OC 应用场景示例：\"></a>OC 应用场景示例：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//采用这种方式传参，可以获取到error的值</span><br><span class=\"line\">- (void)testErrorExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSError *err = nil;</span><br><span class=\"line\">    [self handleResponseCode:400 error:&amp;err];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;err---%p--%@&quot;,err,err);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //指针运算符&amp;和*是从右往左运算,他们的优先级相同。*&amp;err和err一样。</span><br><span class=\"line\">    NSLog(@&quot;*&amp;err---%p--%@&quot;,*&amp;err,*&amp;err);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 &quot;(null)&quot; UserInfo=&#123;data=99&#125;</span><br><span class=\"line\">    *&amp;err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 &quot;(null)&quot; UserInfo=&#123;data=99&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleResponseCode:(NSInteger)code error:(NSError **)error&#123;</span><br><span class=\"line\">    if (code != 0) &#123;</span><br><span class=\"line\">        *error = [NSError errorWithDomain:NSCocoaErrorDomain code:100 userInfo:@&#123;@&quot;data&quot;:@&quot;99&quot;&#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"三、扩展\"><a href=\"#三、扩展\" class=\"headerlink\" title=\"三、扩展\"></a>三、扩展</h3><ol>\n<li><p>操作系统分为32位和64位，32位的最多只能支持4GB的内存，因为计算机底层并不使用十进制，使用的是二进制，32位的二进制只能支持4G个编号，这意味着操作系统只能为4GB的内存单元编号，因此32位的操作系统最多只能支持4GB的内存，多余的内存不会有编号,因此无法将数据存入这些内存单元中。</p>\n</li>\n<li><p>指针存储于栈区，不同数据类型的指针大小都相等，因为他们的值都是一个地址，并且长度也相同。32位操作系统中，指针大小是4个字节，64位操作系统中指针大小是8个字节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面代码是在64位操作系统演示</span><br><span class=\"line\">-(void)testGetPointerNum &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    char *a = &quot;myBlog&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int num1 = 1234325;</span><br><span class=\"line\">    int *b = &amp;num1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    double num2 = 3232.434;</span><br><span class=\"line\">    double *c = &amp;num2;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;char *类型指针变量a所占字节数：%ld&quot;,sizeof(a));</span><br><span class=\"line\">    printf(&quot;int *类型指针变量b所占字节数：%ld&quot;,sizeof(b));</span><br><span class=\"line\">    printf(&quot;double *类型指针变量c所占字节数：%ld&quot;,sizeof(c));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    char *类型指针变量a所占字节数：8</span><br><span class=\"line\">    int *类型指针变量b所占字节数：8</span><br><span class=\"line\">    double *类型指针变量c所占字节数：8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结构体数据类型变量的大小：<code>对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testStructExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data1&#123;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        char b;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data2&#123;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        char b;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data1 p1;</span><br><span class=\"line\">    p1.a = 1;</span><br><span class=\"line\">    p1.b = &#x27;d&#x27;;</span><br><span class=\"line\">    p1.c = &#x27;f&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data2 p2;</span><br><span class=\"line\">    p2.a = 1;</span><br><span class=\"line\">    p2.b = &#x27;d&#x27;;</span><br><span class=\"line\">    p2.c = &#x27;f&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;p1结构体占用的字节个数为：%ld&quot;,sizeof(p1));</span><br><span class=\"line\">    printf(&quot;p2结构体占用的字节个数为：%ld&quot;,sizeof(p2));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    p1结构体占用的字节个数为：8</span><br><span class=\"line\">    p2结构体占用的字节个数为：12</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"结构体内存结构示意图\"></p>\n<p>你可以看到，在 Data1 中，首先是 int 类型的 a 变量，占用了第一个存储单元，然后 b 和 c 占用了第二个存储单元的前两个字节。再看 Data2，由于 Data2 不同于 Data1 的字段顺序，b 占用了第一个存储单元的第一个字节，剩余的 3 个字节不够存放一个 int 类型变量的，所以按照上面我们讲的规则“当本存储单元不够安放的时候，就从下个存储单元的头部开始安放”， a 变量就单独占用了第二个存储单元，c 自己占用第三个存储单元的第一个字节。所以，虽然在数据表示上，Data1 和 Data2 是等价的，可 Data2 却占用了更多的存储空间，相比于 Data1 造成了 50% 的空间浪费。由此可见，在设计结构体的时候，不仅要设计新的结构体类型中所包含的数据字段，还需要关注各个字段之间的顺序排布。</p>\n</li>\n<li><p>32位操作系统内存与地址分布图：</p>\n</li>\n</ol>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png\" alt=\"内存空间布局\"></p>\n<ol start=\"5\">\n<li><p>64位操作系统常用数据类型占用的内存大小：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">常用数据类型</th>\n<th align=\"center\">占用内存大小（字节）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char、unsigned char</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">bool</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">short、unsigned short</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">int、unsigned int</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">long、unsigned long</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">指针</td>\n<td align=\"center\">8</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、引言：\"><a href=\"#一、引言：\" class=\"headerlink\" title=\"一、引言：\"></a>一、引言：</h3><p>日常开发中，我们经常遇到指针，同时指针也是C语言里极为重要的一个知识点，今天我们就来把它彻底弄明白。</p>","more":"<h3 id=\"二：正文\"><a href=\"#二：正文\" class=\"headerlink\" title=\"二：正文\"></a>二：正文</h3><h4 id=\"变量与变量值\"><a href=\"#变量与变量值\" class=\"headerlink\" title=\"变量与变量值:\"></a>变量与变量值:</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据类型（int） 变量名（a） = 值（10）</span><br><span class=\"line\">int a = 10;</span><br></pre></td></tr></table></figure>\n\n<p>变量：变量是一个<strong>抽象概念</strong>，可以理解为允许存放数据的空间。当声明一个变量，计算机就会分配空间存放数据。变量可以通过变量名访问。</p>\n<p>变量值：变量里面存储的数据即为变量值，变量值可以为数值、字符等类型。</p>\n<h4 id=\"指针：\"><a href=\"#指针：\" class=\"headerlink\" title=\"指针：\"></a>指针：</h4><p><strong>指针：</strong>是一种<u>变量</u>，它的值是一个<strong>内存地址</strong>。（从三个方面分析指针：指针的类型、指针所指向的类型、指针的值）</p>\n<p><strong>指针类型：</strong><code>数据类型 *</code>，int *：整形数据类型的指针； char *： 字符数据类型的指针； void *：无数据类型的指针；等等…</p>\n<p><strong>取地址运算：</strong><code>&amp;变量 </code> ，取得的结果是变量的<strong>首</strong>地址，是一个<strong>值</strong>（eg：x10db5640）。</p>\n<p><strong>取变量运算：</strong><code>*指针变量</code>，取得的结果是一个变量。</p>\n<p>1.整形数据类型指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testIntExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //int类型变量a赋值为10</span><br><span class=\"line\">    int a = 10;</span><br><span class=\"line\">    //int*类型的指针变量b赋值为&amp;a</span><br><span class=\"line\">    int *b = &amp;a;</span><br><span class=\"line\">    //int类型变量c赋值为*b</span><br><span class=\"line\">    int c = *b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;变量b---值：%d 地址：%p&quot;,*b,b);</span><br><span class=\"line\">    printf(&quot;变量c---值：%d 地址：%p&quot;,c,&amp;c);</span><br><span class=\"line\">    </span><br><span class=\"line\">    打印结果：</span><br><span class=\"line\">    变量b---值：10 地址：0x10db5641c</span><br><span class=\"line\">    变量c---值：10 地址：0x10db5640c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：指针变量b的类型是：int *，指针变量b所指向的变量类型是int类型，b的值是一个地址：0x10db5641c。</p>\n<p>2.字符数据类型指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testCharExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    char *a = &quot;blog&quot;;</span><br><span class=\"line\">    char *b = a;</span><br><span class=\"line\">    char *c = b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;变量b所指变量的值：%s 变量b所指变量的首地址：%p 变量b的地址：%p&quot;,b,b,&amp;b);</span><br><span class=\"line\">    printf(&quot;变量c所指变量的值：%s 变量c所指变量的首地址：%p 变量c的地址：%p&quot;,c,c,&amp;c);</span><br><span class=\"line\">    </span><br><span class=\"line\">    打印结果：</span><br><span class=\"line\">\t\t变量b所指变量的值：blog 变量b所指变量的首地址：0x10a951bfc 变量b的地址：0x10a76f410</span><br><span class=\"line\">\t\t变量c所指变量的值：blog 变量c所指变量的首地址：0x10a951bfc 变量c的地址：0x10a76f408</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：char*类型指针 变量a 指向char类型变量blog，a的值是 变量blog的首地址0x10a951bfc。</p>\n<p>3.指针与数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testArrayExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int arr[] = &#123;4,12,34,6,7,788&#125;;</span><br><span class=\"line\">    int *a = arr;//得到的是arr的首地址</span><br><span class=\"line\">    int *b = &amp;arr[0];//得到的是arr数组第一个元素的地址</span><br><span class=\"line\">    int *c = arr + 1;//得到的是arr数组第二个元素的地址</span><br><span class=\"line\">    int *d = &amp;arr[0] + 1;//得到的是arr数组第二个元素的地址</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;a:%p---b:%p&quot;,a,b);//可以得出a和b是相等的</span><br><span class=\"line\">    printf(&quot;c:%p---d:%p&quot;,c,d);//可以得出c和d是相等的</span><br><span class=\"line\">    printf(&quot;num:%ld&quot;,c-a);//可以得出c和a之间有几个元素</span><br><span class=\"line\">    printf(&quot;数组中第一个元素的字节数：%ld&quot;,sizeof(arr[0]));//获取数组第一个元素的字节数</span><br><span class=\"line\">    </span><br><span class=\"line\">    *c = 99;</span><br><span class=\"line\">    printf(&quot;arr+1: %d---%p&quot;,*c,c);</span><br><span class=\"line\"></span><br><span class=\"line\">    //打印结果：</span><br><span class=\"line\">    a:0x106f54410---b:0x106f54410</span><br><span class=\"line\">    c:0x106f54414---d:0x106f54414</span><br><span class=\"line\">    num:1</span><br><span class=\"line\">    数组中第一个元素的字节数：4</span><br><span class=\"line\">    arr+1: 99---0x106f54414</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：</p>\n<p>1）arr 表示arr[]数组的首地址</p>\n<p>2）指针c - 指针a，能获取到两个指针之间有几个元素</p>\n<p>3）指针变量加减一个整数,p(指针)(+/-)n(整数)计算方式为：指针地址 (+/-) n * 变量占有的字节数</p>\n<p>4）sizeof的用法：</p>\n<ul>\n<li>每种类型的数据在内存单元中占有的字节数是固定的,因此sizeof(arr)/sizeof(arr[0]) = 数组的元素的个数</li>\n<li>sizeof(arr)：获取的是数组总共占有多少字节</li>\n<li>sizeof(arr[0])：获取的是数组中一个元素占有的字节数</li>\n</ul>\n<p>5）数组变量保存的是地址,但数组变量中保存的地址是不能改变的,注意说的是指针地址不能变,但是指针指向的值是可以变的,因此数组变量应称为指针常量，可以改变数组中地址中存储的值。</p>\n<h4 id=\"OC-应用场景示例：\"><a href=\"#OC-应用场景示例：\" class=\"headerlink\" title=\"OC 应用场景示例：\"></a>OC 应用场景示例：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//采用这种方式传参，可以获取到error的值</span><br><span class=\"line\">- (void)testErrorExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSError *err = nil;</span><br><span class=\"line\">    [self handleResponseCode:400 error:&amp;err];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;err---%p--%@&quot;,err,err);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //指针运算符&amp;和*是从右往左运算,他们的优先级相同。*&amp;err和err一样。</span><br><span class=\"line\">    NSLog(@&quot;*&amp;err---%p--%@&quot;,*&amp;err,*&amp;err);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 &quot;(null)&quot; UserInfo=&#123;data=99&#125;</span><br><span class=\"line\">    *&amp;err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 &quot;(null)&quot; UserInfo=&#123;data=99&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleResponseCode:(NSInteger)code error:(NSError **)error&#123;</span><br><span class=\"line\">    if (code != 0) &#123;</span><br><span class=\"line\">        *error = [NSError errorWithDomain:NSCocoaErrorDomain code:100 userInfo:@&#123;@&quot;data&quot;:@&quot;99&quot;&#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"三、扩展\"><a href=\"#三、扩展\" class=\"headerlink\" title=\"三、扩展\"></a>三、扩展</h3><ol>\n<li><p>操作系统分为32位和64位，32位的最多只能支持4GB的内存，因为计算机底层并不使用十进制，使用的是二进制，32位的二进制只能支持4G个编号，这意味着操作系统只能为4GB的内存单元编号，因此32位的操作系统最多只能支持4GB的内存，多余的内存不会有编号,因此无法将数据存入这些内存单元中。</p>\n</li>\n<li><p>指针存储于栈区，不同数据类型的指针大小都相等，因为他们的值都是一个地址，并且长度也相同。32位操作系统中，指针大小是4个字节，64位操作系统中指针大小是8个字节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面代码是在64位操作系统演示</span><br><span class=\"line\">-(void)testGetPointerNum &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    char *a = &quot;myBlog&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int num1 = 1234325;</span><br><span class=\"line\">    int *b = &amp;num1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    double num2 = 3232.434;</span><br><span class=\"line\">    double *c = &amp;num2;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;char *类型指针变量a所占字节数：%ld&quot;,sizeof(a));</span><br><span class=\"line\">    printf(&quot;int *类型指针变量b所占字节数：%ld&quot;,sizeof(b));</span><br><span class=\"line\">    printf(&quot;double *类型指针变量c所占字节数：%ld&quot;,sizeof(c));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    char *类型指针变量a所占字节数：8</span><br><span class=\"line\">    int *类型指针变量b所占字节数：8</span><br><span class=\"line\">    double *类型指针变量c所占字节数：8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结构体数据类型变量的大小：<code>对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testStructExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data1&#123;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        char b;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data2&#123;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        char b;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data1 p1;</span><br><span class=\"line\">    p1.a = 1;</span><br><span class=\"line\">    p1.b = &#x27;d&#x27;;</span><br><span class=\"line\">    p1.c = &#x27;f&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data2 p2;</span><br><span class=\"line\">    p2.a = 1;</span><br><span class=\"line\">    p2.b = &#x27;d&#x27;;</span><br><span class=\"line\">    p2.c = &#x27;f&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;p1结构体占用的字节个数为：%ld&quot;,sizeof(p1));</span><br><span class=\"line\">    printf(&quot;p2结构体占用的字节个数为：%ld&quot;,sizeof(p2));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    p1结构体占用的字节个数为：8</span><br><span class=\"line\">    p2结构体占用的字节个数为：12</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"结构体内存结构示意图\"></p>\n<p>你可以看到，在 Data1 中，首先是 int 类型的 a 变量，占用了第一个存储单元，然后 b 和 c 占用了第二个存储单元的前两个字节。再看 Data2，由于 Data2 不同于 Data1 的字段顺序，b 占用了第一个存储单元的第一个字节，剩余的 3 个字节不够存放一个 int 类型变量的，所以按照上面我们讲的规则“当本存储单元不够安放的时候，就从下个存储单元的头部开始安放”， a 变量就单独占用了第二个存储单元，c 自己占用第三个存储单元的第一个字节。所以，虽然在数据表示上，Data1 和 Data2 是等价的，可 Data2 却占用了更多的存储空间，相比于 Data1 造成了 50% 的空间浪费。由此可见，在设计结构体的时候，不仅要设计新的结构体类型中所包含的数据字段，还需要关注各个字段之间的顺序排布。</p>\n</li>\n<li><p>32位操作系统内存与地址分布图：</p>\n</li>\n</ol>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png\" alt=\"内存空间布局\"></p>\n<ol start=\"5\">\n<li><p>64位操作系统常用数据类型占用的内存大小：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">常用数据类型</th>\n<th align=\"center\">占用内存大小（字节）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char、unsigned char</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">bool</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">short、unsigned short</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">int、unsigned int</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">long、unsigned long</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">指针</td>\n<td align=\"center\">8</td>\n</tr>\n</tbody></table>\n</li>\n</ol>"},{"title":"内存管理一","date":"2021-06-22T06:18:11.000Z","_content":"\n\n\n> 一、iOS内存管理方式：\n>\n> ​\t1.Tagged Pointer：小对象的内存管理方式\n>\n> ​\t2.引用计数：普通对象的内存管理方式\n>\n> 二、MRC介绍，需要开发工程师做哪些工作\n>\n> 三、ARC介绍，编译器帮我们做了什么\n>\n> <!--more-->\n>\n> ​\t1.指针修饰符\n>\n> ​\t\t1. __strong\n>\n> ​\t\t2. __weak\n>\n> ​\t\t3. __unsafe_unretained\n>\n> ​\t\t4. __autoreease\n>\n> ​\t2.属性修饰符\n>\n> ​\t\t2.1 原子性：`atomic`、`nonatomic`\n>\n> ​\t\t2.2 读写权限：`readwrite`、`readonly`\n>\n> ​\t\t2.3 内存管理语义：`assign`、`retain`、`copy`、`strong`、`weak`、`unsafe_unretained`\n\n### 一、内存管理方式：\n\n#### 1.Tagged Pointer：小对象的内存管理方式\n\n64位操作系统后，iOS引入了Tagged Pointer，用来优化NSString、NSNumber、NSDate的内存管理。\n\n引入Tagged Pointer之前（32位操作系统时），小对象内存管理方式和普通对象一样，首先需要在堆区开辟一块内存，并把内存的地址赋值给栈区的指针变量，然后维护对象的引用计数和内存的释放。\n\n比如我们创建一个int类型的NSNumber对象：\n\n```objective-c\nNSNumber *number = @11;\n```\n\n系统需要开辟16个字节的内存来存储11这个值，同时需要开辟8个字节大小的内存来存储这个对象的地址，本来需要占用4个字节的内存的Int类型数据，占用了24个字节，同时还没考虑维护引用计数和内存释放等的内存开销。\n\n![使用Tagged pointer前的内存管理](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/nsnumber.png)\n\n在引入Tagged Pointer之后，**小对象就不需要像之前那样 在堆区开辟内存，维护引用计数，释放内存了。而是直接把值存到了number指针里，number里面存的不再是一个地址了，而是Tag + Data，Tag是用来标记小对象的类型（NSString、NSNumber、NSDate），Data就是小对象的值。指针什么时候创建，小对象就什么时候创建，指针什么时候销毁，小对象就什么时候销毁。只有在指针存不下小对象的值时，才会变为引用计数的方式管理内存。**这样，仅需要8个字节就可以存储小对象的类型和值，很大程度上节省了内存占用，同时也减少了维护引用计数、内存释放等带来的开销。\n\n![使用Tagged Pointer后的内存管理](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E4%BD%BF%E7%94%A8Tagged.png)\n\n用代码验证一下：\n\n```objective-c\n//  苹果对Tagged Pointer做了数据混淆，所以在分析Tagged Pointer之前，我们需要先关闭Tagged Pointer的数据混淆。通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为YES。否则无法分析打印出的结果\n- (void)testTaggedPointer {\n    \n    NSNumber *number1 = @1;\n    NSNumber *number2 = @2;\n    NSNumber *number3 = @10;\n    NSNumber *number4 = @(0xFFFFFFFFFFFFFFFF);\n\n    NSLog(@\"number1:%p\", number1);\n    NSLog(@\"number2:%p\", number2);\n    NSLog(@\"number3:%p\", number3);\n    NSLog(@\"number4:%p\", number4);\n}\n\nnumber1:0xb000000000000012\nnumber2:0xb000000000000022\nnumber3:0xb0000000000000a2\nnumber4:0x600001be2060\n```\n\nnumber1～number3指针是Tagged Pointer，number4由于值大到存储不下了，改为普通对象内存管理方式。对应的地址分布规律见下图（mac os系统的规律与iOS系统的规律不同 [详细](https://cloud.tencent.com/developer/article/1620346)），可发现规律**如果一个指针的最高位为1，那么他就是Tagged Pointer，否则就不是。**\n\n![ios-nsnumber](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623191932.png)\n\n如果是NSString的话，Tagged Pointer内存地址分布规律就是下面这样的：\n\n![ios-nsstring](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623195417.png)\n\n\n\n学习完上面内容，我们举个例子验证下，找不同：\n\n```objectivec\n// 开辟多个线程去修改name属性\n// 代码1\nfor (int i = 0; i < 1000; i++) {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        self.name = [[NSString alloc] initWithFormat:@\"abcdefghijk\"];\n    });\n}\n\n// 代码2\nfor (int i = 0; i < 1000; i++) {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        self.name = [[NSString alloc] initWithFormat:@\"abc\"];\n    });\n}\n```\n\n运行代码我们会发现 代码1 会crash，因为`abcdefghijk`已经大到指针存储不下，改为了普通对象内存管理方式，所以 代码1 就是正常的调用`setter`方法修改`name`属性,`setter`的实现是这样的：\n\n```objectivec\n- (void)setName:(NSString *)name {\n    if (_name != name) { // 新旧对象不一样时\n        [_name release]; // 释放旧对象\n        _name = [name copy]; // 复制新对象\n    }\n}\n```\n\n在不加锁的情况下，极容易发生多个线程同时调用`[_name release]`的情况，若`_name`已经销毁，再次调用`release`肯定会发生crash。\n\n代码2 正常运行，是因为`abc`并没有大到指针存储不下，`NSString`为`NSTaggedPointerString`类型，在`objc_release`函数中会判断指针是不是`TaggedPointer`类型，是的话就不对对象进行`release`操作，也就避免了因过度释放对象而导致的`Crash`，因为根本就没执行释放操作。\n\n\n\n#### 2.引用计数：普通对象的内存管理方式\n\n**2.1 引用计数是什么？**\n\n**iOS是通过引用计数来管理内存的。所谓的引用计数就是指每当我们创建一个对象，系统就会为该对象分配一个整数，用来表征当前有多少人想使用该对象。**那就引出两个问题：\n\n问题1：创建对象时，系统为对象分配的整数存在哪里？也就是引用计数存在哪里？因为我们知道OC对象内部只有一个`isa`，并没有引用计数的成员变量\n\n问题2：iOS具体是怎么通过引用计数来管理内存的？\n\n\n\n**2.2 引用计数存储在哪里？**\n\n64位操作系统以前，对象的`isa`指针还没进行内存优化，对象的引用计数存储在引用计数表里。\n\n当系统为64位操作系统后，对象的`isa`指针经过了内存优化，它不再直接是一个指针了，而是一个共用体，64位中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1），还有1位用来标记引用计数表里是否有当前对象的引用计数。具体地说：**对象的引用计数首先会存储在`isa`共用体里——`extra_rc`变量，但是`isa`共用体的引用计数存储范围是0～255，一旦引用计数超过了255，这个变量就会溢出，此时系统会把这个变量置为128，同时把引用计数表里是否有当前对象的引用计数的标记——`has_sidetable_rc`变量置为1，并把另外128个引用计数挪到引用计数表里进行存储。下一次对象的引用计数再次增加时，依旧增加`isa`共用体里的引用计数（因为它已被置为128，不再是溢出状态），直到再次溢出，系统再娜128个引用计数到引用计数表里，如此循环往复。**\n\n因此可以看出，系统是不会直接操作引用计数表里的引用计数的，而总是在操作`isa`共用体里的引用计数，直到溢出时才从`isa`共用体里挪128个引用计数到引用计数表里进行存储。\n\n- `isa`共用体\n\n  ```cpp\n  struct objc_object {\n      isa_t isa; // 一个isa_t类型的共用体\n  \n      // 自定义的成员变量，存储着该对象这些成员变量具体的值\n      NSSring *_name; // “张三”\n      NSSring *_sex; // “男”\n      int _age; // 33\n  }\n  \n  union isa_t {\n      Class cls;\n      \n      unsigned long bits; // 8个字节，64位\n      struct { // 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着谁的数据\n  # if __arm64__\n  #   define ISA_MASK        0x0000000ffffffff8ULL\n          unsigned long nonpointer        : 1; // isa是否经过内存优化\n          unsigned long has_assoc         : 1;\n          unsigned long has_cxx_dtor      : 1;\n          unsigned long shiftcls          : 33; // 对象所属类的地址信息\n          unsigned long magic             : 6;\n          unsigned long weakly_referenced : 1;\n          unsigned long deallocating      : 1;\n          unsigned long has_sidetable_rc  : 1; // 引用计数表里是否有当前对象的引用计数\n          unsigned long extra_rc          : 19; // 对象的引用计数 - 1\n  # endif\n      };\n  };\n  ```\n\n- `SideTables`-->`SideTable`-->引用计数表、若引用表\n\n![SideTables](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220627183629.png)\n\n```objective-c\nstatic StripedMap<SideTable>& SideTables() {\n    return *reinterpret_cast<StripedMap<SideTable>*>(SideTableBuf);\n}\n\nstruct SideTable {\n    spinlock_t slock; // 自旋锁\n    RefcountMap refcnts; // 引用计数表\n    weak_table_t weak_table;\n}\n\ntypedef objc::DenseMap<objc_object */*对象的内存地址*/, unsigned long/*对象的引用计数*/> RefcountMap;\n\nstruct weak_table_t {\n    weak_entry_t *weak_entries; // 这个其实才是弱引用表，表中元素为weak_entry_t结构体\n    size_t    num_entries;\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\nstruct weak_entry_t {\n    objc_object *obj; // 对象的内存地址\n    weak_referrer_t *referrers; // 指向该对象的弱指针数组——即所有指向该对象的弱指针（其实存储的是弱指针对应那块内存的地址，但是我们直接理解为弱指针是没有问题的）\n}\n// 例如：\nid obj = [[NSObject alloc] init];\n__weak id weakObj1 = obj;\n__weak id weakObj2 = obj;\n__weak id weakObj3 = obj;\n\n// NSObject对象的weak_entry为：\nstruct weak_entry_t {\n    objc_object *obj; // 对象的内存地址\n    weak_referrer_t *referrers; // 指向该对象的弱指针数组\n} NSObjectWeakEntry = {\n    obj;\n    [weakObj1, weakObj2, weakObj3]\n}\n```\n\n`SideTables`是一个全局的散列表，它里面存储着64个`SideTable`结构体，而每个`SideTable`结构体内部又存储着1个引用计数表和1个弱引用计数表，所以项目中一般会有64个引用计数表和64个弱引用计数表。引用计数表也是一个散列表，表中的元素是一个字典：`key`为对象的内存地址，`value`为对象的引用计数，引用计数表里存储着很多对象的引用计数。若引用计数表也是一个散列表，表中的元素是一个结构体：一个成员变量是对象的内存地址，另一个成员变量是指向该对象的弱指针数组。\n\n所以如果我们想要找到对象的引用计数和弱指针数组，就要首先把对象的内存地址通过某种散列算法得到一个`index`，就可以在`SideTables`里找到对象的引用计数和弱指针数组所在的`SideTable`结构体，也就是找到了引用计数和弱指针数组所在的引用计数表和弱引用计数表，然后再次把对象的内存地址通过某种散列算法得到一个`index`，就可以在引用计数表里找到对象的引用计数，弱引用计数表里找到对象的弱指针数组了。\n\n\n\n**2.3 iOS具体是怎么通过引用计数来进行对象的内存管理的**\n\n主要是通过`alloc`、`new`、`alloc`、`copy`、`mutableCopy`，`retain`，`release`、`autorelease`，`dealoc`这几个方法操作引用计数，来管理对象内存管理的，即：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628181747.png)\n\n```cpp\n// NSObject.mm\n- (void)release {\n    self->rootRelease();\n}\n\nbool objc_object::rootRelease()\n{\n    return rootRelease(true, false);\n}\n\nbool objc_object::rootRelease(bool performDealloc, bool handleUnderflow)\n{\n    if (isTaggedPointer()) return false;\n\n    isa_t newisa = LoadExclusive(&isa.bits);\n\n    if (!newisa.nonpointer) {\n        \n        // 去引用计数表里让它的引用计数-1\n        return sidetable_release(performDealloc);\n    }\n    \n\n    // 用来标识extra_rc是否下溢——即是否减为-1（因为extra_rc存储的是（引用计数 - 1），所以减为0的时候说明引用计数为1，还有人引用它，没事儿）\n    uintptr_t carry;\n    // 首先去isa共用体里，让对象的引用计数-1\n    newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);\n    if (carry) { // 所以如果extra_rc下溢了：\n    \n        goto underflow; // 跳转到underflow处执行\n    }\n\n    // 表明没有下溢，结束\n    return false;\n\n underflow: // extra_rc下溢了：\n\n    newisa = LoadExclusive(&isa.bits);\n\n    if (newisa.has_sidetable_rc) { // 如果引用计数表里有当前对象的引用计数，说明还有人使用该对象\n\n        // 尝试从引用计数表搬回来128个引用计数\n        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);\n        if (borrowed) { // 如果搬成功了\n            \n            // 存进去\n            newisa.extra_rc = borrowed - 1;\n            // 更新一下对象的isa共用体\n            isa = newisa;\n        } else { // 搬失败了，说明引用计数表里的引用计数也为0了（可能是被上一次搬完了）\n            \n            // 走dealloc方法销毁该对象\n            ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n        }\n    } else { // 引用计数表里没有当前对象的引用计数，说明没人使用该对象了\n        \n        // 走dealloc方法销毁该对象\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n    }\n    \n    return true;\n}\n\n// 尝试从引用计数表搬回来128个引用计数\nsize_t objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)\n{\n    SideTable& table = SideTables()[this];\n    RefcountMap::iterator it = table.refcnts.find(this);\n    \n    if (it == table.refcnts.end()  ||  it->second == 0) { // 引用计数表里的引用计数被上一次搬完了\n\n        return 0;\n    }\n    \n    // 引用计数表里的引用计数-128，搬出去\n    size_t oldRefcnt = it->second;\n    size_t newRefcnt = oldRefcnt - (delta_rc << SIDE_TABLE_RC_SHIFT);\n    it->second = newRefcnt;\n    \n    return delta_rc;\n}\n```\n\n>关于`autorelease`和`autoreleasepool`就暂时理解这么一点，更底层的东西有空再说：\n>\n>- `release`会立即使对象的引用计数-1，而`autorelease`则不会，它仅仅是把该对象注册到了`autoreleasepool`中，当`autoreleasepool`销毁时系统会自动让池中所有的对象都调用一下`release`，这时对象的引用计数才-1。\n>- 而`autoreleasepool`又是在RunLoop休眠或退出时销毁的，当然如果是我们自己创建的`@autoreleasepool{}`，出了大括号——即出了`@autoreleasepool{}`的生命周期，它就会销毁。\n>- 只要不是用`alloc`、`new`、`copy`、`mutableCopy`方法创建的对象，而是用类方法创建的对象，方法内部都调用了`autorelease`，都是`autorelease`对象。\n\n- 如果对象的引用计数减为0了，就代表没人想使用该对象了，系统就会调用`dealloc`方法销毁它，并释放它对应的内存，对象一经销毁就不能再访问了，因为他的内存随时会被移作它用。\n\n  ![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628182915.png)\n\n```cpp\n// NSObject.mm\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid _objc_rootDealloc(id obj)\n{\n    obj->rootDealloc();\n}\n\nvoid objc_object::rootDealloc()\n{\n    if (\n        !isa.has_cxx_dtor  && // 如果当前对象没使用过C++析构函数\n        !isa.has_assoc  && // 如果当前对象没有关联对象\n        !isa.weakly_referenced  && // 如果弱引用表里没有当前对象的弱指针数组\n        !isa.has_sidetable_rc // 如果引用计数表里没有当前对象的引用计数\n        )\n    {\n        // 就直接销毁对象，并释放它对应的内存，即我们之前说的对象销毁时会更快\n        free(this);\n    } else {\n        \n        // 否则就慢慢销毁\n        object_dispose(this);\n    }\n}\n\nid object_dispose(id obj)\n{\n    objc_destructInstance(obj);\n    // 销毁对象，并释放它对应的内存，\n    free(obj);\n\n    return nil;\n}\n\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        \n        // 如果当前对象使用过C++析构函数\n        bool cxx = obj->hasCxxDtor();\n        // 如果当前对象有关联对象\n        bool assoc = obj->hasAssociatedObjects();\n\n        // 要按顺序销毁哦\n        if (cxx) object_cxxDestruct(obj); // 销毁C++析构函数相关的东西\n        if (assoc) _object_remove_assocations(obj); // 移除关联对象\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n\nvoid objc_object::clearDeallocating()\n{\n    clearDeallocating_slow();\n}\n\nvoid objc_object::clearDeallocating_slow()\n{\n    // 获取SideTable\n    SideTable& table = SideTables()[this];\n\n    if (isa.weakly_referenced) { // 如果弱引用表里有当前对象的弱指针数组\n        \n        // 把弱引用表里所有指向该对象的弱指针都置为nil，并移除，从此弱引用表里就没有该对象的弱指针数组（关于弱指针（弱引用）更多详细的内容，见下面__weak指针的实现原理）\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    \n    if (isa.has_sidetable_rc) { // 如果引用计数表里有当前对象的引用计数\n        \n        // 从引用计数表里把该对象的引用计数给抹掉，从此引用计数表里就没有该对象的引用计数了\n        table.refcnts.erase(this);\n    }\n}\n```\n\n### 二、MRC介绍，需要开发工程师做哪些工作\n\nMRC（*Manual Reference Count*）：指手动管理引用计数，即需要程序员自己手动调用上面那几个`alloc`、`new`、`alloc`、`copy`、`mutableCopy`，`retain`，`release`、`autorelease`，`dealoc`方法来操作引用计数，从而完成对象的内存管理。具体地说，MRC下我们需要做到以下三点：\n\n- 调用了`alloc`、`new`、`alloc`、`copy`、`mutableCopy`创建对象的地方，在不想使用对象时，要调用\n\n`release`、`autorelease`；调用了`retain`使对象引用计数+1的地方，在不想使用对象时，要调用\n\n`release`、`autorelease`来使对象的引用计数-1。\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    // 调用了alloc、new、copy、mutableCopy创建对象\n    NSArray *arr = [[NSArray alloc] init];\n    NSArray *arr1 = [NSArray new];\n    NSArray *arr2 = [arr copy];\n    NSMutableArray *arr3 = [arr1 mutableCopy];\n    \n    // 调用release、autorelease来释放对象\n    [arr release];\n    [arr1 release];\n    [arr2 autorelease];\n    [arr3 autorelease];\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    NSArray *arr = [NSArray array];\n    // 调用了retain使对象引用计数+1\n    [arr retain];\n\n    // 要调用release、autorelease来使对象的引用计数-1\n    [arr release];\n  \n    //或者调用下面\n    //[arr autorelease];\n}\n```\n\n- 我们还需要处理好`setter`方法内部的内存管理，并在`dealloc`方法里释放当前类及其父类**所有对象类型**的成员变量。\n\n```objectivec\n@implementation INEPerson {\n    int _age;\n    NSString *_name;\n    INEDog *_dog;\n}\n\n- (void)setAge:(int)age {\n    \n    _age = age; // 直接赋值\n}\n\n- (void)setName:(NSString *)name {\n\n    if (_name != name) { // 新旧对象不一样时\n        \n        [_name release]; // 释放旧对象\n        _name = [name copy]; // 复制新对象\n    }\n}\n\n- (void)setDog:(INEDog *)dog {\n    \n    if (_dog != dog) { // 新旧对象不一样时\n        \n        [_dog release]; // 释放旧对象\n        _dog = [dog retain]; // 持有新对象\n    }\n}\n\n- (void)dealloc {\n    \n    // 释放当前类所有对象类型的成员变量\n    [self setName:nil];\n    [self setDog:nil];\n\n    // 释放父类所有对象类型的成员变量，放在最后\n    [super dealloc];\n}\n\n@end\n```\n\n- 我们还需要处理好循环引入问题。\n\n```objectivec\n// INEMan.h\n#import <Foundation/Foundation.h>\n@class INEWoman;\n\n@interface INEMan : NSObject\n\n- (void)setWoman:(INEWoman *)woman;\n\n@end\n\n\n// INEMan.m\n#import \"INEMan.h\"\n#import \"INEWoman.h\"\n\n@implementation INEMan {\n    \n    INEWoman *_woman;\n}\n\n- (void)setWoman:(INEWoman *)woman {\n\n    if (_woman != woman) { // 新旧对象不一样时\n\n        [_woman release]; // 释放旧对象\n        _woman = [woman retain]; // 持有新对象\n    }\n}\n\n- (void)dealloc {\n  \n    NSLog(@\"%s\", __func__);\n    \n    [self setWoman:nil];\n    \n    [super dealloc];\n}\n\n@end\n```\n\n```objectivec\n// INEWoman.h\n#import <Foundation/Foundation.h>\n@class INEMan;\n\n@interface INEWoman : NSObject\n\n- (void)setMan:(INEMan *)man;\n\n@end\n\n\n// INEWoman.m\n#import \"INEWoman.h\"\n#import \"INEMan.h\"\n\n@implementation INEWoman {\n    \n    INEMan *_man;\n}\n\n- (void)setMan:(INEMan *)man {\n\n    _man = man; // 为了避免循环引用，这里不能retain\n}\n\n- (void)dealloc {\n  \n    NSLog(@\"%s\", __func__);\n    \n    [self setMan:nil];\n    \n    [super dealloc];\n}\n\n@end\n```\n\n```csharp\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    INEMan *man = [[INEMan alloc] init];\n    INEWoman *woman = [[INEWoman alloc] init];\n    \n    [man setWoman:woman];\n    [woman setMan:man];\n    \n    [man release];\n    [woman release];\n}\n\n// 控制台打印：两个对象都可以正常销毁\n-[INEWoman dealloc]\n-[INEMan dealloc]\n```\n\n#### 三、ARC介绍，编译器帮我们做了什么\n\nARC（*Autal Reference Count*）：自动管理引用计数，让**编译器**进行内存管理，**在LVVM编译器中设置ARC为有效状态，就无需再次键入`retain`、`realeas`、`autorelease`代码，编译器会在合适的地方自动帮我们插入`retain`、`release`、`autorelease`等方法的调用，从而完成对象的内存管理。但实际上除了编译器之外，ARC还用到了Runtime，比如`weak`指针的清空。**这样就会在降低程序崩溃、内存泄漏风险的同时，很大程度程度减少了开发的工作量，使应用程序具有可预测性，且能流畅运行，速度也将大幅提升。具体来说，与MRC相对应，ARC帮我们做了如下三点：\n\n- 利用`__strong`指针修饰符，编译器会在合适的地方帮们插入`retain`、`release`、`autorelease`等方法的调用；\n\n- 利用属性修饰符，编译器为我们生成特定的`setter`方法并处理好内部的内存管理，还会自动在`dealloc`方法里释放当前类及其父类的成员变量；\n\n- 利用`__weak`指针修饰符和Runtime，来处理循环引入问题。\n\n#### 1.指针修饰符\n\n- `__strong`指针修饰符\n\n  凡是用`__strong`修饰的指针，在超出其作用域时，编译器会为我们插入一次`release`或`autorelease`的调用。\n\n  ```objectivec\n  // ARC下\n  {\n      __strong id obj = [[NSObject alloc] init];\n      __strong id arr = [NSArray array];\n  }\n  \n  等价于：\n  \n  // MRC下\n  {\n      id obj = [[NSObject alloc] init];\n      id arr = [[NSArray alloc] init];\n      \n      [obj release];\n      [arr autorelease];\n  }\n  ```\n\n而在指针赋值时，编译器会自动为我们插入一次`retain`的调用。\n\n```objectivec\n// ARC下\n{\n    __strong id obj = [[NSObject alloc] init];\n    __strong id obj1 = obj;\n}\n\n等价于：\n\n// MRC下\n{\n    id obj = [[NSObject alloc] init];\n    id obj1 = [obj retain];\n    \n    [obj release];\n    [obj1 release];\n}\n```\n\n所以正是因为使用`__strong`指针修饰符，编译器才会在合适的地方帮我们插入`retain`、`release`、`autorelease`等方法的调用，而ARC下所有指针默认都是用`__strong`修饰的。\n\n- `__weak`指针修饰符\n\n看起来有了`strong`,编译器就可以很好的管理内存了，但是很重要的一点是`__strong`无法解决引用计数式内存管理必然会导致的“循环引入”问题。\n\n```objectivec\n// INEMan.h\n#import <Foundation/Foundation.h>\n@class INEWoman;\n\n@interface INEMan : NSObject {\n    \n    __strong INEWoman *_woman; // 强引用\n}\n\n- (void)setWoman:(INEWoman *)woman;\n\n@end\n\n\n// INEMan.m\n#import \"INEMan.h\"\n\n@implementation INEMan \n\n- (void)setWoman:(INEWoman *)woman {\n\n    _woman = woman;\n}\n\n- (void)dealloc {\n  \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n```objectivec\n// INEWoman.h\n#import <Foundation/Foundation.h>\n@class INEMan;\n\n@interface INEWoman : NSObject {\n    \n    __strong INEMan *_man; // 强引用\n}\n\n- (void)setMan:(INEMan *)man;\n\n@end\n\n\n// INEWoman.m\n#import \"INEWoman.h\"\n\n@implementation INEWoman\n\n- (void)setMan:(INEMan *)man {\n\n    _man = man;\n}\n\n- (void)dealloc {\n  \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n```csharp\n// ViewController.m\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    INEMan *man = [[INEMan alloc] init];\n    INEWoman *woman = [[INEWoman alloc] init];\n    \n    [man setWoman:woman];\n    [woman setMan:man];\n}\n\n// 控制台打印：无\n```\n\n`viewDidLoad`执行完，`Man`对象和`Woman`对象的`dealloc`方法都没走，也就是说它们俩都没销毁，这就是因为它们俩形成了循环引用，导致了内存泄漏。\n\n但是只要我们把循环引用中的一个强指针的换成弱指针，就可以解决问题。\n\n```objectivec\n@interface INEMan : NSObject {\n    \n     __weak INEWoman *_woman; // 弱引用\n}\n\n或者：\n\n@interface INEWoman : NSObject {\n    \n    __weak INEMan *_man; // 强引用\n}\n```\n\n为什么能解决呢？这就要来看看**`__weak`指针的实现原理：**\n\n- **`__weak`指针是专门用来解决循环引用问题的，它不是通过引用计数来管理对象的，而是通过弱引用表。**具体地说：\n\n  **1.当我们把一个强指针赋值给一个弱指针时，编译器不会怒自动帮我们插入`retain`使对象的引用计数+1，而是把这个弱指针和对象的内存地址绑在一起，通过两次散列算法找到弱引用计数表里的弱指针数组，然后把这个弱指针存到弱指针数组里。这样我们通过这些弱指针既可以正常使用该对象，又无需顾虑是不是要在什么时候把对象的引用计数-1，以免对象的引用计数>0而无法销毁，因为他没有参数引用计数那一套。**\n\n  **2.当对象销毁时会走dealloc方法，又会通过两次散列算法找到弱引用计数表里的数组，把指向该对象的弱指针都置为`nil`并移除。**\n\n#### 2.属性修饰符\n\n属性修饰符一共有三对儿：**原子性、读写权限和内存管理语意**，属性修饰符主要影响就是编译器为成员变量生成的`setter`、`getter`方法上。（这里除了讲解和内存相关的知识外，其他的也回顾一下）\n\n> 原子性：`atomic`（默认）、`nonatomic`\n\n- `atomic`：默认为`atomic`，使用`atomic`修饰的属性，编译器为该属性生成的`setter`、`getter`方法内部是加了锁的。\n\n  ```objectivec\n  @property (atomic, strong) NSMutableArray *array;\n  \n  - (void)setArray:(NSMutableArray *)array {\n      \n      // 加锁\n      _array = array;\n      // 解锁\n  }\n  \n  - (NSMutableArray *)array {\n      // 加锁\n      return _array;\n      // 解锁\n  }\n  ```\n\n但这仅仅是保证我们调用`setter`、`getter`方法访问属性这一步是线程安全的，它没发保证我们使用属性的线程是安全的，比如我们调用`[self.array addObject:xxx]`,`self.array`访问属性这一步是线程安全的，但`addObject:`使用属性这一步是线程不安全的。\n\n```objective-c\n// 线程1\n[self.array addObject:@\"11\"];\n// 线程2\n[self.array addObject:@\"12\"];\n\n等价于\n\n// 线程1\n[[self array] addObject:@\"11\"];\n// 线程2\n[[self array] addObject:@\"12\"];\n```\n\n所以为了保证使用属性的线程安全，我们还得在需要的地方自己加锁，这样一来使用使用`atomic`修饰属性就多此一举了，而且`stter`、`getter`方法的调用通常都是很频繁的，内部加锁的话会增加内存的开销，耗费性能。\n\n```php\n// 线程1\n// 加锁\n[self.array addObject:@\"11\"];\n// 解锁\n\n// 线程2\n// 加锁\n[self.array addObject:@\"12\"];\n// 解锁\n```\n\n- `nonatomic`：因此我们在实际开发中总是使用`nonatomic`。\n\n> 读写权限：`readwrite`(默认)、`readonly`\n\n- `readwrite`：默认为`readwrite`，代表该属性可读可写，编译器会为该属性生成`setter`\n\n`getter`方法的声明与实现。\n\n- `readonly`：代表该属性只能读取不能写入，编译器会为该属性生成`setter`、`getter`方法的声明与`getter`方法的实现。\n\n> 内存管理语意：\n>\n> - MRC下有：`assign`、`retain`、`copy`。\n> - ARC下新增了：`strong`、`weak`、`unsafe_unretained`。\n\n- `assign`：`assign`一般来修饰基本数据类型。使用`assign`修饰属性，编译器为属性生成的`setter`方法内部只是简单的赋值操作。\n\n```cpp\n- (void)setAge:(int)age {\n    \n    // 简单的赋值操作\n    _age = age;\n}\n```\n\n- `retain`：`retain`一般用来修饰对象类型。使用`retain`修饰的属性，编译器为该属性生成的`setter`方法内部会调用一下`retain`方法，是对象的引用计数+1。\n\n  ```objective-c\n  - (void)setDog:(Dog *)dog {\n      \n      if (_dog != dog) { // 新旧对象不一样时\n          \n          [_dog release]; // 释放旧对象\n          _dog = [dog retain]; // 持有新对象\n      }\n  }\n  ```\n\n- `copy`：`copy`一般用来修饰不可变属性和block。使用`copy`修饰的属性，编译器为该属性生成的`setter`方法内部会调用一下`copy`方法，生成一个新的对象，新对象的引用计数为1，而旧对象的引用计数不变。\n\n  ```objectivec\n  - (void)setName:(NSString *)name {\n  \n      if (_name != name) { // 新旧对象不一样时\n          \n          [_name release]; // 释放旧对象\n          _name = [name copy]; // 复制新对象\n      }\n  }\n  ```\n\n- `strong`：默认为`strong`，大多数情况下和`retain`的效果是一样的，修饰block和`copy`的效果是一样的，`strong`一般用来修饰对象类型。\n- `weak`：`weak`一般用来修饰代理对象和`NSTimer`，以免造成循环引入；还有用来修饰xib或sb拖出来的控件，因为这些界面已经被添加到界面上了，被subviews这个属性持有了，不必再用变量持有。\n\n- `unsafe_unretained`：和`assign`效果是一样的，如果用他们来修饰对象类型，和`weak`功能类似，但`weak`修饰的属性会在对象销毁时会被置为`nil`，比较安全，而`unsafe_unretained`和`assign`修饰的属性则不会，所以容易出现野指针。\n\n","source":"_posts/内存管理一.md","raw":"---\ntitle: 内存管理一\ndate: 2021-06-22 14:18:11\ntags: 内存管理系列\n---\n\n\n\n> 一、iOS内存管理方式：\n>\n> ​\t1.Tagged Pointer：小对象的内存管理方式\n>\n> ​\t2.引用计数：普通对象的内存管理方式\n>\n> 二、MRC介绍，需要开发工程师做哪些工作\n>\n> 三、ARC介绍，编译器帮我们做了什么\n>\n> <!--more-->\n>\n> ​\t1.指针修饰符\n>\n> ​\t\t1. __strong\n>\n> ​\t\t2. __weak\n>\n> ​\t\t3. __unsafe_unretained\n>\n> ​\t\t4. __autoreease\n>\n> ​\t2.属性修饰符\n>\n> ​\t\t2.1 原子性：`atomic`、`nonatomic`\n>\n> ​\t\t2.2 读写权限：`readwrite`、`readonly`\n>\n> ​\t\t2.3 内存管理语义：`assign`、`retain`、`copy`、`strong`、`weak`、`unsafe_unretained`\n\n### 一、内存管理方式：\n\n#### 1.Tagged Pointer：小对象的内存管理方式\n\n64位操作系统后，iOS引入了Tagged Pointer，用来优化NSString、NSNumber、NSDate的内存管理。\n\n引入Tagged Pointer之前（32位操作系统时），小对象内存管理方式和普通对象一样，首先需要在堆区开辟一块内存，并把内存的地址赋值给栈区的指针变量，然后维护对象的引用计数和内存的释放。\n\n比如我们创建一个int类型的NSNumber对象：\n\n```objective-c\nNSNumber *number = @11;\n```\n\n系统需要开辟16个字节的内存来存储11这个值，同时需要开辟8个字节大小的内存来存储这个对象的地址，本来需要占用4个字节的内存的Int类型数据，占用了24个字节，同时还没考虑维护引用计数和内存释放等的内存开销。\n\n![使用Tagged pointer前的内存管理](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/nsnumber.png)\n\n在引入Tagged Pointer之后，**小对象就不需要像之前那样 在堆区开辟内存，维护引用计数，释放内存了。而是直接把值存到了number指针里，number里面存的不再是一个地址了，而是Tag + Data，Tag是用来标记小对象的类型（NSString、NSNumber、NSDate），Data就是小对象的值。指针什么时候创建，小对象就什么时候创建，指针什么时候销毁，小对象就什么时候销毁。只有在指针存不下小对象的值时，才会变为引用计数的方式管理内存。**这样，仅需要8个字节就可以存储小对象的类型和值，很大程度上节省了内存占用，同时也减少了维护引用计数、内存释放等带来的开销。\n\n![使用Tagged Pointer后的内存管理](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E4%BD%BF%E7%94%A8Tagged.png)\n\n用代码验证一下：\n\n```objective-c\n//  苹果对Tagged Pointer做了数据混淆，所以在分析Tagged Pointer之前，我们需要先关闭Tagged Pointer的数据混淆。通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为YES。否则无法分析打印出的结果\n- (void)testTaggedPointer {\n    \n    NSNumber *number1 = @1;\n    NSNumber *number2 = @2;\n    NSNumber *number3 = @10;\n    NSNumber *number4 = @(0xFFFFFFFFFFFFFFFF);\n\n    NSLog(@\"number1:%p\", number1);\n    NSLog(@\"number2:%p\", number2);\n    NSLog(@\"number3:%p\", number3);\n    NSLog(@\"number4:%p\", number4);\n}\n\nnumber1:0xb000000000000012\nnumber2:0xb000000000000022\nnumber3:0xb0000000000000a2\nnumber4:0x600001be2060\n```\n\nnumber1～number3指针是Tagged Pointer，number4由于值大到存储不下了，改为普通对象内存管理方式。对应的地址分布规律见下图（mac os系统的规律与iOS系统的规律不同 [详细](https://cloud.tencent.com/developer/article/1620346)），可发现规律**如果一个指针的最高位为1，那么他就是Tagged Pointer，否则就不是。**\n\n![ios-nsnumber](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623191932.png)\n\n如果是NSString的话，Tagged Pointer内存地址分布规律就是下面这样的：\n\n![ios-nsstring](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623195417.png)\n\n\n\n学习完上面内容，我们举个例子验证下，找不同：\n\n```objectivec\n// 开辟多个线程去修改name属性\n// 代码1\nfor (int i = 0; i < 1000; i++) {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        self.name = [[NSString alloc] initWithFormat:@\"abcdefghijk\"];\n    });\n}\n\n// 代码2\nfor (int i = 0; i < 1000; i++) {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        self.name = [[NSString alloc] initWithFormat:@\"abc\"];\n    });\n}\n```\n\n运行代码我们会发现 代码1 会crash，因为`abcdefghijk`已经大到指针存储不下，改为了普通对象内存管理方式，所以 代码1 就是正常的调用`setter`方法修改`name`属性,`setter`的实现是这样的：\n\n```objectivec\n- (void)setName:(NSString *)name {\n    if (_name != name) { // 新旧对象不一样时\n        [_name release]; // 释放旧对象\n        _name = [name copy]; // 复制新对象\n    }\n}\n```\n\n在不加锁的情况下，极容易发生多个线程同时调用`[_name release]`的情况，若`_name`已经销毁，再次调用`release`肯定会发生crash。\n\n代码2 正常运行，是因为`abc`并没有大到指针存储不下，`NSString`为`NSTaggedPointerString`类型，在`objc_release`函数中会判断指针是不是`TaggedPointer`类型，是的话就不对对象进行`release`操作，也就避免了因过度释放对象而导致的`Crash`，因为根本就没执行释放操作。\n\n\n\n#### 2.引用计数：普通对象的内存管理方式\n\n**2.1 引用计数是什么？**\n\n**iOS是通过引用计数来管理内存的。所谓的引用计数就是指每当我们创建一个对象，系统就会为该对象分配一个整数，用来表征当前有多少人想使用该对象。**那就引出两个问题：\n\n问题1：创建对象时，系统为对象分配的整数存在哪里？也就是引用计数存在哪里？因为我们知道OC对象内部只有一个`isa`，并没有引用计数的成员变量\n\n问题2：iOS具体是怎么通过引用计数来管理内存的？\n\n\n\n**2.2 引用计数存储在哪里？**\n\n64位操作系统以前，对象的`isa`指针还没进行内存优化，对象的引用计数存储在引用计数表里。\n\n当系统为64位操作系统后，对象的`isa`指针经过了内存优化，它不再直接是一个指针了，而是一个共用体，64位中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1），还有1位用来标记引用计数表里是否有当前对象的引用计数。具体地说：**对象的引用计数首先会存储在`isa`共用体里——`extra_rc`变量，但是`isa`共用体的引用计数存储范围是0～255，一旦引用计数超过了255，这个变量就会溢出，此时系统会把这个变量置为128，同时把引用计数表里是否有当前对象的引用计数的标记——`has_sidetable_rc`变量置为1，并把另外128个引用计数挪到引用计数表里进行存储。下一次对象的引用计数再次增加时，依旧增加`isa`共用体里的引用计数（因为它已被置为128，不再是溢出状态），直到再次溢出，系统再娜128个引用计数到引用计数表里，如此循环往复。**\n\n因此可以看出，系统是不会直接操作引用计数表里的引用计数的，而总是在操作`isa`共用体里的引用计数，直到溢出时才从`isa`共用体里挪128个引用计数到引用计数表里进行存储。\n\n- `isa`共用体\n\n  ```cpp\n  struct objc_object {\n      isa_t isa; // 一个isa_t类型的共用体\n  \n      // 自定义的成员变量，存储着该对象这些成员变量具体的值\n      NSSring *_name; // “张三”\n      NSSring *_sex; // “男”\n      int _age; // 33\n  }\n  \n  union isa_t {\n      Class cls;\n      \n      unsigned long bits; // 8个字节，64位\n      struct { // 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着谁的数据\n  # if __arm64__\n  #   define ISA_MASK        0x0000000ffffffff8ULL\n          unsigned long nonpointer        : 1; // isa是否经过内存优化\n          unsigned long has_assoc         : 1;\n          unsigned long has_cxx_dtor      : 1;\n          unsigned long shiftcls          : 33; // 对象所属类的地址信息\n          unsigned long magic             : 6;\n          unsigned long weakly_referenced : 1;\n          unsigned long deallocating      : 1;\n          unsigned long has_sidetable_rc  : 1; // 引用计数表里是否有当前对象的引用计数\n          unsigned long extra_rc          : 19; // 对象的引用计数 - 1\n  # endif\n      };\n  };\n  ```\n\n- `SideTables`-->`SideTable`-->引用计数表、若引用表\n\n![SideTables](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220627183629.png)\n\n```objective-c\nstatic StripedMap<SideTable>& SideTables() {\n    return *reinterpret_cast<StripedMap<SideTable>*>(SideTableBuf);\n}\n\nstruct SideTable {\n    spinlock_t slock; // 自旋锁\n    RefcountMap refcnts; // 引用计数表\n    weak_table_t weak_table;\n}\n\ntypedef objc::DenseMap<objc_object */*对象的内存地址*/, unsigned long/*对象的引用计数*/> RefcountMap;\n\nstruct weak_table_t {\n    weak_entry_t *weak_entries; // 这个其实才是弱引用表，表中元素为weak_entry_t结构体\n    size_t    num_entries;\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\nstruct weak_entry_t {\n    objc_object *obj; // 对象的内存地址\n    weak_referrer_t *referrers; // 指向该对象的弱指针数组——即所有指向该对象的弱指针（其实存储的是弱指针对应那块内存的地址，但是我们直接理解为弱指针是没有问题的）\n}\n// 例如：\nid obj = [[NSObject alloc] init];\n__weak id weakObj1 = obj;\n__weak id weakObj2 = obj;\n__weak id weakObj3 = obj;\n\n// NSObject对象的weak_entry为：\nstruct weak_entry_t {\n    objc_object *obj; // 对象的内存地址\n    weak_referrer_t *referrers; // 指向该对象的弱指针数组\n} NSObjectWeakEntry = {\n    obj;\n    [weakObj1, weakObj2, weakObj3]\n}\n```\n\n`SideTables`是一个全局的散列表，它里面存储着64个`SideTable`结构体，而每个`SideTable`结构体内部又存储着1个引用计数表和1个弱引用计数表，所以项目中一般会有64个引用计数表和64个弱引用计数表。引用计数表也是一个散列表，表中的元素是一个字典：`key`为对象的内存地址，`value`为对象的引用计数，引用计数表里存储着很多对象的引用计数。若引用计数表也是一个散列表，表中的元素是一个结构体：一个成员变量是对象的内存地址，另一个成员变量是指向该对象的弱指针数组。\n\n所以如果我们想要找到对象的引用计数和弱指针数组，就要首先把对象的内存地址通过某种散列算法得到一个`index`，就可以在`SideTables`里找到对象的引用计数和弱指针数组所在的`SideTable`结构体，也就是找到了引用计数和弱指针数组所在的引用计数表和弱引用计数表，然后再次把对象的内存地址通过某种散列算法得到一个`index`，就可以在引用计数表里找到对象的引用计数，弱引用计数表里找到对象的弱指针数组了。\n\n\n\n**2.3 iOS具体是怎么通过引用计数来进行对象的内存管理的**\n\n主要是通过`alloc`、`new`、`alloc`、`copy`、`mutableCopy`，`retain`，`release`、`autorelease`，`dealoc`这几个方法操作引用计数，来管理对象内存管理的，即：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628181747.png)\n\n```cpp\n// NSObject.mm\n- (void)release {\n    self->rootRelease();\n}\n\nbool objc_object::rootRelease()\n{\n    return rootRelease(true, false);\n}\n\nbool objc_object::rootRelease(bool performDealloc, bool handleUnderflow)\n{\n    if (isTaggedPointer()) return false;\n\n    isa_t newisa = LoadExclusive(&isa.bits);\n\n    if (!newisa.nonpointer) {\n        \n        // 去引用计数表里让它的引用计数-1\n        return sidetable_release(performDealloc);\n    }\n    \n\n    // 用来标识extra_rc是否下溢——即是否减为-1（因为extra_rc存储的是（引用计数 - 1），所以减为0的时候说明引用计数为1，还有人引用它，没事儿）\n    uintptr_t carry;\n    // 首先去isa共用体里，让对象的引用计数-1\n    newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);\n    if (carry) { // 所以如果extra_rc下溢了：\n    \n        goto underflow; // 跳转到underflow处执行\n    }\n\n    // 表明没有下溢，结束\n    return false;\n\n underflow: // extra_rc下溢了：\n\n    newisa = LoadExclusive(&isa.bits);\n\n    if (newisa.has_sidetable_rc) { // 如果引用计数表里有当前对象的引用计数，说明还有人使用该对象\n\n        // 尝试从引用计数表搬回来128个引用计数\n        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);\n        if (borrowed) { // 如果搬成功了\n            \n            // 存进去\n            newisa.extra_rc = borrowed - 1;\n            // 更新一下对象的isa共用体\n            isa = newisa;\n        } else { // 搬失败了，说明引用计数表里的引用计数也为0了（可能是被上一次搬完了）\n            \n            // 走dealloc方法销毁该对象\n            ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n        }\n    } else { // 引用计数表里没有当前对象的引用计数，说明没人使用该对象了\n        \n        // 走dealloc方法销毁该对象\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n    }\n    \n    return true;\n}\n\n// 尝试从引用计数表搬回来128个引用计数\nsize_t objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)\n{\n    SideTable& table = SideTables()[this];\n    RefcountMap::iterator it = table.refcnts.find(this);\n    \n    if (it == table.refcnts.end()  ||  it->second == 0) { // 引用计数表里的引用计数被上一次搬完了\n\n        return 0;\n    }\n    \n    // 引用计数表里的引用计数-128，搬出去\n    size_t oldRefcnt = it->second;\n    size_t newRefcnt = oldRefcnt - (delta_rc << SIDE_TABLE_RC_SHIFT);\n    it->second = newRefcnt;\n    \n    return delta_rc;\n}\n```\n\n>关于`autorelease`和`autoreleasepool`就暂时理解这么一点，更底层的东西有空再说：\n>\n>- `release`会立即使对象的引用计数-1，而`autorelease`则不会，它仅仅是把该对象注册到了`autoreleasepool`中，当`autoreleasepool`销毁时系统会自动让池中所有的对象都调用一下`release`，这时对象的引用计数才-1。\n>- 而`autoreleasepool`又是在RunLoop休眠或退出时销毁的，当然如果是我们自己创建的`@autoreleasepool{}`，出了大括号——即出了`@autoreleasepool{}`的生命周期，它就会销毁。\n>- 只要不是用`alloc`、`new`、`copy`、`mutableCopy`方法创建的对象，而是用类方法创建的对象，方法内部都调用了`autorelease`，都是`autorelease`对象。\n\n- 如果对象的引用计数减为0了，就代表没人想使用该对象了，系统就会调用`dealloc`方法销毁它，并释放它对应的内存，对象一经销毁就不能再访问了，因为他的内存随时会被移作它用。\n\n  ![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628182915.png)\n\n```cpp\n// NSObject.mm\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid _objc_rootDealloc(id obj)\n{\n    obj->rootDealloc();\n}\n\nvoid objc_object::rootDealloc()\n{\n    if (\n        !isa.has_cxx_dtor  && // 如果当前对象没使用过C++析构函数\n        !isa.has_assoc  && // 如果当前对象没有关联对象\n        !isa.weakly_referenced  && // 如果弱引用表里没有当前对象的弱指针数组\n        !isa.has_sidetable_rc // 如果引用计数表里没有当前对象的引用计数\n        )\n    {\n        // 就直接销毁对象，并释放它对应的内存，即我们之前说的对象销毁时会更快\n        free(this);\n    } else {\n        \n        // 否则就慢慢销毁\n        object_dispose(this);\n    }\n}\n\nid object_dispose(id obj)\n{\n    objc_destructInstance(obj);\n    // 销毁对象，并释放它对应的内存，\n    free(obj);\n\n    return nil;\n}\n\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        \n        // 如果当前对象使用过C++析构函数\n        bool cxx = obj->hasCxxDtor();\n        // 如果当前对象有关联对象\n        bool assoc = obj->hasAssociatedObjects();\n\n        // 要按顺序销毁哦\n        if (cxx) object_cxxDestruct(obj); // 销毁C++析构函数相关的东西\n        if (assoc) _object_remove_assocations(obj); // 移除关联对象\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n\nvoid objc_object::clearDeallocating()\n{\n    clearDeallocating_slow();\n}\n\nvoid objc_object::clearDeallocating_slow()\n{\n    // 获取SideTable\n    SideTable& table = SideTables()[this];\n\n    if (isa.weakly_referenced) { // 如果弱引用表里有当前对象的弱指针数组\n        \n        // 把弱引用表里所有指向该对象的弱指针都置为nil，并移除，从此弱引用表里就没有该对象的弱指针数组（关于弱指针（弱引用）更多详细的内容，见下面__weak指针的实现原理）\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    \n    if (isa.has_sidetable_rc) { // 如果引用计数表里有当前对象的引用计数\n        \n        // 从引用计数表里把该对象的引用计数给抹掉，从此引用计数表里就没有该对象的引用计数了\n        table.refcnts.erase(this);\n    }\n}\n```\n\n### 二、MRC介绍，需要开发工程师做哪些工作\n\nMRC（*Manual Reference Count*）：指手动管理引用计数，即需要程序员自己手动调用上面那几个`alloc`、`new`、`alloc`、`copy`、`mutableCopy`，`retain`，`release`、`autorelease`，`dealoc`方法来操作引用计数，从而完成对象的内存管理。具体地说，MRC下我们需要做到以下三点：\n\n- 调用了`alloc`、`new`、`alloc`、`copy`、`mutableCopy`创建对象的地方，在不想使用对象时，要调用\n\n`release`、`autorelease`；调用了`retain`使对象引用计数+1的地方，在不想使用对象时，要调用\n\n`release`、`autorelease`来使对象的引用计数-1。\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    // 调用了alloc、new、copy、mutableCopy创建对象\n    NSArray *arr = [[NSArray alloc] init];\n    NSArray *arr1 = [NSArray new];\n    NSArray *arr2 = [arr copy];\n    NSMutableArray *arr3 = [arr1 mutableCopy];\n    \n    // 调用release、autorelease来释放对象\n    [arr release];\n    [arr1 release];\n    [arr2 autorelease];\n    [arr3 autorelease];\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    NSArray *arr = [NSArray array];\n    // 调用了retain使对象引用计数+1\n    [arr retain];\n\n    // 要调用release、autorelease来使对象的引用计数-1\n    [arr release];\n  \n    //或者调用下面\n    //[arr autorelease];\n}\n```\n\n- 我们还需要处理好`setter`方法内部的内存管理，并在`dealloc`方法里释放当前类及其父类**所有对象类型**的成员变量。\n\n```objectivec\n@implementation INEPerson {\n    int _age;\n    NSString *_name;\n    INEDog *_dog;\n}\n\n- (void)setAge:(int)age {\n    \n    _age = age; // 直接赋值\n}\n\n- (void)setName:(NSString *)name {\n\n    if (_name != name) { // 新旧对象不一样时\n        \n        [_name release]; // 释放旧对象\n        _name = [name copy]; // 复制新对象\n    }\n}\n\n- (void)setDog:(INEDog *)dog {\n    \n    if (_dog != dog) { // 新旧对象不一样时\n        \n        [_dog release]; // 释放旧对象\n        _dog = [dog retain]; // 持有新对象\n    }\n}\n\n- (void)dealloc {\n    \n    // 释放当前类所有对象类型的成员变量\n    [self setName:nil];\n    [self setDog:nil];\n\n    // 释放父类所有对象类型的成员变量，放在最后\n    [super dealloc];\n}\n\n@end\n```\n\n- 我们还需要处理好循环引入问题。\n\n```objectivec\n// INEMan.h\n#import <Foundation/Foundation.h>\n@class INEWoman;\n\n@interface INEMan : NSObject\n\n- (void)setWoman:(INEWoman *)woman;\n\n@end\n\n\n// INEMan.m\n#import \"INEMan.h\"\n#import \"INEWoman.h\"\n\n@implementation INEMan {\n    \n    INEWoman *_woman;\n}\n\n- (void)setWoman:(INEWoman *)woman {\n\n    if (_woman != woman) { // 新旧对象不一样时\n\n        [_woman release]; // 释放旧对象\n        _woman = [woman retain]; // 持有新对象\n    }\n}\n\n- (void)dealloc {\n  \n    NSLog(@\"%s\", __func__);\n    \n    [self setWoman:nil];\n    \n    [super dealloc];\n}\n\n@end\n```\n\n```objectivec\n// INEWoman.h\n#import <Foundation/Foundation.h>\n@class INEMan;\n\n@interface INEWoman : NSObject\n\n- (void)setMan:(INEMan *)man;\n\n@end\n\n\n// INEWoman.m\n#import \"INEWoman.h\"\n#import \"INEMan.h\"\n\n@implementation INEWoman {\n    \n    INEMan *_man;\n}\n\n- (void)setMan:(INEMan *)man {\n\n    _man = man; // 为了避免循环引用，这里不能retain\n}\n\n- (void)dealloc {\n  \n    NSLog(@\"%s\", __func__);\n    \n    [self setMan:nil];\n    \n    [super dealloc];\n}\n\n@end\n```\n\n```csharp\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    INEMan *man = [[INEMan alloc] init];\n    INEWoman *woman = [[INEWoman alloc] init];\n    \n    [man setWoman:woman];\n    [woman setMan:man];\n    \n    [man release];\n    [woman release];\n}\n\n// 控制台打印：两个对象都可以正常销毁\n-[INEWoman dealloc]\n-[INEMan dealloc]\n```\n\n#### 三、ARC介绍，编译器帮我们做了什么\n\nARC（*Autal Reference Count*）：自动管理引用计数，让**编译器**进行内存管理，**在LVVM编译器中设置ARC为有效状态，就无需再次键入`retain`、`realeas`、`autorelease`代码，编译器会在合适的地方自动帮我们插入`retain`、`release`、`autorelease`等方法的调用，从而完成对象的内存管理。但实际上除了编译器之外，ARC还用到了Runtime，比如`weak`指针的清空。**这样就会在降低程序崩溃、内存泄漏风险的同时，很大程度程度减少了开发的工作量，使应用程序具有可预测性，且能流畅运行，速度也将大幅提升。具体来说，与MRC相对应，ARC帮我们做了如下三点：\n\n- 利用`__strong`指针修饰符，编译器会在合适的地方帮们插入`retain`、`release`、`autorelease`等方法的调用；\n\n- 利用属性修饰符，编译器为我们生成特定的`setter`方法并处理好内部的内存管理，还会自动在`dealloc`方法里释放当前类及其父类的成员变量；\n\n- 利用`__weak`指针修饰符和Runtime，来处理循环引入问题。\n\n#### 1.指针修饰符\n\n- `__strong`指针修饰符\n\n  凡是用`__strong`修饰的指针，在超出其作用域时，编译器会为我们插入一次`release`或`autorelease`的调用。\n\n  ```objectivec\n  // ARC下\n  {\n      __strong id obj = [[NSObject alloc] init];\n      __strong id arr = [NSArray array];\n  }\n  \n  等价于：\n  \n  // MRC下\n  {\n      id obj = [[NSObject alloc] init];\n      id arr = [[NSArray alloc] init];\n      \n      [obj release];\n      [arr autorelease];\n  }\n  ```\n\n而在指针赋值时，编译器会自动为我们插入一次`retain`的调用。\n\n```objectivec\n// ARC下\n{\n    __strong id obj = [[NSObject alloc] init];\n    __strong id obj1 = obj;\n}\n\n等价于：\n\n// MRC下\n{\n    id obj = [[NSObject alloc] init];\n    id obj1 = [obj retain];\n    \n    [obj release];\n    [obj1 release];\n}\n```\n\n所以正是因为使用`__strong`指针修饰符，编译器才会在合适的地方帮我们插入`retain`、`release`、`autorelease`等方法的调用，而ARC下所有指针默认都是用`__strong`修饰的。\n\n- `__weak`指针修饰符\n\n看起来有了`strong`,编译器就可以很好的管理内存了，但是很重要的一点是`__strong`无法解决引用计数式内存管理必然会导致的“循环引入”问题。\n\n```objectivec\n// INEMan.h\n#import <Foundation/Foundation.h>\n@class INEWoman;\n\n@interface INEMan : NSObject {\n    \n    __strong INEWoman *_woman; // 强引用\n}\n\n- (void)setWoman:(INEWoman *)woman;\n\n@end\n\n\n// INEMan.m\n#import \"INEMan.h\"\n\n@implementation INEMan \n\n- (void)setWoman:(INEWoman *)woman {\n\n    _woman = woman;\n}\n\n- (void)dealloc {\n  \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n```objectivec\n// INEWoman.h\n#import <Foundation/Foundation.h>\n@class INEMan;\n\n@interface INEWoman : NSObject {\n    \n    __strong INEMan *_man; // 强引用\n}\n\n- (void)setMan:(INEMan *)man;\n\n@end\n\n\n// INEWoman.m\n#import \"INEWoman.h\"\n\n@implementation INEWoman\n\n- (void)setMan:(INEMan *)man {\n\n    _man = man;\n}\n\n- (void)dealloc {\n  \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n```csharp\n// ViewController.m\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    INEMan *man = [[INEMan alloc] init];\n    INEWoman *woman = [[INEWoman alloc] init];\n    \n    [man setWoman:woman];\n    [woman setMan:man];\n}\n\n// 控制台打印：无\n```\n\n`viewDidLoad`执行完，`Man`对象和`Woman`对象的`dealloc`方法都没走，也就是说它们俩都没销毁，这就是因为它们俩形成了循环引用，导致了内存泄漏。\n\n但是只要我们把循环引用中的一个强指针的换成弱指针，就可以解决问题。\n\n```objectivec\n@interface INEMan : NSObject {\n    \n     __weak INEWoman *_woman; // 弱引用\n}\n\n或者：\n\n@interface INEWoman : NSObject {\n    \n    __weak INEMan *_man; // 强引用\n}\n```\n\n为什么能解决呢？这就要来看看**`__weak`指针的实现原理：**\n\n- **`__weak`指针是专门用来解决循环引用问题的，它不是通过引用计数来管理对象的，而是通过弱引用表。**具体地说：\n\n  **1.当我们把一个强指针赋值给一个弱指针时，编译器不会怒自动帮我们插入`retain`使对象的引用计数+1，而是把这个弱指针和对象的内存地址绑在一起，通过两次散列算法找到弱引用计数表里的弱指针数组，然后把这个弱指针存到弱指针数组里。这样我们通过这些弱指针既可以正常使用该对象，又无需顾虑是不是要在什么时候把对象的引用计数-1，以免对象的引用计数>0而无法销毁，因为他没有参数引用计数那一套。**\n\n  **2.当对象销毁时会走dealloc方法，又会通过两次散列算法找到弱引用计数表里的数组，把指向该对象的弱指针都置为`nil`并移除。**\n\n#### 2.属性修饰符\n\n属性修饰符一共有三对儿：**原子性、读写权限和内存管理语意**，属性修饰符主要影响就是编译器为成员变量生成的`setter`、`getter`方法上。（这里除了讲解和内存相关的知识外，其他的也回顾一下）\n\n> 原子性：`atomic`（默认）、`nonatomic`\n\n- `atomic`：默认为`atomic`，使用`atomic`修饰的属性，编译器为该属性生成的`setter`、`getter`方法内部是加了锁的。\n\n  ```objectivec\n  @property (atomic, strong) NSMutableArray *array;\n  \n  - (void)setArray:(NSMutableArray *)array {\n      \n      // 加锁\n      _array = array;\n      // 解锁\n  }\n  \n  - (NSMutableArray *)array {\n      // 加锁\n      return _array;\n      // 解锁\n  }\n  ```\n\n但这仅仅是保证我们调用`setter`、`getter`方法访问属性这一步是线程安全的，它没发保证我们使用属性的线程是安全的，比如我们调用`[self.array addObject:xxx]`,`self.array`访问属性这一步是线程安全的，但`addObject:`使用属性这一步是线程不安全的。\n\n```objective-c\n// 线程1\n[self.array addObject:@\"11\"];\n// 线程2\n[self.array addObject:@\"12\"];\n\n等价于\n\n// 线程1\n[[self array] addObject:@\"11\"];\n// 线程2\n[[self array] addObject:@\"12\"];\n```\n\n所以为了保证使用属性的线程安全，我们还得在需要的地方自己加锁，这样一来使用使用`atomic`修饰属性就多此一举了，而且`stter`、`getter`方法的调用通常都是很频繁的，内部加锁的话会增加内存的开销，耗费性能。\n\n```php\n// 线程1\n// 加锁\n[self.array addObject:@\"11\"];\n// 解锁\n\n// 线程2\n// 加锁\n[self.array addObject:@\"12\"];\n// 解锁\n```\n\n- `nonatomic`：因此我们在实际开发中总是使用`nonatomic`。\n\n> 读写权限：`readwrite`(默认)、`readonly`\n\n- `readwrite`：默认为`readwrite`，代表该属性可读可写，编译器会为该属性生成`setter`\n\n`getter`方法的声明与实现。\n\n- `readonly`：代表该属性只能读取不能写入，编译器会为该属性生成`setter`、`getter`方法的声明与`getter`方法的实现。\n\n> 内存管理语意：\n>\n> - MRC下有：`assign`、`retain`、`copy`。\n> - ARC下新增了：`strong`、`weak`、`unsafe_unretained`。\n\n- `assign`：`assign`一般来修饰基本数据类型。使用`assign`修饰属性，编译器为属性生成的`setter`方法内部只是简单的赋值操作。\n\n```cpp\n- (void)setAge:(int)age {\n    \n    // 简单的赋值操作\n    _age = age;\n}\n```\n\n- `retain`：`retain`一般用来修饰对象类型。使用`retain`修饰的属性，编译器为该属性生成的`setter`方法内部会调用一下`retain`方法，是对象的引用计数+1。\n\n  ```objective-c\n  - (void)setDog:(Dog *)dog {\n      \n      if (_dog != dog) { // 新旧对象不一样时\n          \n          [_dog release]; // 释放旧对象\n          _dog = [dog retain]; // 持有新对象\n      }\n  }\n  ```\n\n- `copy`：`copy`一般用来修饰不可变属性和block。使用`copy`修饰的属性，编译器为该属性生成的`setter`方法内部会调用一下`copy`方法，生成一个新的对象，新对象的引用计数为1，而旧对象的引用计数不变。\n\n  ```objectivec\n  - (void)setName:(NSString *)name {\n  \n      if (_name != name) { // 新旧对象不一样时\n          \n          [_name release]; // 释放旧对象\n          _name = [name copy]; // 复制新对象\n      }\n  }\n  ```\n\n- `strong`：默认为`strong`，大多数情况下和`retain`的效果是一样的，修饰block和`copy`的效果是一样的，`strong`一般用来修饰对象类型。\n- `weak`：`weak`一般用来修饰代理对象和`NSTimer`，以免造成循环引入；还有用来修饰xib或sb拖出来的控件，因为这些界面已经被添加到界面上了，被subviews这个属性持有了，不必再用变量持有。\n\n- `unsafe_unretained`：和`assign`效果是一样的，如果用他们来修饰对象类型，和`weak`功能类似，但`weak`修饰的属性会在对象销毁时会被置为`nil`，比较安全，而`unsafe_unretained`和`assign`修饰的属性则不会，所以容易出现野指针。\n\n","slug":"内存管理一","published":1,"updated":"2022-07-17T03:05:08.623Z","_id":"cl4y1tfwm00002cfy9dri58wq","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>一、iOS内存管理方式：</p>\n<p>​    1.Tagged Pointer：小对象的内存管理方式</p>\n<p>​    2.引用计数：普通对象的内存管理方式</p>\n<p>二、MRC介绍，需要开发工程师做哪些工作</p>\n<p>三、ARC介绍，编译器帮我们做了什么</p>\n<span id=\"more\"></span>\n\n<p>​    1.指针修饰符</p>\n<p>​        1. __strong</p>\n<p>​        2. __weak</p>\n<p>​        3. __unsafe_unretained</p>\n<p>​        4. __autoreease</p>\n<p>​    2.属性修饰符</p>\n<p>​        2.1 原子性：<code>atomic</code>、<code>nonatomic</code></p>\n<p>​        2.2 读写权限：<code>readwrite</code>、<code>readonly</code></p>\n<p>​        2.3 内存管理语义：<code>assign</code>、<code>retain</code>、<code>copy</code>、<code>strong</code>、<code>weak</code>、<code>unsafe_unretained</code></p>\n</blockquote>\n<h3 id=\"一、内存管理方式：\"><a href=\"#一、内存管理方式：\" class=\"headerlink\" title=\"一、内存管理方式：\"></a>一、内存管理方式：</h3><h4 id=\"1-Tagged-Pointer：小对象的内存管理方式\"><a href=\"#1-Tagged-Pointer：小对象的内存管理方式\" class=\"headerlink\" title=\"1.Tagged Pointer：小对象的内存管理方式\"></a>1.Tagged Pointer：小对象的内存管理方式</h4><p>64位操作系统后，iOS引入了Tagged Pointer，用来优化NSString、NSNumber、NSDate的内存管理。</p>\n<p>引入Tagged Pointer之前（32位操作系统时），小对象内存管理方式和普通对象一样，首先需要在堆区开辟一块内存，并把内存的地址赋值给栈区的指针变量，然后维护对象的引用计数和内存的释放。</p>\n<p>比如我们创建一个int类型的NSNumber对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNumber *number = @11;</span><br></pre></td></tr></table></figure>\n\n<p>系统需要开辟16个字节的内存来存储11这个值，同时需要开辟8个字节大小的内存来存储这个对象的地址，本来需要占用4个字节的内存的Int类型数据，占用了24个字节，同时还没考虑维护引用计数和内存释放等的内存开销。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/nsnumber.png\" alt=\"使用Tagged pointer前的内存管理\"></p>\n<p>在引入Tagged Pointer之后，<strong>小对象就不需要像之前那样 在堆区开辟内存，维护引用计数，释放内存了。而是直接把值存到了number指针里，number里面存的不再是一个地址了，而是Tag + Data，Tag是用来标记小对象的类型（NSString、NSNumber、NSDate），Data就是小对象的值。指针什么时候创建，小对象就什么时候创建，指针什么时候销毁，小对象就什么时候销毁。只有在指针存不下小对象的值时，才会变为引用计数的方式管理内存。</strong>这样，仅需要8个字节就可以存储小对象的类型和值，很大程度上节省了内存占用，同时也减少了维护引用计数、内存释放等带来的开销。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E4%BD%BF%E7%94%A8Tagged.png\" alt=\"使用Tagged Pointer后的内存管理\"></p>\n<p>用代码验证一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  苹果对Tagged Pointer做了数据混淆，所以在分析Tagged Pointer之前，我们需要先关闭Tagged Pointer的数据混淆。通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为YES。否则无法分析打印出的结果</span><br><span class=\"line\">- (void)testTaggedPointer &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSNumber *number1 = @1;</span><br><span class=\"line\">    NSNumber *number2 = @2;</span><br><span class=\"line\">    NSNumber *number3 = @10;</span><br><span class=\"line\">    NSNumber *number4 = @(0xFFFFFFFFFFFFFFFF);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;number1:%p&quot;, number1);</span><br><span class=\"line\">    NSLog(@&quot;number2:%p&quot;, number2);</span><br><span class=\"line\">    NSLog(@&quot;number3:%p&quot;, number3);</span><br><span class=\"line\">    NSLog(@&quot;number4:%p&quot;, number4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">number1:0xb000000000000012</span><br><span class=\"line\">number2:0xb000000000000022</span><br><span class=\"line\">number3:0xb0000000000000a2</span><br><span class=\"line\">number4:0x600001be2060</span><br></pre></td></tr></table></figure>\n\n<p>number1～number3指针是Tagged Pointer，number4由于值大到存储不下了，改为普通对象内存管理方式。对应的地址分布规律见下图（mac os系统的规律与iOS系统的规律不同 <a href=\"https://cloud.tencent.com/developer/article/1620346\">详细</a>），可发现规律<strong>如果一个指针的最高位为1，那么他就是Tagged Pointer，否则就不是。</strong></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623191932.png\" alt=\"ios-nsnumber\"></p>\n<p>如果是NSString的话，Tagged Pointer内存地址分布规律就是下面这样的：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623195417.png\" alt=\"ios-nsstring\"></p>\n<p>学习完上面内容，我们举个例子验证下，找不同：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开辟多个线程去修改name属性</span></span><br><span class=\"line\"><span class=\"comment\">// 代码1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@&quot;abcdefghijk&quot;</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代码2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@&quot;abc&quot;</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行代码我们会发现 代码1 会crash，因为<code>abcdefghijk</code>已经大到指针存储不下，改为了普通对象内存管理方式，所以 代码1 就是正常的调用<code>setter</code>方法修改<code>name</code>属性,<code>setter</code>的实现是这样的：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不加锁的情况下，极容易发生多个线程同时调用<code>[_name release]</code>的情况，若<code>_name</code>已经销毁，再次调用<code>release</code>肯定会发生crash。</p>\n<p>代码2 正常运行，是因为<code>abc</code>并没有大到指针存储不下，<code>NSString</code>为<code>NSTaggedPointerString</code>类型，在<code>objc_release</code>函数中会判断指针是不是<code>TaggedPointer</code>类型，是的话就不对对象进行<code>release</code>操作，也就避免了因过度释放对象而导致的<code>Crash</code>，因为根本就没执行释放操作。</p>\n<h4 id=\"2-引用计数：普通对象的内存管理方式\"><a href=\"#2-引用计数：普通对象的内存管理方式\" class=\"headerlink\" title=\"2.引用计数：普通对象的内存管理方式\"></a>2.引用计数：普通对象的内存管理方式</h4><p><strong>2.1 引用计数是什么？</strong></p>\n<p><strong>iOS是通过引用计数来管理内存的。所谓的引用计数就是指每当我们创建一个对象，系统就会为该对象分配一个整数，用来表征当前有多少人想使用该对象。</strong>那就引出两个问题：</p>\n<p>问题1：创建对象时，系统为对象分配的整数存在哪里？也就是引用计数存在哪里？因为我们知道OC对象内部只有一个<code>isa</code>，并没有引用计数的成员变量</p>\n<p>问题2：iOS具体是怎么通过引用计数来管理内存的？</p>\n<p><strong>2.2 引用计数存储在哪里？</strong></p>\n<p>64位操作系统以前，对象的<code>isa</code>指针还没进行内存优化，对象的引用计数存储在引用计数表里。</p>\n<p>当系统为64位操作系统后，对象的<code>isa</code>指针经过了内存优化，它不再直接是一个指针了，而是一个共用体，64位中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1），还有1位用来标记引用计数表里是否有当前对象的引用计数。具体地说：<strong>对象的引用计数首先会存储在<code>isa</code>共用体里——<code>extra_rc</code>变量，但是<code>isa</code>共用体的引用计数存储范围是0～255，一旦引用计数超过了255，这个变量就会溢出，此时系统会把这个变量置为128，同时把引用计数表里是否有当前对象的引用计数的标记——<code>has_sidetable_rc</code>变量置为1，并把另外128个引用计数挪到引用计数表里进行存储。下一次对象的引用计数再次增加时，依旧增加<code>isa</code>共用体里的引用计数（因为它已被置为128，不再是溢出状态），直到再次溢出，系统再娜128个引用计数到引用计数表里，如此循环往复。</strong></p>\n<p>因此可以看出，系统是不会直接操作引用计数表里的引用计数的，而总是在操作<code>isa</code>共用体里的引用计数，直到溢出时才从<code>isa</code>共用体里挪128个引用计数到引用计数表里进行存储。</p>\n<ul>\n<li><p><code>isa</code>共用体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">objc_object</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">isa_t</span> isa; <span class=\"comment\">// 一个isa_t类型的共用体</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义的成员变量，存储着该对象这些成员变量具体的值</span></span><br><span class=\"line\">    NSSring *_name; <span class=\"comment\">// “张三”</span></span><br><span class=\"line\">    NSSring *_sex; <span class=\"comment\">// “男”</span></span><br><span class=\"line\">    <span class=\"type\">int</span> _age; <span class=\"comment\">// 33</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">isa_t</span> &#123;</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> bits; <span class=\"comment\">// 8个字节，64位</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">// 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着谁的数据</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">if</span> __arm64__</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"keyword\">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> nonpointer        : <span class=\"number\">1</span>; <span class=\"comment\">// isa是否经过内存优化</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_assoc         : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_cxx_dtor      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> shiftcls          : <span class=\"number\">33</span>; <span class=\"comment\">// 对象所属类的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> magic             : <span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> weakly_referenced : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> deallocating      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_sidetable_rc  : <span class=\"number\">1</span>; <span class=\"comment\">// 引用计数表里是否有当前对象的引用计数</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> extra_rc          : <span class=\"number\">19</span>; <span class=\"comment\">// 对象的引用计数 - 1</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>SideTables</code>–&gt;<code>SideTable</code>–&gt;引用计数表、若引用表</p>\n</li>\n</ul>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220627183629.png\" alt=\"SideTables\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class=\"line\">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct SideTable &#123;</span><br><span class=\"line\">    spinlock_t slock; // 自旋锁</span><br><span class=\"line\">    RefcountMap refcnts; // 引用计数表</span><br><span class=\"line\">    weak_table_t weak_table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef objc::DenseMap&lt;objc_object */*对象的内存地址*/, unsigned long/*对象的引用计数*/&gt; RefcountMap;</span><br><span class=\"line\"></span><br><span class=\"line\">struct weak_table_t &#123;</span><br><span class=\"line\">    weak_entry_t *weak_entries; // 这个其实才是弱引用表，表中元素为weak_entry_t结构体</span><br><span class=\"line\">    size_t    num_entries;</span><br><span class=\"line\">    uintptr_t mask;</span><br><span class=\"line\">    uintptr_t max_hash_displacement;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    objc_object *obj; // 对象的内存地址</span><br><span class=\"line\">    weak_referrer_t *referrers; // 指向该对象的弱指针数组——即所有指向该对象的弱指针（其实存储的是弱指针对应那块内存的地址，但是我们直接理解为弱指针是没有问题的）</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 例如：</span><br><span class=\"line\">id obj = [[NSObject alloc] init];</span><br><span class=\"line\">__weak id weakObj1 = obj;</span><br><span class=\"line\">__weak id weakObj2 = obj;</span><br><span class=\"line\">__weak id weakObj3 = obj;</span><br><span class=\"line\"></span><br><span class=\"line\">// NSObject对象的weak_entry为：</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    objc_object *obj; // 对象的内存地址</span><br><span class=\"line\">    weak_referrer_t *referrers; // 指向该对象的弱指针数组</span><br><span class=\"line\">&#125; NSObjectWeakEntry = &#123;</span><br><span class=\"line\">    obj;</span><br><span class=\"line\">    [weakObj1, weakObj2, weakObj3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>SideTables</code>是一个全局的散列表，它里面存储着64个<code>SideTable</code>结构体，而每个<code>SideTable</code>结构体内部又存储着1个引用计数表和1个弱引用计数表，所以项目中一般会有64个引用计数表和64个弱引用计数表。引用计数表也是一个散列表，表中的元素是一个字典：<code>key</code>为对象的内存地址，<code>value</code>为对象的引用计数，引用计数表里存储着很多对象的引用计数。若引用计数表也是一个散列表，表中的元素是一个结构体：一个成员变量是对象的内存地址，另一个成员变量是指向该对象的弱指针数组。</p>\n<p>所以如果我们想要找到对象的引用计数和弱指针数组，就要首先把对象的内存地址通过某种散列算法得到一个<code>index</code>，就可以在<code>SideTables</code>里找到对象的引用计数和弱指针数组所在的<code>SideTable</code>结构体，也就是找到了引用计数和弱指针数组所在的引用计数表和弱引用计数表，然后再次把对象的内存地址通过某种散列算法得到一个<code>index</code>，就可以在引用计数表里找到对象的引用计数，弱引用计数表里找到对象的弱指针数组了。</p>\n<p><strong>2.3 iOS具体是怎么通过引用计数来进行对象的内存管理的</strong></p>\n<p>主要是通过<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>，<code>retain</code>，<code>release</code>、<code>autorelease</code>，<code>dealoc</code>这几个方法操作引用计数，来管理对象内存管理的，即：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628181747.png\" alt=\"img\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NSObject.mm</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)release &#123;</span><br><span class=\"line\">    self-&gt;<span class=\"built_in\">rootRelease</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">objc_object::rootRelease</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">rootRelease</span>(<span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">objc_object::rootRelease</span><span class=\"params\">(<span class=\"type\">bool</span> performDealloc, <span class=\"type\">bool</span> handleUnderflow)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isTaggedPointer</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">isa_t</span> newisa = <span class=\"built_in\">LoadExclusive</span>(&amp;isa.bits);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newisa.nonpointer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 去引用计数表里让它的引用计数-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">sidetable_release</span>(performDealloc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用来标识extra_rc是否下溢——即是否减为-1（因为extra_rc存储的是（引用计数 - 1），所以减为0的时候说明引用计数为1，还有人引用它，没事儿）</span></span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> carry;</span><br><span class=\"line\">    <span class=\"comment\">// 首先去isa共用体里，让对象的引用计数-1</span></span><br><span class=\"line\">    newisa.bits = <span class=\"built_in\">subc</span>(newisa.bits, RC_ONE, <span class=\"number\">0</span>, &amp;carry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (carry) &#123; <span class=\"comment\">// 所以如果extra_rc下溢了：</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> underflow; <span class=\"comment\">// 跳转到underflow处执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表明没有下溢，结束</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> underflow: <span class=\"comment\">// extra_rc下溢了：</span></span><br><span class=\"line\"></span><br><span class=\"line\">    newisa = <span class=\"built_in\">LoadExclusive</span>(&amp;isa.bits);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newisa.has_sidetable_rc) &#123; <span class=\"comment\">// 如果引用计数表里有当前对象的引用计数，说明还有人使用该对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 尝试从引用计数表搬回来128个引用计数</span></span><br><span class=\"line\">        <span class=\"type\">size_t</span> borrowed = <span class=\"built_in\">sidetable_subExtraRC_nolock</span>(RC_HALF);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (borrowed) &#123; <span class=\"comment\">// 如果搬成功了</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 存进去</span></span><br><span class=\"line\">            newisa.extra_rc = borrowed - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 更新一下对象的isa共用体</span></span><br><span class=\"line\">            isa = newisa;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 搬失败了，说明引用计数表里的引用计数也为0了（可能是被上一次搬完了）</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 走dealloc方法销毁该对象</span></span><br><span class=\"line\">            ((<span class=\"built_in\">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class=\"keyword\">this</span>, SEL_dealloc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 引用计数表里没有当前对象的引用计数，说明没人使用该对象了</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 走dealloc方法销毁该对象</span></span><br><span class=\"line\">        ((<span class=\"built_in\">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class=\"keyword\">this</span>, SEL_dealloc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试从引用计数表搬回来128个引用计数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">objc_object::sidetable_subExtraRC_nolock</span><span class=\"params\">(<span class=\"type\">size_t</span> delta_rc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SideTable&amp; table = <span class=\"built_in\">SideTables</span>()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\">    RefcountMap::iterator it = table.refcnts.<span class=\"built_in\">find</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == table.refcnts.<span class=\"built_in\">end</span>()  ||  it-&gt;second == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 引用计数表里的引用计数被上一次搬完了</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 引用计数表里的引用计数-128，搬出去</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> oldRefcnt = it-&gt;second;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT);</span><br><span class=\"line\">    it-&gt;second = newRefcnt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> delta_rc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于<code>autorelease</code>和<code>autoreleasepool</code>就暂时理解这么一点，更底层的东西有空再说：</p>\n<ul>\n<li><code>release</code>会立即使对象的引用计数-1，而<code>autorelease</code>则不会，它仅仅是把该对象注册到了<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时系统会自动让池中所有的对象都调用一下<code>release</code>，这时对象的引用计数才-1。</li>\n<li>而<code>autoreleasepool</code>又是在RunLoop休眠或退出时销毁的，当然如果是我们自己创建的<code>@autoreleasepool&#123;&#125;</code>，出了大括号——即出了<code>@autoreleasepool&#123;&#125;</code>的生命周期，它就会销毁。</li>\n<li>只要不是用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法创建的对象，而是用类方法创建的对象，方法内部都调用了<code>autorelease</code>，都是<code>autorelease</code>对象。</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>如果对象的引用计数减为0了，就代表没人想使用该对象了，系统就会调用<code>dealloc</code>方法销毁它，并释放它对应的内存，对象一经销毁就不能再访问了，因为他的内存随时会被移作它用。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628182915.png\" alt=\"img\"></p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NSObject.mm</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    _objc_rootDealloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> _objc_rootDealloc(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    obj-&gt;<span class=\"built_in\">rootDealloc</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::rootDealloc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !isa.has_cxx_dtor  &amp;&amp; <span class=\"comment\">// 如果当前对象没使用过C++析构函数</span></span><br><span class=\"line\">        !isa.has_assoc  &amp;&amp; <span class=\"comment\">// 如果当前对象没有关联对象</span></span><br><span class=\"line\">        !isa.weakly_referenced  &amp;&amp; <span class=\"comment\">// 如果弱引用表里没有当前对象的弱指针数组</span></span><br><span class=\"line\">        !isa.has_sidetable_rc <span class=\"comment\">// 如果引用计数表里没有当前对象的引用计数</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 就直接销毁对象，并释放它对应的内存，即我们之前说的对象销毁时会更快</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 否则就慢慢销毁</span></span><br><span class=\"line\">        <span class=\"built_in\">object_dispose</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">id <span class=\"title\">object_dispose</span><span class=\"params\">(id obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">objc_destructInstance</span>(obj);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁对象，并释放它对应的内存，</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">objc_destructInstance</span><span class=\"params\">(id obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果当前对象使用过C++析构函数</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> cxx = obj-&gt;<span class=\"built_in\">hasCxxDtor</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前对象有关联对象</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> assoc = obj-&gt;<span class=\"built_in\">hasAssociatedObjects</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 要按顺序销毁哦</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cxx) <span class=\"built_in\">object_cxxDestruct</span>(obj); <span class=\"comment\">// 销毁C++析构函数相关的东西</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (assoc) _object_remove_assocations(obj); <span class=\"comment\">// 移除关联对象</span></span><br><span class=\"line\">        obj-&gt;<span class=\"built_in\">clearDeallocating</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::clearDeallocating</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearDeallocating_slow</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::clearDeallocating_slow</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取SideTable</span></span><br><span class=\"line\">    SideTable&amp; table = <span class=\"built_in\">SideTables</span>()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.weakly_referenced) &#123; <span class=\"comment\">// 如果弱引用表里有当前对象的弱指针数组</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 把弱引用表里所有指向该对象的弱指针都置为nil，并移除，从此弱引用表里就没有该对象的弱指针数组（关于弱指针（弱引用）更多详细的内容，见下面__weak指针的实现原理）</span></span><br><span class=\"line\">        <span class=\"built_in\">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.has_sidetable_rc) &#123; <span class=\"comment\">// 如果引用计数表里有当前对象的引用计数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 从引用计数表里把该对象的引用计数给抹掉，从此引用计数表里就没有该对象的引用计数了</span></span><br><span class=\"line\">        table.refcnts.<span class=\"built_in\">erase</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、MRC介绍，需要开发工程师做哪些工作\"><a href=\"#二、MRC介绍，需要开发工程师做哪些工作\" class=\"headerlink\" title=\"二、MRC介绍，需要开发工程师做哪些工作\"></a>二、MRC介绍，需要开发工程师做哪些工作</h3><p>MRC（<em>Manual Reference Count</em>）：指手动管理引用计数，即需要程序员自己手动调用上面那几个<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>，<code>retain</code>，<code>release</code>、<code>autorelease</code>，<code>dealoc</code>方法来操作引用计数，从而完成对象的内存管理。具体地说，MRC下我们需要做到以下三点：</p>\n<ul>\n<li>调用了<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>创建对象的地方，在不想使用对象时，要调用</li>\n</ul>\n<p><code>release</code>、<code>autorelease</code>；调用了<code>retain</code>使对象引用计数+1的地方，在不想使用对象时，要调用</p>\n<p><code>release</code>、<code>autorelease</code>来使对象的引用计数-1。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 调用了alloc、new、copy、mutableCopy创建对象</span></span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr1 = [<span class=\"built_in\">NSArray</span> new];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr2 = [arr <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *arr3 = [arr1 mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 调用release、autorelease来释放对象</span></span><br><span class=\"line\">    [arr release];</span><br><span class=\"line\">    [arr1 release];</span><br><span class=\"line\">    [arr2 autorelease];</span><br><span class=\"line\">    [arr3 autorelease];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">    <span class=\"comment\">// 调用了retain使对象引用计数+1</span></span><br><span class=\"line\">    [arr <span class=\"keyword\">retain</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 要调用release、autorelease来使对象的引用计数-1</span></span><br><span class=\"line\">    [arr release];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//或者调用下面</span></span><br><span class=\"line\">    <span class=\"comment\">//[arr autorelease];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们还需要处理好<code>setter</code>方法内部的内存管理，并在<code>dealloc</code>方法里释放当前类及其父类<strong>所有对象类型</strong>的成员变量。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> _age;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_name;</span><br><span class=\"line\">    INEDog *_dog;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setAge:(<span class=\"type\">int</span>)age &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _age = age; <span class=\"comment\">// 直接赋值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setDog:(INEDog *)dog &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_dog != dog) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_dog release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _dog = [dog <span class=\"keyword\">retain</span>]; <span class=\"comment\">// 持有新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 释放当前类所有对象类型的成员变量</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setName:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setDog:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放父类所有对象类型的成员变量，放在最后</span></span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们还需要处理好循环引入问题。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// INEMan.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">INEWoman</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEMan</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setWoman:(INEWoman *)woman;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// INEMan.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEMan.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEWoman.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    INEWoman *_woman;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setWoman:(INEWoman *)woman &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_woman != woman) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\"></span><br><span class=\"line\">        [_woman release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _woman = [woman <span class=\"keyword\">retain</span>]; <span class=\"comment\">// 持有新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setWoman:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// INEWoman.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">INEMan</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEWoman</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setMan:(INEMan *)man;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// INEWoman.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEWoman.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEMan.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEWoman</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    INEMan *_man;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setMan:(INEMan *)man &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    _man = man; <span class=\"comment\">// 为了避免循环引用，这里不能retain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setMan:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"meta\">super viewDidLoad</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    INEMan *man = [[INEMan alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    INEWoman *woman = [[INEWoman alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"meta\">man setWoman:woman</span>];</span><br><span class=\"line\">    [<span class=\"meta\">woman setMan:man</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"meta\">man release</span>];</span><br><span class=\"line\">    [<span class=\"meta\">woman release</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 控制台打印：两个对象都可以正常销毁</span></span><br><span class=\"line\">-[INEWoman dealloc]</span><br><span class=\"line\">-[INEMan dealloc]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"三、ARC介绍，编译器帮我们做了什么\"><a href=\"#三、ARC介绍，编译器帮我们做了什么\" class=\"headerlink\" title=\"三、ARC介绍，编译器帮我们做了什么\"></a>三、ARC介绍，编译器帮我们做了什么</h4><p>ARC（<em>Autal Reference Count</em>）：自动管理引用计数，让<strong>编译器</strong>进行内存管理，<strong>在LVVM编译器中设置ARC为有效状态，就无需再次键入<code>retain</code>、<code>realeas</code>、<code>autorelease</code>代码，编译器会在合适的地方自动帮我们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用，从而完成对象的内存管理。但实际上除了编译器之外，ARC还用到了Runtime，比如<code>weak</code>指针的清空。</strong>这样就会在降低程序崩溃、内存泄漏风险的同时，很大程度程度减少了开发的工作量，使应用程序具有可预测性，且能流畅运行，速度也将大幅提升。具体来说，与MRC相对应，ARC帮我们做了如下三点：</p>\n<ul>\n<li><p>利用<code>__strong</code>指针修饰符，编译器会在合适的地方帮们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用；</p>\n</li>\n<li><p>利用属性修饰符，编译器为我们生成特定的<code>setter</code>方法并处理好内部的内存管理，还会自动在<code>dealloc</code>方法里释放当前类及其父类的成员变量；</p>\n</li>\n<li><p>利用<code>__weak</code>指针修饰符和Runtime，来处理循环引入问题。</p>\n</li>\n</ul>\n<h4 id=\"1-指针修饰符\"><a href=\"#1-指针修饰符\" class=\"headerlink\" title=\"1.指针修饰符\"></a>1.指针修饰符</h4><ul>\n<li><p><code>__strong</code>指针修饰符</p>\n<p>凡是用<code>__strong</code>修饰的指针，在超出其作用域时，编译器会为我们插入一次<code>release</code>或<code>autorelease</code>的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">等价于：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MRC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"type\">id</span> arr = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    [arr autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>而在指针赋值时，编译器会自动为我们插入一次<code>retain</code>的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj1 = obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">等价于：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MRC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"type\">id</span> obj1 = [obj <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    [obj1 release];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以正是因为使用<code>__strong</code>指针修饰符，编译器才会在合适的地方帮我们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用，而ARC下所有指针默认都是用<code>__strong</code>修饰的。</p>\n<ul>\n<li><code>__weak</code>指针修饰符</li>\n</ul>\n<p>看起来有了<code>strong</code>,编译器就可以很好的管理内存了，但是很重要的一点是<code>__strong</code>无法解决引用计数式内存管理必然会导致的“循环引入”问题。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// INEMan.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">INEWoman</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEMan</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> INEWoman *_woman; <span class=\"comment\">// 强引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setWoman:(INEWoman *)woman;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// INEMan.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEMan.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEMan</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setWoman:(INEWoman *)woman &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    _woman = woman;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// INEWoman.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">INEMan</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEWoman</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> INEMan *_man; <span class=\"comment\">// 强引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setMan:(INEMan *)man;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// INEWoman.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEWoman.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEWoman</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setMan:(INEMan *)man &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    _man = man;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewController.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"meta\">super viewDidLoad</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    INEMan *man = [[INEMan alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    INEWoman *woman = [[INEWoman alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"meta\">man setWoman:woman</span>];</span><br><span class=\"line\">    [<span class=\"meta\">woman setMan:man</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 控制台打印：无</span></span><br></pre></td></tr></table></figure>\n\n<p><code>viewDidLoad</code>执行完，<code>Man</code>对象和<code>Woman</code>对象的<code>dealloc</code>方法都没走，也就是说它们俩都没销毁，这就是因为它们俩形成了循环引用，导致了内存泄漏。</p>\n<p>但是只要我们把循环引用中的一个强指针的换成弱指针，就可以解决问题。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEMan</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">     __<span class=\"keyword\">weak</span> INEWoman *_woman; <span class=\"comment\">// 弱引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">或者：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEWoman</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> INEMan *_man; <span class=\"comment\">// 强引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么能解决呢？这就要来看看**<code>__weak</code>指针的实现原理：**</p>\n<ul>\n<li><p><strong><code>__weak</code>指针是专门用来解决循环引用问题的，它不是通过引用计数来管理对象的，而是通过弱引用表。</strong>具体地说：</p>\n<p><strong>1.当我们把一个强指针赋值给一个弱指针时，编译器不会怒自动帮我们插入<code>retain</code>使对象的引用计数+1，而是把这个弱指针和对象的内存地址绑在一起，通过两次散列算法找到弱引用计数表里的弱指针数组，然后把这个弱指针存到弱指针数组里。这样我们通过这些弱指针既可以正常使用该对象，又无需顾虑是不是要在什么时候把对象的引用计数-1，以免对象的引用计数&gt;0而无法销毁，因为他没有参数引用计数那一套。</strong></p>\n<p><strong>2.当对象销毁时会走dealloc方法，又会通过两次散列算法找到弱引用计数表里的数组，把指向该对象的弱指针都置为<code>nil</code>并移除。</strong></p>\n</li>\n</ul>\n<h4 id=\"2-属性修饰符\"><a href=\"#2-属性修饰符\" class=\"headerlink\" title=\"2.属性修饰符\"></a>2.属性修饰符</h4><p>属性修饰符一共有三对儿：<strong>原子性、读写权限和内存管理语意</strong>，属性修饰符主要影响就是编译器为成员变量生成的<code>setter</code>、<code>getter</code>方法上。（这里除了讲解和内存相关的知识外，其他的也回顾一下）</p>\n<blockquote>\n<p>原子性：<code>atomic</code>（默认）、<code>nonatomic</code></p>\n</blockquote>\n<ul>\n<li><p><code>atomic</code>：默认为<code>atomic</code>，使用<code>atomic</code>修饰的属性，编译器为该属性生成的<code>setter</code>、<code>getter</code>方法内部是加了锁的。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (atomic, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableArray</span> *array;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setArray:(<span class=\"built_in\">NSMutableArray</span> *)array &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    _array = array;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableArray</span> *)array &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _array;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>但这仅仅是保证我们调用<code>setter</code>、<code>getter</code>方法访问属性这一步是线程安全的，它没发保证我们使用属性的线程是安全的，比如我们调用<code>[self.array addObject:xxx]</code>,<code>self.array</code>访问属性这一步是线程安全的，但<code>addObject:</code>使用属性这一步是线程不安全的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程1</span><br><span class=\"line\">[self.array addObject:@&quot;11&quot;];</span><br><span class=\"line\">// 线程2</span><br><span class=\"line\">[self.array addObject:@&quot;12&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">等价于</span><br><span class=\"line\"></span><br><span class=\"line\">// 线程1</span><br><span class=\"line\">[[self array] addObject:@&quot;11&quot;];</span><br><span class=\"line\">// 线程2</span><br><span class=\"line\">[[self array] addObject:@&quot;12&quot;];</span><br></pre></td></tr></table></figure>\n\n<p>所以为了保证使用属性的线程安全，我们还得在需要的地方自己加锁，这样一来使用使用<code>atomic</code>修饰属性就多此一举了，而且<code>stter</code>、<code>getter</code>方法的调用通常都是很频繁的，内部加锁的话会增加内存的开销，耗费性能。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">[<span class=\"built_in\">self</span>.<span class=\"keyword\">array</span> addObject:@<span class=\"string\">&quot;11&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">[<span class=\"built_in\">self</span>.<span class=\"keyword\">array</span> addObject:@<span class=\"string\">&quot;12&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>nonatomic</code>：因此我们在实际开发中总是使用<code>nonatomic</code>。</li>\n</ul>\n<blockquote>\n<p>读写权限：<code>readwrite</code>(默认)、<code>readonly</code></p>\n</blockquote>\n<ul>\n<li><code>readwrite</code>：默认为<code>readwrite</code>，代表该属性可读可写，编译器会为该属性生成<code>setter</code></li>\n</ul>\n<p><code>getter</code>方法的声明与实现。</p>\n<ul>\n<li><code>readonly</code>：代表该属性只能读取不能写入，编译器会为该属性生成<code>setter</code>、<code>getter</code>方法的声明与<code>getter</code>方法的实现。</li>\n</ul>\n<blockquote>\n<p>内存管理语意：</p>\n<ul>\n<li>MRC下有：<code>assign</code>、<code>retain</code>、<code>copy</code>。</li>\n<li>ARC下新增了：<code>strong</code>、<code>weak</code>、<code>unsafe_unretained</code>。</li>\n</ul>\n</blockquote>\n<ul>\n<li><code>assign</code>：<code>assign</code>一般来修饰基本数据类型。使用<code>assign</code>修饰属性，编译器为属性生成的<code>setter</code>方法内部只是简单的赋值操作。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setAge:(<span class=\"type\">int</span>)age &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 简单的赋值操作</span></span><br><span class=\"line\">    _age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>retain</code>：<code>retain</code>一般用来修饰对象类型。使用<code>retain</code>修饰的属性，编译器为该属性生成的<code>setter</code>方法内部会调用一下<code>retain</code>方法，是对象的引用计数+1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setDog:(Dog *)dog &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (_dog != dog) &#123; // 新旧对象不一样时</span><br><span class=\"line\">        </span><br><span class=\"line\">        [_dog release]; // 释放旧对象</span><br><span class=\"line\">        _dog = [dog retain]; // 持有新对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>copy</code>：<code>copy</code>一般用来修饰不可变属性和block。使用<code>copy</code>修饰的属性，编译器为该属性生成的<code>setter</code>方法内部会调用一下<code>copy</code>方法，生成一个新的对象，新对象的引用计数为1，而旧对象的引用计数不变。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>strong</code>：默认为<code>strong</code>，大多数情况下和<code>retain</code>的效果是一样的，修饰block和<code>copy</code>的效果是一样的，<code>strong</code>一般用来修饰对象类型。</p>\n</li>\n<li><p><code>weak</code>：<code>weak</code>一般用来修饰代理对象和<code>NSTimer</code>，以免造成循环引入；还有用来修饰xib或sb拖出来的控件，因为这些界面已经被添加到界面上了，被subviews这个属性持有了，不必再用变量持有。</p>\n</li>\n<li><p><code>unsafe_unretained</code>：和<code>assign</code>效果是一样的，如果用他们来修饰对象类型，和<code>weak</code>功能类似，但<code>weak</code>修饰的属性会在对象销毁时会被置为<code>nil</code>，比较安全，而<code>unsafe_unretained</code>和<code>assign</code>修饰的属性则不会，所以容易出现野指针。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一、iOS内存管理方式：</p>\n<p>​    1.Tagged Pointer：小对象的内存管理方式</p>\n<p>​    2.引用计数：普通对象的内存管理方式</p>\n<p>二、MRC介绍，需要开发工程师做哪些工作</p>\n<p>三、ARC介绍，编译器帮我们做了什么</p>","more":"<p>​    1.指针修饰符</p>\n<p>​        1. __strong</p>\n<p>​        2. __weak</p>\n<p>​        3. __unsafe_unretained</p>\n<p>​        4. __autoreease</p>\n<p>​    2.属性修饰符</p>\n<p>​        2.1 原子性：<code>atomic</code>、<code>nonatomic</code></p>\n<p>​        2.2 读写权限：<code>readwrite</code>、<code>readonly</code></p>\n<p>​        2.3 内存管理语义：<code>assign</code>、<code>retain</code>、<code>copy</code>、<code>strong</code>、<code>weak</code>、<code>unsafe_unretained</code></p>\n</blockquote>\n<h3 id=\"一、内存管理方式：\"><a href=\"#一、内存管理方式：\" class=\"headerlink\" title=\"一、内存管理方式：\"></a>一、内存管理方式：</h3><h4 id=\"1-Tagged-Pointer：小对象的内存管理方式\"><a href=\"#1-Tagged-Pointer：小对象的内存管理方式\" class=\"headerlink\" title=\"1.Tagged Pointer：小对象的内存管理方式\"></a>1.Tagged Pointer：小对象的内存管理方式</h4><p>64位操作系统后，iOS引入了Tagged Pointer，用来优化NSString、NSNumber、NSDate的内存管理。</p>\n<p>引入Tagged Pointer之前（32位操作系统时），小对象内存管理方式和普通对象一样，首先需要在堆区开辟一块内存，并把内存的地址赋值给栈区的指针变量，然后维护对象的引用计数和内存的释放。</p>\n<p>比如我们创建一个int类型的NSNumber对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNumber *number = @11;</span><br></pre></td></tr></table></figure>\n\n<p>系统需要开辟16个字节的内存来存储11这个值，同时需要开辟8个字节大小的内存来存储这个对象的地址，本来需要占用4个字节的内存的Int类型数据，占用了24个字节，同时还没考虑维护引用计数和内存释放等的内存开销。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/nsnumber.png\" alt=\"使用Tagged pointer前的内存管理\"></p>\n<p>在引入Tagged Pointer之后，<strong>小对象就不需要像之前那样 在堆区开辟内存，维护引用计数，释放内存了。而是直接把值存到了number指针里，number里面存的不再是一个地址了，而是Tag + Data，Tag是用来标记小对象的类型（NSString、NSNumber、NSDate），Data就是小对象的值。指针什么时候创建，小对象就什么时候创建，指针什么时候销毁，小对象就什么时候销毁。只有在指针存不下小对象的值时，才会变为引用计数的方式管理内存。</strong>这样，仅需要8个字节就可以存储小对象的类型和值，很大程度上节省了内存占用，同时也减少了维护引用计数、内存释放等带来的开销。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E4%BD%BF%E7%94%A8Tagged.png\" alt=\"使用Tagged Pointer后的内存管理\"></p>\n<p>用代码验证一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  苹果对Tagged Pointer做了数据混淆，所以在分析Tagged Pointer之前，我们需要先关闭Tagged Pointer的数据混淆。通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为YES。否则无法分析打印出的结果</span><br><span class=\"line\">- (void)testTaggedPointer &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSNumber *number1 = @1;</span><br><span class=\"line\">    NSNumber *number2 = @2;</span><br><span class=\"line\">    NSNumber *number3 = @10;</span><br><span class=\"line\">    NSNumber *number4 = @(0xFFFFFFFFFFFFFFFF);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;number1:%p&quot;, number1);</span><br><span class=\"line\">    NSLog(@&quot;number2:%p&quot;, number2);</span><br><span class=\"line\">    NSLog(@&quot;number3:%p&quot;, number3);</span><br><span class=\"line\">    NSLog(@&quot;number4:%p&quot;, number4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">number1:0xb000000000000012</span><br><span class=\"line\">number2:0xb000000000000022</span><br><span class=\"line\">number3:0xb0000000000000a2</span><br><span class=\"line\">number4:0x600001be2060</span><br></pre></td></tr></table></figure>\n\n<p>number1～number3指针是Tagged Pointer，number4由于值大到存储不下了，改为普通对象内存管理方式。对应的地址分布规律见下图（mac os系统的规律与iOS系统的规律不同 <a href=\"https://cloud.tencent.com/developer/article/1620346\">详细</a>），可发现规律<strong>如果一个指针的最高位为1，那么他就是Tagged Pointer，否则就不是。</strong></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623191932.png\" alt=\"ios-nsnumber\"></p>\n<p>如果是NSString的话，Tagged Pointer内存地址分布规律就是下面这样的：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623195417.png\" alt=\"ios-nsstring\"></p>\n<p>学习完上面内容，我们举个例子验证下，找不同：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开辟多个线程去修改name属性</span></span><br><span class=\"line\"><span class=\"comment\">// 代码1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@&quot;abcdefghijk&quot;</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代码2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@&quot;abc&quot;</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行代码我们会发现 代码1 会crash，因为<code>abcdefghijk</code>已经大到指针存储不下，改为了普通对象内存管理方式，所以 代码1 就是正常的调用<code>setter</code>方法修改<code>name</code>属性,<code>setter</code>的实现是这样的：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不加锁的情况下，极容易发生多个线程同时调用<code>[_name release]</code>的情况，若<code>_name</code>已经销毁，再次调用<code>release</code>肯定会发生crash。</p>\n<p>代码2 正常运行，是因为<code>abc</code>并没有大到指针存储不下，<code>NSString</code>为<code>NSTaggedPointerString</code>类型，在<code>objc_release</code>函数中会判断指针是不是<code>TaggedPointer</code>类型，是的话就不对对象进行<code>release</code>操作，也就避免了因过度释放对象而导致的<code>Crash</code>，因为根本就没执行释放操作。</p>\n<h4 id=\"2-引用计数：普通对象的内存管理方式\"><a href=\"#2-引用计数：普通对象的内存管理方式\" class=\"headerlink\" title=\"2.引用计数：普通对象的内存管理方式\"></a>2.引用计数：普通对象的内存管理方式</h4><p><strong>2.1 引用计数是什么？</strong></p>\n<p><strong>iOS是通过引用计数来管理内存的。所谓的引用计数就是指每当我们创建一个对象，系统就会为该对象分配一个整数，用来表征当前有多少人想使用该对象。</strong>那就引出两个问题：</p>\n<p>问题1：创建对象时，系统为对象分配的整数存在哪里？也就是引用计数存在哪里？因为我们知道OC对象内部只有一个<code>isa</code>，并没有引用计数的成员变量</p>\n<p>问题2：iOS具体是怎么通过引用计数来管理内存的？</p>\n<p><strong>2.2 引用计数存储在哪里？</strong></p>\n<p>64位操作系统以前，对象的<code>isa</code>指针还没进行内存优化，对象的引用计数存储在引用计数表里。</p>\n<p>当系统为64位操作系统后，对象的<code>isa</code>指针经过了内存优化，它不再直接是一个指针了，而是一个共用体，64位中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1），还有1位用来标记引用计数表里是否有当前对象的引用计数。具体地说：<strong>对象的引用计数首先会存储在<code>isa</code>共用体里——<code>extra_rc</code>变量，但是<code>isa</code>共用体的引用计数存储范围是0～255，一旦引用计数超过了255，这个变量就会溢出，此时系统会把这个变量置为128，同时把引用计数表里是否有当前对象的引用计数的标记——<code>has_sidetable_rc</code>变量置为1，并把另外128个引用计数挪到引用计数表里进行存储。下一次对象的引用计数再次增加时，依旧增加<code>isa</code>共用体里的引用计数（因为它已被置为128，不再是溢出状态），直到再次溢出，系统再娜128个引用计数到引用计数表里，如此循环往复。</strong></p>\n<p>因此可以看出，系统是不会直接操作引用计数表里的引用计数的，而总是在操作<code>isa</code>共用体里的引用计数，直到溢出时才从<code>isa</code>共用体里挪128个引用计数到引用计数表里进行存储。</p>\n<ul>\n<li><p><code>isa</code>共用体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">objc_object</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">isa_t</span> isa; <span class=\"comment\">// 一个isa_t类型的共用体</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义的成员变量，存储着该对象这些成员变量具体的值</span></span><br><span class=\"line\">    NSSring *_name; <span class=\"comment\">// “张三”</span></span><br><span class=\"line\">    NSSring *_sex; <span class=\"comment\">// “男”</span></span><br><span class=\"line\">    <span class=\"type\">int</span> _age; <span class=\"comment\">// 33</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">isa_t</span> &#123;</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> bits; <span class=\"comment\">// 8个字节，64位</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">// 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着谁的数据</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">if</span> __arm64__</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"keyword\">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> nonpointer        : <span class=\"number\">1</span>; <span class=\"comment\">// isa是否经过内存优化</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_assoc         : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_cxx_dtor      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> shiftcls          : <span class=\"number\">33</span>; <span class=\"comment\">// 对象所属类的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> magic             : <span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> weakly_referenced : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> deallocating      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_sidetable_rc  : <span class=\"number\">1</span>; <span class=\"comment\">// 引用计数表里是否有当前对象的引用计数</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> extra_rc          : <span class=\"number\">19</span>; <span class=\"comment\">// 对象的引用计数 - 1</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>SideTables</code>–&gt;<code>SideTable</code>–&gt;引用计数表、若引用表</p>\n</li>\n</ul>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220627183629.png\" alt=\"SideTables\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class=\"line\">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct SideTable &#123;</span><br><span class=\"line\">    spinlock_t slock; // 自旋锁</span><br><span class=\"line\">    RefcountMap refcnts; // 引用计数表</span><br><span class=\"line\">    weak_table_t weak_table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef objc::DenseMap&lt;objc_object */*对象的内存地址*/, unsigned long/*对象的引用计数*/&gt; RefcountMap;</span><br><span class=\"line\"></span><br><span class=\"line\">struct weak_table_t &#123;</span><br><span class=\"line\">    weak_entry_t *weak_entries; // 这个其实才是弱引用表，表中元素为weak_entry_t结构体</span><br><span class=\"line\">    size_t    num_entries;</span><br><span class=\"line\">    uintptr_t mask;</span><br><span class=\"line\">    uintptr_t max_hash_displacement;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    objc_object *obj; // 对象的内存地址</span><br><span class=\"line\">    weak_referrer_t *referrers; // 指向该对象的弱指针数组——即所有指向该对象的弱指针（其实存储的是弱指针对应那块内存的地址，但是我们直接理解为弱指针是没有问题的）</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 例如：</span><br><span class=\"line\">id obj = [[NSObject alloc] init];</span><br><span class=\"line\">__weak id weakObj1 = obj;</span><br><span class=\"line\">__weak id weakObj2 = obj;</span><br><span class=\"line\">__weak id weakObj3 = obj;</span><br><span class=\"line\"></span><br><span class=\"line\">// NSObject对象的weak_entry为：</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    objc_object *obj; // 对象的内存地址</span><br><span class=\"line\">    weak_referrer_t *referrers; // 指向该对象的弱指针数组</span><br><span class=\"line\">&#125; NSObjectWeakEntry = &#123;</span><br><span class=\"line\">    obj;</span><br><span class=\"line\">    [weakObj1, weakObj2, weakObj3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>SideTables</code>是一个全局的散列表，它里面存储着64个<code>SideTable</code>结构体，而每个<code>SideTable</code>结构体内部又存储着1个引用计数表和1个弱引用计数表，所以项目中一般会有64个引用计数表和64个弱引用计数表。引用计数表也是一个散列表，表中的元素是一个字典：<code>key</code>为对象的内存地址，<code>value</code>为对象的引用计数，引用计数表里存储着很多对象的引用计数。若引用计数表也是一个散列表，表中的元素是一个结构体：一个成员变量是对象的内存地址，另一个成员变量是指向该对象的弱指针数组。</p>\n<p>所以如果我们想要找到对象的引用计数和弱指针数组，就要首先把对象的内存地址通过某种散列算法得到一个<code>index</code>，就可以在<code>SideTables</code>里找到对象的引用计数和弱指针数组所在的<code>SideTable</code>结构体，也就是找到了引用计数和弱指针数组所在的引用计数表和弱引用计数表，然后再次把对象的内存地址通过某种散列算法得到一个<code>index</code>，就可以在引用计数表里找到对象的引用计数，弱引用计数表里找到对象的弱指针数组了。</p>\n<p><strong>2.3 iOS具体是怎么通过引用计数来进行对象的内存管理的</strong></p>\n<p>主要是通过<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>，<code>retain</code>，<code>release</code>、<code>autorelease</code>，<code>dealoc</code>这几个方法操作引用计数，来管理对象内存管理的，即：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628181747.png\" alt=\"img\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NSObject.mm</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)release &#123;</span><br><span class=\"line\">    self-&gt;<span class=\"built_in\">rootRelease</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">objc_object::rootRelease</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">rootRelease</span>(<span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">objc_object::rootRelease</span><span class=\"params\">(<span class=\"type\">bool</span> performDealloc, <span class=\"type\">bool</span> handleUnderflow)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isTaggedPointer</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">isa_t</span> newisa = <span class=\"built_in\">LoadExclusive</span>(&amp;isa.bits);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newisa.nonpointer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 去引用计数表里让它的引用计数-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">sidetable_release</span>(performDealloc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用来标识extra_rc是否下溢——即是否减为-1（因为extra_rc存储的是（引用计数 - 1），所以减为0的时候说明引用计数为1，还有人引用它，没事儿）</span></span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> carry;</span><br><span class=\"line\">    <span class=\"comment\">// 首先去isa共用体里，让对象的引用计数-1</span></span><br><span class=\"line\">    newisa.bits = <span class=\"built_in\">subc</span>(newisa.bits, RC_ONE, <span class=\"number\">0</span>, &amp;carry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (carry) &#123; <span class=\"comment\">// 所以如果extra_rc下溢了：</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> underflow; <span class=\"comment\">// 跳转到underflow处执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表明没有下溢，结束</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> underflow: <span class=\"comment\">// extra_rc下溢了：</span></span><br><span class=\"line\"></span><br><span class=\"line\">    newisa = <span class=\"built_in\">LoadExclusive</span>(&amp;isa.bits);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newisa.has_sidetable_rc) &#123; <span class=\"comment\">// 如果引用计数表里有当前对象的引用计数，说明还有人使用该对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 尝试从引用计数表搬回来128个引用计数</span></span><br><span class=\"line\">        <span class=\"type\">size_t</span> borrowed = <span class=\"built_in\">sidetable_subExtraRC_nolock</span>(RC_HALF);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (borrowed) &#123; <span class=\"comment\">// 如果搬成功了</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 存进去</span></span><br><span class=\"line\">            newisa.extra_rc = borrowed - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 更新一下对象的isa共用体</span></span><br><span class=\"line\">            isa = newisa;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 搬失败了，说明引用计数表里的引用计数也为0了（可能是被上一次搬完了）</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 走dealloc方法销毁该对象</span></span><br><span class=\"line\">            ((<span class=\"built_in\">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class=\"keyword\">this</span>, SEL_dealloc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 引用计数表里没有当前对象的引用计数，说明没人使用该对象了</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 走dealloc方法销毁该对象</span></span><br><span class=\"line\">        ((<span class=\"built_in\">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class=\"keyword\">this</span>, SEL_dealloc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试从引用计数表搬回来128个引用计数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">objc_object::sidetable_subExtraRC_nolock</span><span class=\"params\">(<span class=\"type\">size_t</span> delta_rc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SideTable&amp; table = <span class=\"built_in\">SideTables</span>()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\">    RefcountMap::iterator it = table.refcnts.<span class=\"built_in\">find</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == table.refcnts.<span class=\"built_in\">end</span>()  ||  it-&gt;second == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 引用计数表里的引用计数被上一次搬完了</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 引用计数表里的引用计数-128，搬出去</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> oldRefcnt = it-&gt;second;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT);</span><br><span class=\"line\">    it-&gt;second = newRefcnt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> delta_rc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于<code>autorelease</code>和<code>autoreleasepool</code>就暂时理解这么一点，更底层的东西有空再说：</p>\n<ul>\n<li><code>release</code>会立即使对象的引用计数-1，而<code>autorelease</code>则不会，它仅仅是把该对象注册到了<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时系统会自动让池中所有的对象都调用一下<code>release</code>，这时对象的引用计数才-1。</li>\n<li>而<code>autoreleasepool</code>又是在RunLoop休眠或退出时销毁的，当然如果是我们自己创建的<code>@autoreleasepool&#123;&#125;</code>，出了大括号——即出了<code>@autoreleasepool&#123;&#125;</code>的生命周期，它就会销毁。</li>\n<li>只要不是用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法创建的对象，而是用类方法创建的对象，方法内部都调用了<code>autorelease</code>，都是<code>autorelease</code>对象。</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>如果对象的引用计数减为0了，就代表没人想使用该对象了，系统就会调用<code>dealloc</code>方法销毁它，并释放它对应的内存，对象一经销毁就不能再访问了，因为他的内存随时会被移作它用。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628182915.png\" alt=\"img\"></p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NSObject.mm</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    _objc_rootDealloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> _objc_rootDealloc(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    obj-&gt;<span class=\"built_in\">rootDealloc</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::rootDealloc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !isa.has_cxx_dtor  &amp;&amp; <span class=\"comment\">// 如果当前对象没使用过C++析构函数</span></span><br><span class=\"line\">        !isa.has_assoc  &amp;&amp; <span class=\"comment\">// 如果当前对象没有关联对象</span></span><br><span class=\"line\">        !isa.weakly_referenced  &amp;&amp; <span class=\"comment\">// 如果弱引用表里没有当前对象的弱指针数组</span></span><br><span class=\"line\">        !isa.has_sidetable_rc <span class=\"comment\">// 如果引用计数表里没有当前对象的引用计数</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 就直接销毁对象，并释放它对应的内存，即我们之前说的对象销毁时会更快</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 否则就慢慢销毁</span></span><br><span class=\"line\">        <span class=\"built_in\">object_dispose</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">id <span class=\"title\">object_dispose</span><span class=\"params\">(id obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">objc_destructInstance</span>(obj);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁对象，并释放它对应的内存，</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">objc_destructInstance</span><span class=\"params\">(id obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果当前对象使用过C++析构函数</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> cxx = obj-&gt;<span class=\"built_in\">hasCxxDtor</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前对象有关联对象</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> assoc = obj-&gt;<span class=\"built_in\">hasAssociatedObjects</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 要按顺序销毁哦</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cxx) <span class=\"built_in\">object_cxxDestruct</span>(obj); <span class=\"comment\">// 销毁C++析构函数相关的东西</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (assoc) _object_remove_assocations(obj); <span class=\"comment\">// 移除关联对象</span></span><br><span class=\"line\">        obj-&gt;<span class=\"built_in\">clearDeallocating</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::clearDeallocating</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearDeallocating_slow</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::clearDeallocating_slow</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取SideTable</span></span><br><span class=\"line\">    SideTable&amp; table = <span class=\"built_in\">SideTables</span>()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.weakly_referenced) &#123; <span class=\"comment\">// 如果弱引用表里有当前对象的弱指针数组</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 把弱引用表里所有指向该对象的弱指针都置为nil，并移除，从此弱引用表里就没有该对象的弱指针数组（关于弱指针（弱引用）更多详细的内容，见下面__weak指针的实现原理）</span></span><br><span class=\"line\">        <span class=\"built_in\">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.has_sidetable_rc) &#123; <span class=\"comment\">// 如果引用计数表里有当前对象的引用计数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 从引用计数表里把该对象的引用计数给抹掉，从此引用计数表里就没有该对象的引用计数了</span></span><br><span class=\"line\">        table.refcnts.<span class=\"built_in\">erase</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、MRC介绍，需要开发工程师做哪些工作\"><a href=\"#二、MRC介绍，需要开发工程师做哪些工作\" class=\"headerlink\" title=\"二、MRC介绍，需要开发工程师做哪些工作\"></a>二、MRC介绍，需要开发工程师做哪些工作</h3><p>MRC（<em>Manual Reference Count</em>）：指手动管理引用计数，即需要程序员自己手动调用上面那几个<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>，<code>retain</code>，<code>release</code>、<code>autorelease</code>，<code>dealoc</code>方法来操作引用计数，从而完成对象的内存管理。具体地说，MRC下我们需要做到以下三点：</p>\n<ul>\n<li>调用了<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>创建对象的地方，在不想使用对象时，要调用</li>\n</ul>\n<p><code>release</code>、<code>autorelease</code>；调用了<code>retain</code>使对象引用计数+1的地方，在不想使用对象时，要调用</p>\n<p><code>release</code>、<code>autorelease</code>来使对象的引用计数-1。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 调用了alloc、new、copy、mutableCopy创建对象</span></span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr1 = [<span class=\"built_in\">NSArray</span> new];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr2 = [arr <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *arr3 = [arr1 mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 调用release、autorelease来释放对象</span></span><br><span class=\"line\">    [arr release];</span><br><span class=\"line\">    [arr1 release];</span><br><span class=\"line\">    [arr2 autorelease];</span><br><span class=\"line\">    [arr3 autorelease];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">    <span class=\"comment\">// 调用了retain使对象引用计数+1</span></span><br><span class=\"line\">    [arr <span class=\"keyword\">retain</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 要调用release、autorelease来使对象的引用计数-1</span></span><br><span class=\"line\">    [arr release];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//或者调用下面</span></span><br><span class=\"line\">    <span class=\"comment\">//[arr autorelease];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们还需要处理好<code>setter</code>方法内部的内存管理，并在<code>dealloc</code>方法里释放当前类及其父类<strong>所有对象类型</strong>的成员变量。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> _age;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_name;</span><br><span class=\"line\">    INEDog *_dog;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setAge:(<span class=\"type\">int</span>)age &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _age = age; <span class=\"comment\">// 直接赋值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setDog:(INEDog *)dog &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_dog != dog) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_dog release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _dog = [dog <span class=\"keyword\">retain</span>]; <span class=\"comment\">// 持有新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 释放当前类所有对象类型的成员变量</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setName:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setDog:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放父类所有对象类型的成员变量，放在最后</span></span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们还需要处理好循环引入问题。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// INEMan.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">INEWoman</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEMan</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setWoman:(INEWoman *)woman;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// INEMan.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEMan.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEWoman.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    INEWoman *_woman;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setWoman:(INEWoman *)woman &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_woman != woman) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\"></span><br><span class=\"line\">        [_woman release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _woman = [woman <span class=\"keyword\">retain</span>]; <span class=\"comment\">// 持有新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setWoman:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// INEWoman.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">INEMan</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEWoman</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setMan:(INEMan *)man;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// INEWoman.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEWoman.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEMan.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEWoman</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    INEMan *_man;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setMan:(INEMan *)man &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    _man = man; <span class=\"comment\">// 为了避免循环引用，这里不能retain</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setMan:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"meta\">super viewDidLoad</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    INEMan *man = [[INEMan alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    INEWoman *woman = [[INEWoman alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"meta\">man setWoman:woman</span>];</span><br><span class=\"line\">    [<span class=\"meta\">woman setMan:man</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"meta\">man release</span>];</span><br><span class=\"line\">    [<span class=\"meta\">woman release</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 控制台打印：两个对象都可以正常销毁</span></span><br><span class=\"line\">-[INEWoman dealloc]</span><br><span class=\"line\">-[INEMan dealloc]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"三、ARC介绍，编译器帮我们做了什么\"><a href=\"#三、ARC介绍，编译器帮我们做了什么\" class=\"headerlink\" title=\"三、ARC介绍，编译器帮我们做了什么\"></a>三、ARC介绍，编译器帮我们做了什么</h4><p>ARC（<em>Autal Reference Count</em>）：自动管理引用计数，让<strong>编译器</strong>进行内存管理，<strong>在LVVM编译器中设置ARC为有效状态，就无需再次键入<code>retain</code>、<code>realeas</code>、<code>autorelease</code>代码，编译器会在合适的地方自动帮我们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用，从而完成对象的内存管理。但实际上除了编译器之外，ARC还用到了Runtime，比如<code>weak</code>指针的清空。</strong>这样就会在降低程序崩溃、内存泄漏风险的同时，很大程度程度减少了开发的工作量，使应用程序具有可预测性，且能流畅运行，速度也将大幅提升。具体来说，与MRC相对应，ARC帮我们做了如下三点：</p>\n<ul>\n<li><p>利用<code>__strong</code>指针修饰符，编译器会在合适的地方帮们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用；</p>\n</li>\n<li><p>利用属性修饰符，编译器为我们生成特定的<code>setter</code>方法并处理好内部的内存管理，还会自动在<code>dealloc</code>方法里释放当前类及其父类的成员变量；</p>\n</li>\n<li><p>利用<code>__weak</code>指针修饰符和Runtime，来处理循环引入问题。</p>\n</li>\n</ul>\n<h4 id=\"1-指针修饰符\"><a href=\"#1-指针修饰符\" class=\"headerlink\" title=\"1.指针修饰符\"></a>1.指针修饰符</h4><ul>\n<li><p><code>__strong</code>指针修饰符</p>\n<p>凡是用<code>__strong</code>修饰的指针，在超出其作用域时，编译器会为我们插入一次<code>release</code>或<code>autorelease</code>的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">等价于：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MRC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"type\">id</span> arr = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    [arr autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>而在指针赋值时，编译器会自动为我们插入一次<code>retain</code>的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj1 = obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">等价于：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MRC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"type\">id</span> obj1 = [obj <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    [obj1 release];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以正是因为使用<code>__strong</code>指针修饰符，编译器才会在合适的地方帮我们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用，而ARC下所有指针默认都是用<code>__strong</code>修饰的。</p>\n<ul>\n<li><code>__weak</code>指针修饰符</li>\n</ul>\n<p>看起来有了<code>strong</code>,编译器就可以很好的管理内存了，但是很重要的一点是<code>__strong</code>无法解决引用计数式内存管理必然会导致的“循环引入”问题。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// INEMan.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">INEWoman</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEMan</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> INEWoman *_woman; <span class=\"comment\">// 强引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setWoman:(INEWoman *)woman;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// INEMan.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEMan.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEMan</span> </span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setWoman:(INEWoman *)woman &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    _woman = woman;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// INEWoman.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@class</span> <span class=\"title\">INEMan</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEWoman</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> INEMan *_man; <span class=\"comment\">// 强引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setMan:(INEMan *)man;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// INEWoman.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEWoman.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEWoman</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setMan:(INEMan *)man &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    _man = man;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ViewController.m</span></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"meta\">super viewDidLoad</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    INEMan *man = [[INEMan alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    INEWoman *woman = [[INEWoman alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [<span class=\"meta\">man setWoman:woman</span>];</span><br><span class=\"line\">    [<span class=\"meta\">woman setMan:man</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 控制台打印：无</span></span><br></pre></td></tr></table></figure>\n\n<p><code>viewDidLoad</code>执行完，<code>Man</code>对象和<code>Woman</code>对象的<code>dealloc</code>方法都没走，也就是说它们俩都没销毁，这就是因为它们俩形成了循环引用，导致了内存泄漏。</p>\n<p>但是只要我们把循环引用中的一个强指针的换成弱指针，就可以解决问题。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEMan</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">     __<span class=\"keyword\">weak</span> INEWoman *_woman; <span class=\"comment\">// 弱引用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">或者：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEWoman</span> : <span class=\"title\">NSObject</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> INEMan *_man; <span class=\"comment\">// 强引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么能解决呢？这就要来看看**<code>__weak</code>指针的实现原理：**</p>\n<ul>\n<li><p><strong><code>__weak</code>指针是专门用来解决循环引用问题的，它不是通过引用计数来管理对象的，而是通过弱引用表。</strong>具体地说：</p>\n<p><strong>1.当我们把一个强指针赋值给一个弱指针时，编译器不会怒自动帮我们插入<code>retain</code>使对象的引用计数+1，而是把这个弱指针和对象的内存地址绑在一起，通过两次散列算法找到弱引用计数表里的弱指针数组，然后把这个弱指针存到弱指针数组里。这样我们通过这些弱指针既可以正常使用该对象，又无需顾虑是不是要在什么时候把对象的引用计数-1，以免对象的引用计数&gt;0而无法销毁，因为他没有参数引用计数那一套。</strong></p>\n<p><strong>2.当对象销毁时会走dealloc方法，又会通过两次散列算法找到弱引用计数表里的数组，把指向该对象的弱指针都置为<code>nil</code>并移除。</strong></p>\n</li>\n</ul>\n<h4 id=\"2-属性修饰符\"><a href=\"#2-属性修饰符\" class=\"headerlink\" title=\"2.属性修饰符\"></a>2.属性修饰符</h4><p>属性修饰符一共有三对儿：<strong>原子性、读写权限和内存管理语意</strong>，属性修饰符主要影响就是编译器为成员变量生成的<code>setter</code>、<code>getter</code>方法上。（这里除了讲解和内存相关的知识外，其他的也回顾一下）</p>\n<blockquote>\n<p>原子性：<code>atomic</code>（默认）、<code>nonatomic</code></p>\n</blockquote>\n<ul>\n<li><p><code>atomic</code>：默认为<code>atomic</code>，使用<code>atomic</code>修饰的属性，编译器为该属性生成的<code>setter</code>、<code>getter</code>方法内部是加了锁的。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (atomic, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableArray</span> *array;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setArray:(<span class=\"built_in\">NSMutableArray</span> *)array &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    _array = array;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableArray</span> *)array &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _array;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>但这仅仅是保证我们调用<code>setter</code>、<code>getter</code>方法访问属性这一步是线程安全的，它没发保证我们使用属性的线程是安全的，比如我们调用<code>[self.array addObject:xxx]</code>,<code>self.array</code>访问属性这一步是线程安全的，但<code>addObject:</code>使用属性这一步是线程不安全的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程1</span><br><span class=\"line\">[self.array addObject:@&quot;11&quot;];</span><br><span class=\"line\">// 线程2</span><br><span class=\"line\">[self.array addObject:@&quot;12&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">等价于</span><br><span class=\"line\"></span><br><span class=\"line\">// 线程1</span><br><span class=\"line\">[[self array] addObject:@&quot;11&quot;];</span><br><span class=\"line\">// 线程2</span><br><span class=\"line\">[[self array] addObject:@&quot;12&quot;];</span><br></pre></td></tr></table></figure>\n\n<p>所以为了保证使用属性的线程安全，我们还得在需要的地方自己加锁，这样一来使用使用<code>atomic</code>修饰属性就多此一举了，而且<code>stter</code>、<code>getter</code>方法的调用通常都是很频繁的，内部加锁的话会增加内存的开销，耗费性能。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">[<span class=\"built_in\">self</span>.<span class=\"keyword\">array</span> addObject:@<span class=\"string\">&quot;11&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">[<span class=\"built_in\">self</span>.<span class=\"keyword\">array</span> addObject:@<span class=\"string\">&quot;12&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>nonatomic</code>：因此我们在实际开发中总是使用<code>nonatomic</code>。</li>\n</ul>\n<blockquote>\n<p>读写权限：<code>readwrite</code>(默认)、<code>readonly</code></p>\n</blockquote>\n<ul>\n<li><code>readwrite</code>：默认为<code>readwrite</code>，代表该属性可读可写，编译器会为该属性生成<code>setter</code></li>\n</ul>\n<p><code>getter</code>方法的声明与实现。</p>\n<ul>\n<li><code>readonly</code>：代表该属性只能读取不能写入，编译器会为该属性生成<code>setter</code>、<code>getter</code>方法的声明与<code>getter</code>方法的实现。</li>\n</ul>\n<blockquote>\n<p>内存管理语意：</p>\n<ul>\n<li>MRC下有：<code>assign</code>、<code>retain</code>、<code>copy</code>。</li>\n<li>ARC下新增了：<code>strong</code>、<code>weak</code>、<code>unsafe_unretained</code>。</li>\n</ul>\n</blockquote>\n<ul>\n<li><code>assign</code>：<code>assign</code>一般来修饰基本数据类型。使用<code>assign</code>修饰属性，编译器为属性生成的<code>setter</code>方法内部只是简单的赋值操作。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setAge:(<span class=\"type\">int</span>)age &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 简单的赋值操作</span></span><br><span class=\"line\">    _age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>retain</code>：<code>retain</code>一般用来修饰对象类型。使用<code>retain</code>修饰的属性，编译器为该属性生成的<code>setter</code>方法内部会调用一下<code>retain</code>方法，是对象的引用计数+1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setDog:(Dog *)dog &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (_dog != dog) &#123; // 新旧对象不一样时</span><br><span class=\"line\">        </span><br><span class=\"line\">        [_dog release]; // 释放旧对象</span><br><span class=\"line\">        _dog = [dog retain]; // 持有新对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>copy</code>：<code>copy</code>一般用来修饰不可变属性和block。使用<code>copy</code>修饰的属性，编译器为该属性生成的<code>setter</code>方法内部会调用一下<code>copy</code>方法，生成一个新的对象，新对象的引用计数为1，而旧对象的引用计数不变。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>strong</code>：默认为<code>strong</code>，大多数情况下和<code>retain</code>的效果是一样的，修饰block和<code>copy</code>的效果是一样的，<code>strong</code>一般用来修饰对象类型。</p>\n</li>\n<li><p><code>weak</code>：<code>weak</code>一般用来修饰代理对象和<code>NSTimer</code>，以免造成循环引入；还有用来修饰xib或sb拖出来的控件，因为这些界面已经被添加到界面上了，被subviews这个属性持有了，不必再用变量持有。</p>\n</li>\n<li><p><code>unsafe_unretained</code>：和<code>assign</code>效果是一样的，如果用他们来修饰对象类型，和<code>weak</code>功能类似，但<code>weak</code>修饰的属性会在对象销毁时会被置为<code>nil</code>，比较安全，而<code>unsafe_unretained</code>和<code>assign</code>修饰的属性则不会，所以容易出现野指针。</p>\n</li>\n</ul>"},{"title":"内存管理二","date":"2021-07-05T09:32:38.000Z","_content":"\n> 一、定时器的循环引入\n>\n> 二、copy、mutableCopy\n>\n> 三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}\n>\n> 四、其他注意事项\n\n<!--more-->\n\n### 一、定时器的循环引入\n\n我们以`NSTimer`举例，`CADisplayLink`遇到同样的问题，解决方案也一样。\n\n#### 1.`NSTimer`的循环引入\n\n使用`NSTimer`，写法通常如下：\n\n```objectivec\n#import \"ViewController.h\"\n#import \"ViewController1.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    \n    ViewController1 *vc = [[ViewController1 alloc] init];\n    [self.navigationController pushViewController:vc animated:YES];\n}\n\n@end\n```\n\n```objectivec\n#import \"ViewController1.h\"\n\n@interface ViewController1 ()\n\n@property (nonatomic, strong) NSTimer *timer;\n\n@end\n\n@implementation ViewController1\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 创建timer\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(test) userInfo:nil repeats:YES];\n}\n\n- (void)test {\n    \n    NSLog(@\"11\");\n}\n\n- (void)dealloc {\n    \n    NSLog(@\"%s\", __func__);\n    \n    // 退出界面时，使timer失效从而销毁\n    [self.timer invalidate];\n}\n\n@end\n```\n\n运行代码，点击`ViewController`进入`ViewController1`，此时`timer`跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回`ViewController`，正常情况下`ViewController1`应该会销毁，并触发`dealloc`方法，`timer`也跟着失效并且销毁。但实际情况却是`ViewController1`没有销毁，也没有触发`dealloc`方法，`timer`还一直跑着，这是因为`timer`和`ViewController1`形成了循环引用，导致内存泄漏。\n\n查看`timer`的创建方法，可以知道：**`timer`会强引用`target`，**也就是说`timer`确实强引用着`ViewController1`。\n\n![creatTimer](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png)\n\n而`ViewController`又强引用着`timer`。\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png)\n\n那怎么打破`NSTimer`的循环引用呢？我们知道`__weak`是专门用来打破循环引用的，那它是不是也能打破`NSTimer`的循环引用？\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 尝试用__weak打破NSTimer的循环引用\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(test) userInfo:nil repeats:YES];\n}\n```\n\n运行，发现没有效果，那为什么`__weak`不能打破`NSTimer`的循环引用？毫无疑问`__weak`的确是把`self`搞成了弱指针，但因为`NSTimer`内部有一个强指针类型的`target`变量\n\n```objectivec\n@property (nonatomic, strong) id target;\n```\n\n来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用`target`，所以用`__weak`不能打破`NSTimer`的循环引用。\n\n那再试试另一条引用线吧，让`ViewController1`弱引用`timer`。\n\n```objectivec\n@interface ViewController1 ()\n\n// 尝试用weak修饰timer来打破NSTimer的循环引用\n@property (nonatomic, weak) NSTimer *timer;\n\n@end\n```\n\n运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对`NSTimer`的说明，可以知道：**把`timer`添加到RunLoop之后，RunLoop会强引用`timer`，并且建议我们不必自己强引用`timer`，而解除RunLoop对`timer`强引用的唯一方式就是调用`timer`的`invalidate`方法使`timer`失效从而销毁。**\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png)\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png)\n\n也就是说，实际的引用关系如下：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png)\n\n所以我们**使用`weak`修饰`timer`是正确的，**但这还是不能打破`NSTimer`的循环引用——更准确地说，这可以解决`NSTimer`的循环引用，但还是没有解决`NSTimer`内存泄漏的问题。因为`[self.timer invalidate]`的调用——即`timer`的销毁——最好就是发生在`ViewController1`销毁时，而`ViewController1`要想销毁就必须得`timer`先销毁，还是内存泄漏。\n\n倒腾来倒腾去，还是得**从`timer`强引用`target`这条引用线下手，把它搞成弱引用，`__weak`不起作用，那我们想想别的方案呗。**\n\n#### 2、打破`NSTimer`的循环引用\n\n- 方案一：使用block的方式创建`timer`\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        [weakSelf test];\n    }];\n}\n```\n\n为什么能解决呢？因为此时`timer`是强引用block的，而`__weak`可以打破block的循环引用，所以block是弱引用`self`的，所以最终的效果就类似于`timer`弱引用`self`。解决是能解决，但用这种方式创建`timer`要iOS10.0以后才能使用。\n\n- 方案二：创建一个中间对象——代理\n\n  我们可以把方案一的思路自己实现一下嘛，**即创建一个中间对象（方案一的中间对象就是block嘛），把这个中间对象作为`timer`的`target`参数传进去，让`timer`强引用这个中间对象，而让这个中间对象弱引用`ViewController1`，这样`ViewController1`就能正常释放，`NSTimer`就能正常调用失效方法，RunLoop就能正常解除对`NSTimer`的强引用，`NSTimer`就能正常解除对中间对象的强引用，内存泄漏就解决了。**当然**由于中间对象没有`target`——即`ViewController1`——的方法，所以我们还要做一步消息转发。**\n\n```objectivec\n-----------INETimerProxy.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface INETimerProxy : NSObject\n\n+ (instancetype)proxyWithTarget:(id)target;\n\n@end\n\n\n-----------INETimerProxy.m-----------\n\n#import \"INETimerProxy.h\"\n\n@interface INETimerProxy ()\n\n/// 弱引用target所指向的对象\n@property (nonatomic, weak) id target;\n\n@end\n\n@implementation INETimerProxy\n\n+ (instancetype)proxyWithTarget:(id)target {\n    \n    INETimerProxy *proxy = [[INETimerProxy alloc] init];\n    proxy.target = target;\n    return proxy;\n}\n\n// 直接消息转发\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    \n    return self.target;\n}\n\n@end\n```\n\n```objectivec\n-----------ViewController1.m-----------\n\n#import \"INETimerProxy.h\"\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:[INETimerProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];\n}\n```\n\n为了提高消息转发效率，我们可以让代理直接继承自`NSProxy`，而不是`NSObject`。**`NSProxy`是专门用来做消息转发的，继承自`NSObject`的类调用方法时会走方法查找 --> 动态方法解析 --> 直接消息转发、完整消息转发这套流程，而继承自`NSProxy`的类调用方法时只会走方法查找 --> 完整消息转发这两个流程，消息转发效率更高，所以以后但凡要做消息转发就直接继承自`NSProxy`好了，而不是`NSObject`。**\n\n```objectivec\n-----------INETimerProxy.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface INETimerProxy : NSProxy\n\n+ (instancetype)proxyWithTarget:(id)target;\n\n@end\n\n\n-----------INETimerProxy.m-----------\n\n#import \"INETimerProxy.h\"\n\n@interface INETimerProxy ()\n\n/// 弱引用target所指向的对象\n@property (nonatomic, weak) id target;\n\n@end\n\n@implementation INETimerProxy\n\n+ (instancetype)proxyWithTarget:(id)target {\n    \n    // NSProxy类是没有init方法的，alloc后就可以直接使用\n    INETimerProxy *proxy = [INETimerProxy alloc];\n    proxy.target = target;\n    return proxy;\n}\n\n// 完整消息转发\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {\n    \n    return [self.target methodSignatureForSelector:sel];\n}\n\n- (void)forwardInvocation:(NSInvocation *)invocation {\n    \n    [invocation invokeWithTarget:self.target];\n}\n\n@end\n```\n\n### 二、`copy`、`mutableCopy`\n\n#### 1、深拷贝与浅拷贝\n\n> - **深拷贝，是指内容拷贝，会产生新的对象，新对象的引用计数为1；浅拷贝，是指指针拷贝，不会产生新的对象，旧对象的引用计数加1，浅拷贝其实就是`retain`，深拷贝的话新对象和旧对象互不影响，浅拷贝的话改变一个另一个也跟着变了。**\n> - **只有不可变对象的不可变拷贝是浅拷贝，其它的都是深拷贝。**\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    NSString *str1 = @\"11\";\n    NSString *str2 = [str1 copy]; // 不可变对象的不可变拷贝 --> 浅拷贝\n    NSMutableString *str3 = [str1 mutableCopy]; // 深拷贝\n    NSLog(@\"%p %p %p\", str1, str2, str3);\n    \n    NSMutableString *str4 = [@\"11\" mutableCopy];\n    NSString *str5 = [str4 copy]; // 深拷贝\n    NSMutableString *str6 = [str4 mutableCopy]; // 深拷贝\n    NSLog(@\"%p %p %p\", str4, str5, str6);\n}\n\n\n控制台打印：\n0x1025260b0 0x1025260b0 0x600003bc0ab0\n0x600003b992c0 0xc91f17b5d8b748d0 0x600003b99890\n```\n\n#### 2、不可变属性最好用`copy`修饰，而可变属性坚决不能用`copy`修饰、只能用`strong`、`retain`修饰\n\n> `copy`拷贝出来的东西是不可变对象，是不能修改的；\n>\n> `mutableCopy`拷贝出来的东西是可变对象，是能修改的。\n\n\n\n- **不可变对象最好用`copy`修饰**\n\n  不可变对象最好用`copy`修饰，因为用`strong`、`retain`修饰的话，`setter`方法内部仅仅是`retain`，那当我们把一个可变对象赋值给这个不可变属性时，不可变属性仅仅是指针指向了可变对象，修改可变对象的值，也就是不可变属性指向的对象值发生了改变，这不是我们所希望的结果，我们直观的感觉应该是“不可变属性指向的对象不应该随着别人的改变而改变”。\n\n```objectivec\n@interface ViewController ()\n\n@property (nonatomic, strong) NSString *name;\n//@property (nonatomic, retain) NSString *name;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    // 可变对象\n    NSMutableString *mutableName = [@\"张三\" mutableCopy];\n    // 可变对象赋值给这个不可变属性\n    self.name = mutableName;\n    NSLog(@\"%@\", self.name); // 张三\n    \n    // 修改可变对象的值\n    [mutableName appendString:@\"丰\"];\n    NSLog(@\"%@\", self.name); // 张三丰，不可变属性的值也会跟着变化，这不是我们希望看到的\n}\n\n@end\n```\n\n而用`copy`修饰的话，`setter`方法内部就是`copy`，那不管你外界传给它一个可变还是不可变对象，该属性最终都是深拷贝出一份不可变的，这样外界就无法影响这个属性的值，除非我们主动修改，符合我们的预期。\n\n```objectivec\n@interface ViewController ()\n\n@property (nonatomic, copy) NSString *name;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    // 可变对象\n    NSMutableString *mutableName = [@\"张三\" mutableCopy];\n    // 可变对象赋值给这个不可变属性\n    self.name = mutableName;\n    NSLog(@\"%@\", self.name); // 张三\n    \n    // 修改可变对象的值\n    [mutableName appendString:@\"丰\"];\n    NSLog(@\"%@\", self.name); // 张三，外界无法影响这个属性的值\n    \n    self.name = @\"张三丰\";\n    NSLog(@\"%@\", self.name); // 张三丰，我们主动修改属性的值，符合我们的预期\n}\n\n@end\n```\n\n- **而可变属性坚决不能用`copy`修饰、只能用`strong`或`retain`修饰**\n\n  可变属性坚决不能用`copy`修饰，只能用`strong`、`retain`修饰，道理和上面一样，`copy`修饰的属性最终在`setter`方法里`copy`出一份不可变的，如果你非要用它来修饰可变属性，那从外在看来好像可以改变这个属性，结果一修改就崩溃了，因为找不到方法。\n\n  ```objectivec\n  @interface ViewController ()\n  \n  @property (nonatomic, copy) NSMutableString *name;\n  \n  @end\n  \n  @implementation ViewController\n  \n  - (void)viewDidLoad {\n      [super viewDidLoad];\n    \n      self.name = [@\"张三\" mutableCopy];\n      [self.name appendString:@\"丰\"]; // 一修改，就崩溃，因为NSString根本没有appendString:方法\n  }\n  \n  @end\n  ```\n\n### 三、创建大量`autorelease`对象时，最好自己创建一个`@autoreleasepool {...}`\n\n只要不是用`alloc`、`new`、`copy`、`mutableCopy`方法创建的对象，而是用类方法创建的对象，方法内部都调用了`autorelease`，都是`autorelease`对象，例如：\n\n```objectivec\nNSString *str = [NSString string];\nNSArray *arr = [NSArray array];\nNSDictionary *dict = [NSDictionary dictionary];\nUIImage *image = [UIImage imageNamed:@\"11\"];\n```\n\n因为类方法的内部实现大概如下：\n\n```kotlin\n- (id)object {\n    \n    id obj = [[NSObject alloc] init];\n    [obj autorelease];\n    \n    return obj;\n}\n```\n\n而`alloc`、`new`、`copy`、`mutableCopy`方法的内部实现大概如下：**所以在创建大量`autorelease`对象时，最好自己创建一个`@autoreleasepool {...}`。**\n\n```objectivec\n- (id)allocObject {\n    \n    id obj = [[NSObject alloc] init];\n    \n    return obj;\n}\n```\n\n**所以在创建大量`autorelease`对象时，最好自己创建一个`@autoreleasepool {...}`。因为如果主线程RunLoop的某次循环一直忙着处理事情，线程没有休眠或者退出，那本次循环的`autoreleasepool`就迟迟无法销毁，这就会导致这次循环里的`autorelease`对象迟迟无法释放掉，因此就很有可能会导致内存的使用峰值过高，从而导致内存溢出。而自己创建`@autoreleasepool {...}`后，每一次`for`循环都会出一次`@autoreleasepool {...}`**的作用域而销毁一波**`autorelease`对象，这就可以降低内存的峰值。**\n\n```objectivec\nfor (int i = 0; i < 100000; i ++) {\n    \n    @autoreleasepool {\n        \n        NSString *string = [NSString stringWithFormat:@\"%d\", i];\n        NSLog(@\"%@\", string);\n    }\n}\n```\n\n`autoreleasepool`的实现原理简述：`autoreleasepool`其实也是一个对象，它在创建后，内部会有一堆`AutoReleasePoolPage`对象，这一堆`AutoReleasePoolPage`对象是通过双向链表组织起来的——即`AutoReleasePoolPage`对象1的`child`属性指向`AutoReleasePoolPage`对象2，`AutoReleasePoolPage`对象2的`child`属性指向`AutoReleasePoolPage`对象3，而`AutoReleasePoolPage`对象3的`parent`属性指向`AutoReleasePoolPage`对象2，`AutoReleasePoolPage`对象2的`parent`属性指向`AutoReleasePoolPage`对象1，这样通过`child`属性和`parent`两个属性关联起来的双向数据结构就是双向链表，而每一个`AutoReleasePoolPage`对象内部都有4040个字节用来存放`autorelease`对象的内存地址，如果项目里一个`AutoReleasePoolPage`对象存不下所有的`autorelease`对象的内存地址，那`autoreleasepool`在创建的时候就会创建两个`AutoReleasePoolPage`对象，依次类推，然后当`autoreleasepool`销毁时就会去`AutoReleasePoolPage`对象里找到这些对象的地址将它们的引用计数都做一次减1操作。\n\n### 四、其它一些注意\n\n注意代理不要出现循环引用，block不要出现循环引用，KVO和通知要在`dealloc`的时候释放等。\n\n### 五、知识扩展-GC和引用计数对比\n\nAndroid 手机通常使用 Java 来开发，而 Java 是使用[垃圾回收](https://so.csdn.net/so/search?q=垃圾回收&spm=1001.2101.3001.7020)这种内存管理方式。垃圾回收(Garbage Collection，简称 GC)这种内存管理机制最早由图灵奖获得者 John McCarthy 在 1959 年提出，垃圾回收的理论主要基于一个事实：大部分的对象的生命期都很短。所以，GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到 Old 区。(其实还有一个 Perm 区，但是内存回收算法通常不涉及这个区域)\n\n当 GC 工作时，GC 认为当前的一些对象是有效的，这些对象包括：全局变量，栈里面的变量等，然后 GC 从这些变量出发，去标记这些变量「可达」的其它变量，这个标记是一个递归的过程，最后就像从树根的内存对象开始，把所有的树枝和树叶都记成可达的了。那除了这些「可达」的变量，别的变量就都需要被回收了。\n\n听起来很牛逼对不对？那为什么苹果不用呢？实际上苹果在 OS X 10.5 的时候还真用了，不过在 10.7 的时候把 GC 换成了 ARC。那么，GC 有什么问题让苹果不能忍，这就是：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所以说，你知道 Android 手机有时候为什么会卡吧，GC 就相当于春运的最后一天返城高峰。当所有的对象都需要一起回收时，那种体验肯定是当时还在世的乔布斯忍受不了的。\n\n- **ARC 相对于 GC 的优点：**\n\n  1.ARC 工作在编译期，在运行时没有额外开销。\n\n  2.ARC 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 GC 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。\n\n- **ARC 相对于 GC 的缺点：**\n\n  1.GC 真的是太简单了，基本上完全不用处理内存管理问题，而 ARC 还是需要处理类似循环引用这种内存管理问题。\n\n  2.GC 一类的语言相对来说学习起来更简单。","source":"_posts/内存管理二.md","raw":"---\ntitle: 内存管理二\ndate: 2021-07-05 17:32:38\ntags: 内存管理系列\n---\n\n> 一、定时器的循环引入\n>\n> 二、copy、mutableCopy\n>\n> 三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}\n>\n> 四、其他注意事项\n\n<!--more-->\n\n### 一、定时器的循环引入\n\n我们以`NSTimer`举例，`CADisplayLink`遇到同样的问题，解决方案也一样。\n\n#### 1.`NSTimer`的循环引入\n\n使用`NSTimer`，写法通常如下：\n\n```objectivec\n#import \"ViewController.h\"\n#import \"ViewController1.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    \n    ViewController1 *vc = [[ViewController1 alloc] init];\n    [self.navigationController pushViewController:vc animated:YES];\n}\n\n@end\n```\n\n```objectivec\n#import \"ViewController1.h\"\n\n@interface ViewController1 ()\n\n@property (nonatomic, strong) NSTimer *timer;\n\n@end\n\n@implementation ViewController1\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 创建timer\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(test) userInfo:nil repeats:YES];\n}\n\n- (void)test {\n    \n    NSLog(@\"11\");\n}\n\n- (void)dealloc {\n    \n    NSLog(@\"%s\", __func__);\n    \n    // 退出界面时，使timer失效从而销毁\n    [self.timer invalidate];\n}\n\n@end\n```\n\n运行代码，点击`ViewController`进入`ViewController1`，此时`timer`跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回`ViewController`，正常情况下`ViewController1`应该会销毁，并触发`dealloc`方法，`timer`也跟着失效并且销毁。但实际情况却是`ViewController1`没有销毁，也没有触发`dealloc`方法，`timer`还一直跑着，这是因为`timer`和`ViewController1`形成了循环引用，导致内存泄漏。\n\n查看`timer`的创建方法，可以知道：**`timer`会强引用`target`，**也就是说`timer`确实强引用着`ViewController1`。\n\n![creatTimer](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png)\n\n而`ViewController`又强引用着`timer`。\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png)\n\n那怎么打破`NSTimer`的循环引用呢？我们知道`__weak`是专门用来打破循环引用的，那它是不是也能打破`NSTimer`的循环引用？\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 尝试用__weak打破NSTimer的循环引用\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(test) userInfo:nil repeats:YES];\n}\n```\n\n运行，发现没有效果，那为什么`__weak`不能打破`NSTimer`的循环引用？毫无疑问`__weak`的确是把`self`搞成了弱指针，但因为`NSTimer`内部有一个强指针类型的`target`变量\n\n```objectivec\n@property (nonatomic, strong) id target;\n```\n\n来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用`target`，所以用`__weak`不能打破`NSTimer`的循环引用。\n\n那再试试另一条引用线吧，让`ViewController1`弱引用`timer`。\n\n```objectivec\n@interface ViewController1 ()\n\n// 尝试用weak修饰timer来打破NSTimer的循环引用\n@property (nonatomic, weak) NSTimer *timer;\n\n@end\n```\n\n运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对`NSTimer`的说明，可以知道：**把`timer`添加到RunLoop之后，RunLoop会强引用`timer`，并且建议我们不必自己强引用`timer`，而解除RunLoop对`timer`强引用的唯一方式就是调用`timer`的`invalidate`方法使`timer`失效从而销毁。**\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png)\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png)\n\n也就是说，实际的引用关系如下：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png)\n\n所以我们**使用`weak`修饰`timer`是正确的，**但这还是不能打破`NSTimer`的循环引用——更准确地说，这可以解决`NSTimer`的循环引用，但还是没有解决`NSTimer`内存泄漏的问题。因为`[self.timer invalidate]`的调用——即`timer`的销毁——最好就是发生在`ViewController1`销毁时，而`ViewController1`要想销毁就必须得`timer`先销毁，还是内存泄漏。\n\n倒腾来倒腾去，还是得**从`timer`强引用`target`这条引用线下手，把它搞成弱引用，`__weak`不起作用，那我们想想别的方案呗。**\n\n#### 2、打破`NSTimer`的循环引用\n\n- 方案一：使用block的方式创建`timer`\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        [weakSelf test];\n    }];\n}\n```\n\n为什么能解决呢？因为此时`timer`是强引用block的，而`__weak`可以打破block的循环引用，所以block是弱引用`self`的，所以最终的效果就类似于`timer`弱引用`self`。解决是能解决，但用这种方式创建`timer`要iOS10.0以后才能使用。\n\n- 方案二：创建一个中间对象——代理\n\n  我们可以把方案一的思路自己实现一下嘛，**即创建一个中间对象（方案一的中间对象就是block嘛），把这个中间对象作为`timer`的`target`参数传进去，让`timer`强引用这个中间对象，而让这个中间对象弱引用`ViewController1`，这样`ViewController1`就能正常释放，`NSTimer`就能正常调用失效方法，RunLoop就能正常解除对`NSTimer`的强引用，`NSTimer`就能正常解除对中间对象的强引用，内存泄漏就解决了。**当然**由于中间对象没有`target`——即`ViewController1`——的方法，所以我们还要做一步消息转发。**\n\n```objectivec\n-----------INETimerProxy.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface INETimerProxy : NSObject\n\n+ (instancetype)proxyWithTarget:(id)target;\n\n@end\n\n\n-----------INETimerProxy.m-----------\n\n#import \"INETimerProxy.h\"\n\n@interface INETimerProxy ()\n\n/// 弱引用target所指向的对象\n@property (nonatomic, weak) id target;\n\n@end\n\n@implementation INETimerProxy\n\n+ (instancetype)proxyWithTarget:(id)target {\n    \n    INETimerProxy *proxy = [[INETimerProxy alloc] init];\n    proxy.target = target;\n    return proxy;\n}\n\n// 直接消息转发\n- (id)forwardingTargetForSelector:(SEL)aSelector {\n    \n    return self.target;\n}\n\n@end\n```\n\n```objectivec\n-----------ViewController1.m-----------\n\n#import \"INETimerProxy.h\"\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:[INETimerProxy proxyWithTarget:self] selector:@selector(test) userInfo:nil repeats:YES];\n}\n```\n\n为了提高消息转发效率，我们可以让代理直接继承自`NSProxy`，而不是`NSObject`。**`NSProxy`是专门用来做消息转发的，继承自`NSObject`的类调用方法时会走方法查找 --> 动态方法解析 --> 直接消息转发、完整消息转发这套流程，而继承自`NSProxy`的类调用方法时只会走方法查找 --> 完整消息转发这两个流程，消息转发效率更高，所以以后但凡要做消息转发就直接继承自`NSProxy`好了，而不是`NSObject`。**\n\n```objectivec\n-----------INETimerProxy.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface INETimerProxy : NSProxy\n\n+ (instancetype)proxyWithTarget:(id)target;\n\n@end\n\n\n-----------INETimerProxy.m-----------\n\n#import \"INETimerProxy.h\"\n\n@interface INETimerProxy ()\n\n/// 弱引用target所指向的对象\n@property (nonatomic, weak) id target;\n\n@end\n\n@implementation INETimerProxy\n\n+ (instancetype)proxyWithTarget:(id)target {\n    \n    // NSProxy类是没有init方法的，alloc后就可以直接使用\n    INETimerProxy *proxy = [INETimerProxy alloc];\n    proxy.target = target;\n    return proxy;\n}\n\n// 完整消息转发\n- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel {\n    \n    return [self.target methodSignatureForSelector:sel];\n}\n\n- (void)forwardInvocation:(NSInvocation *)invocation {\n    \n    [invocation invokeWithTarget:self.target];\n}\n\n@end\n```\n\n### 二、`copy`、`mutableCopy`\n\n#### 1、深拷贝与浅拷贝\n\n> - **深拷贝，是指内容拷贝，会产生新的对象，新对象的引用计数为1；浅拷贝，是指指针拷贝，不会产生新的对象，旧对象的引用计数加1，浅拷贝其实就是`retain`，深拷贝的话新对象和旧对象互不影响，浅拷贝的话改变一个另一个也跟着变了。**\n> - **只有不可变对象的不可变拷贝是浅拷贝，其它的都是深拷贝。**\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    NSString *str1 = @\"11\";\n    NSString *str2 = [str1 copy]; // 不可变对象的不可变拷贝 --> 浅拷贝\n    NSMutableString *str3 = [str1 mutableCopy]; // 深拷贝\n    NSLog(@\"%p %p %p\", str1, str2, str3);\n    \n    NSMutableString *str4 = [@\"11\" mutableCopy];\n    NSString *str5 = [str4 copy]; // 深拷贝\n    NSMutableString *str6 = [str4 mutableCopy]; // 深拷贝\n    NSLog(@\"%p %p %p\", str4, str5, str6);\n}\n\n\n控制台打印：\n0x1025260b0 0x1025260b0 0x600003bc0ab0\n0x600003b992c0 0xc91f17b5d8b748d0 0x600003b99890\n```\n\n#### 2、不可变属性最好用`copy`修饰，而可变属性坚决不能用`copy`修饰、只能用`strong`、`retain`修饰\n\n> `copy`拷贝出来的东西是不可变对象，是不能修改的；\n>\n> `mutableCopy`拷贝出来的东西是可变对象，是能修改的。\n\n\n\n- **不可变对象最好用`copy`修饰**\n\n  不可变对象最好用`copy`修饰，因为用`strong`、`retain`修饰的话，`setter`方法内部仅仅是`retain`，那当我们把一个可变对象赋值给这个不可变属性时，不可变属性仅仅是指针指向了可变对象，修改可变对象的值，也就是不可变属性指向的对象值发生了改变，这不是我们所希望的结果，我们直观的感觉应该是“不可变属性指向的对象不应该随着别人的改变而改变”。\n\n```objectivec\n@interface ViewController ()\n\n@property (nonatomic, strong) NSString *name;\n//@property (nonatomic, retain) NSString *name;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    // 可变对象\n    NSMutableString *mutableName = [@\"张三\" mutableCopy];\n    // 可变对象赋值给这个不可变属性\n    self.name = mutableName;\n    NSLog(@\"%@\", self.name); // 张三\n    \n    // 修改可变对象的值\n    [mutableName appendString:@\"丰\"];\n    NSLog(@\"%@\", self.name); // 张三丰，不可变属性的值也会跟着变化，这不是我们希望看到的\n}\n\n@end\n```\n\n而用`copy`修饰的话，`setter`方法内部就是`copy`，那不管你外界传给它一个可变还是不可变对象，该属性最终都是深拷贝出一份不可变的，这样外界就无法影响这个属性的值，除非我们主动修改，符合我们的预期。\n\n```objectivec\n@interface ViewController ()\n\n@property (nonatomic, copy) NSString *name;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    // 可变对象\n    NSMutableString *mutableName = [@\"张三\" mutableCopy];\n    // 可变对象赋值给这个不可变属性\n    self.name = mutableName;\n    NSLog(@\"%@\", self.name); // 张三\n    \n    // 修改可变对象的值\n    [mutableName appendString:@\"丰\"];\n    NSLog(@\"%@\", self.name); // 张三，外界无法影响这个属性的值\n    \n    self.name = @\"张三丰\";\n    NSLog(@\"%@\", self.name); // 张三丰，我们主动修改属性的值，符合我们的预期\n}\n\n@end\n```\n\n- **而可变属性坚决不能用`copy`修饰、只能用`strong`或`retain`修饰**\n\n  可变属性坚决不能用`copy`修饰，只能用`strong`、`retain`修饰，道理和上面一样，`copy`修饰的属性最终在`setter`方法里`copy`出一份不可变的，如果你非要用它来修饰可变属性，那从外在看来好像可以改变这个属性，结果一修改就崩溃了，因为找不到方法。\n\n  ```objectivec\n  @interface ViewController ()\n  \n  @property (nonatomic, copy) NSMutableString *name;\n  \n  @end\n  \n  @implementation ViewController\n  \n  - (void)viewDidLoad {\n      [super viewDidLoad];\n    \n      self.name = [@\"张三\" mutableCopy];\n      [self.name appendString:@\"丰\"]; // 一修改，就崩溃，因为NSString根本没有appendString:方法\n  }\n  \n  @end\n  ```\n\n### 三、创建大量`autorelease`对象时，最好自己创建一个`@autoreleasepool {...}`\n\n只要不是用`alloc`、`new`、`copy`、`mutableCopy`方法创建的对象，而是用类方法创建的对象，方法内部都调用了`autorelease`，都是`autorelease`对象，例如：\n\n```objectivec\nNSString *str = [NSString string];\nNSArray *arr = [NSArray array];\nNSDictionary *dict = [NSDictionary dictionary];\nUIImage *image = [UIImage imageNamed:@\"11\"];\n```\n\n因为类方法的内部实现大概如下：\n\n```kotlin\n- (id)object {\n    \n    id obj = [[NSObject alloc] init];\n    [obj autorelease];\n    \n    return obj;\n}\n```\n\n而`alloc`、`new`、`copy`、`mutableCopy`方法的内部实现大概如下：**所以在创建大量`autorelease`对象时，最好自己创建一个`@autoreleasepool {...}`。**\n\n```objectivec\n- (id)allocObject {\n    \n    id obj = [[NSObject alloc] init];\n    \n    return obj;\n}\n```\n\n**所以在创建大量`autorelease`对象时，最好自己创建一个`@autoreleasepool {...}`。因为如果主线程RunLoop的某次循环一直忙着处理事情，线程没有休眠或者退出，那本次循环的`autoreleasepool`就迟迟无法销毁，这就会导致这次循环里的`autorelease`对象迟迟无法释放掉，因此就很有可能会导致内存的使用峰值过高，从而导致内存溢出。而自己创建`@autoreleasepool {...}`后，每一次`for`循环都会出一次`@autoreleasepool {...}`**的作用域而销毁一波**`autorelease`对象，这就可以降低内存的峰值。**\n\n```objectivec\nfor (int i = 0; i < 100000; i ++) {\n    \n    @autoreleasepool {\n        \n        NSString *string = [NSString stringWithFormat:@\"%d\", i];\n        NSLog(@\"%@\", string);\n    }\n}\n```\n\n`autoreleasepool`的实现原理简述：`autoreleasepool`其实也是一个对象，它在创建后，内部会有一堆`AutoReleasePoolPage`对象，这一堆`AutoReleasePoolPage`对象是通过双向链表组织起来的——即`AutoReleasePoolPage`对象1的`child`属性指向`AutoReleasePoolPage`对象2，`AutoReleasePoolPage`对象2的`child`属性指向`AutoReleasePoolPage`对象3，而`AutoReleasePoolPage`对象3的`parent`属性指向`AutoReleasePoolPage`对象2，`AutoReleasePoolPage`对象2的`parent`属性指向`AutoReleasePoolPage`对象1，这样通过`child`属性和`parent`两个属性关联起来的双向数据结构就是双向链表，而每一个`AutoReleasePoolPage`对象内部都有4040个字节用来存放`autorelease`对象的内存地址，如果项目里一个`AutoReleasePoolPage`对象存不下所有的`autorelease`对象的内存地址，那`autoreleasepool`在创建的时候就会创建两个`AutoReleasePoolPage`对象，依次类推，然后当`autoreleasepool`销毁时就会去`AutoReleasePoolPage`对象里找到这些对象的地址将它们的引用计数都做一次减1操作。\n\n### 四、其它一些注意\n\n注意代理不要出现循环引用，block不要出现循环引用，KVO和通知要在`dealloc`的时候释放等。\n\n### 五、知识扩展-GC和引用计数对比\n\nAndroid 手机通常使用 Java 来开发，而 Java 是使用[垃圾回收](https://so.csdn.net/so/search?q=垃圾回收&spm=1001.2101.3001.7020)这种内存管理方式。垃圾回收(Garbage Collection，简称 GC)这种内存管理机制最早由图灵奖获得者 John McCarthy 在 1959 年提出，垃圾回收的理论主要基于一个事实：大部分的对象的生命期都很短。所以，GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到 Old 区。(其实还有一个 Perm 区，但是内存回收算法通常不涉及这个区域)\n\n当 GC 工作时，GC 认为当前的一些对象是有效的，这些对象包括：全局变量，栈里面的变量等，然后 GC 从这些变量出发，去标记这些变量「可达」的其它变量，这个标记是一个递归的过程，最后就像从树根的内存对象开始，把所有的树枝和树叶都记成可达的了。那除了这些「可达」的变量，别的变量就都需要被回收了。\n\n听起来很牛逼对不对？那为什么苹果不用呢？实际上苹果在 OS X 10.5 的时候还真用了，不过在 10.7 的时候把 GC 换成了 ARC。那么，GC 有什么问题让苹果不能忍，这就是：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所以说，你知道 Android 手机有时候为什么会卡吧，GC 就相当于春运的最后一天返城高峰。当所有的对象都需要一起回收时，那种体验肯定是当时还在世的乔布斯忍受不了的。\n\n- **ARC 相对于 GC 的优点：**\n\n  1.ARC 工作在编译期，在运行时没有额外开销。\n\n  2.ARC 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 GC 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。\n\n- **ARC 相对于 GC 的缺点：**\n\n  1.GC 真的是太简单了，基本上完全不用处理内存管理问题，而 ARC 还是需要处理类似循环引用这种内存管理问题。\n\n  2.GC 一类的语言相对来说学习起来更简单。","slug":"内存管理二","published":1,"updated":"2022-07-17T03:05:00.277Z","_id":"cl582bsyi00007pfy2r7df1gg","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>一、定时器的循环引入</p>\n<p>二、copy、mutableCopy</p>\n<p>三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}</p>\n<p>四、其他注意事项</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3 id=\"一、定时器的循环引入\"><a href=\"#一、定时器的循环引入\" class=\"headerlink\" title=\"一、定时器的循环引入\"></a>一、定时器的循环引入</h3><p>我们以<code>NSTimer</code>举例，<code>CADisplayLink</code>遇到同样的问题，解决方案也一样。</p>\n<h4 id=\"1-NSTimer的循环引入\"><a href=\"#1-NSTimer的循环引入\" class=\"headerlink\" title=\"1.NSTimer的循环引入\"></a>1.<code>NSTimer</code>的循环引入</h4><p>使用<code>NSTimer</code>，写法通常如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController1.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ViewController1 *vc = [[ViewController1 alloc] init];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController pushViewController:vc animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController1.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController1</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController1</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建timer</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)test &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 退出界面时，使timer失效从而销毁</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.timer invalidate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行代码，点击<code>ViewController</code>进入<code>ViewController1</code>，此时<code>timer</code>跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回<code>ViewController</code>，正常情况下<code>ViewController1</code>应该会销毁，并触发<code>dealloc</code>方法，<code>timer</code>也跟着失效并且销毁。但实际情况却是<code>ViewController1</code>没有销毁，也没有触发<code>dealloc</code>方法，<code>timer</code>还一直跑着，这是因为<code>timer</code>和<code>ViewController1</code>形成了循环引用，导致内存泄漏。</p>\n<p>查看<code>timer</code>的创建方法，可以知道：**<code>timer</code>会强引用<code>target</code>，**也就是说<code>timer</code>确实强引用着<code>ViewController1</code>。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png\" alt=\"creatTimer\"></p>\n<p>而<code>ViewController</code>又强引用着<code>timer</code>。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png\" alt=\"img\"></p>\n<p>那怎么打破<code>NSTimer</code>的循环引用呢？我们知道<code>__weak</code>是专门用来打破循环引用的，那它是不是也能打破<code>NSTimer</code>的循环引用？</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 尝试用__weak打破NSTimer的循环引用</span></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:weakSelf selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行，发现没有效果，那为什么<code>__weak</code>不能打破<code>NSTimer</code>的循环引用？毫无疑问<code>__weak</code>的确是把<code>self</code>搞成了弱指针，但因为<code>NSTimer</code>内部有一个强指针类型的<code>target</code>变量</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"type\">id</span> target;</span><br></pre></td></tr></table></figure>\n\n<p>来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用<code>target</code>，所以用<code>__weak</code>不能打破<code>NSTimer</code>的循环引用。</p>\n<p>那再试试另一条引用线吧，让<code>ViewController1</code>弱引用<code>timer</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController1</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试用weak修饰timer来打破NSTimer的循环引用</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对<code>NSTimer</code>的说明，可以知道：<strong>把<code>timer</code>添加到RunLoop之后，RunLoop会强引用<code>timer</code>，并且建议我们不必自己强引用<code>timer</code>，而解除RunLoop对<code>timer</code>强引用的唯一方式就是调用<code>timer</code>的<code>invalidate</code>方法使<code>timer</code>失效从而销毁。</strong></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png\" alt=\"img\"></p>\n<p>也就是说，实际的引用关系如下：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png\" alt=\"img\"></p>\n<p>所以我们<strong>使用<code>weak</code>修饰<code>timer</code>是正确的，</strong>但这还是不能打破<code>NSTimer</code>的循环引用——更准确地说，这可以解决<code>NSTimer</code>的循环引用，但还是没有解决<code>NSTimer</code>内存泄漏的问题。因为<code>[self.timer invalidate]</code>的调用——即<code>timer</code>的销毁——最好就是发生在<code>ViewController1</code>销毁时，而<code>ViewController1</code>要想销毁就必须得<code>timer</code>先销毁，还是内存泄漏。</p>\n<p>倒腾来倒腾去，还是得<strong>从<code>timer</code>强引用<code>target</code>这条引用线下手，把它搞成弱引用，<code>__weak</code>不起作用，那我们想想别的方案呗。</strong></p>\n<h4 id=\"2、打破NSTimer的循环引用\"><a href=\"#2、打破NSTimer的循环引用\" class=\"headerlink\" title=\"2、打破NSTimer的循环引用\"></a>2、打破<code>NSTimer</code>的循环引用</h4><ul>\n<li>方案一：使用block的方式创建<code>timer</code></li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [weakSelf test];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么能解决呢？因为此时<code>timer</code>是强引用block的，而<code>__weak</code>可以打破block的循环引用，所以block是弱引用<code>self</code>的，所以最终的效果就类似于<code>timer</code>弱引用<code>self</code>。解决是能解决，但用这种方式创建<code>timer</code>要iOS10.0以后才能使用。</p>\n<ul>\n<li><p>方案二：创建一个中间对象——代理</p>\n<p>我们可以把方案一的思路自己实现一下嘛，<strong>即创建一个中间对象（方案一的中间对象就是block嘛），把这个中间对象作为<code>timer</code>的<code>target</code>参数传进去，让<code>timer</code>强引用这个中间对象，而让这个中间对象弱引用<code>ViewController1</code>，这样<code>ViewController1</code>就能正常释放，<code>NSTimer</code>就能正常调用失效方法，RunLoop就能正常解除对<code>NSTimer</code>的强引用，<code>NSTimer</code>就能正常解除对中间对象的强引用，内存泄漏就解决了。</strong>当然<strong>由于中间对象没有<code>target</code>——即<code>ViewController1</code>——的方法，所以我们还要做一步消息转发。</strong></p>\n</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INETimerProxy.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INETimerProxy</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INETimerProxy.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INETimerProxy.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INETimerProxy</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 弱引用target所指向的对象</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"type\">id</span> target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INETimerProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    INETimerProxy *proxy = [[INETimerProxy alloc] init];</span><br><span class=\"line\">    proxy.target = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接消息转发</span></span><br><span class=\"line\">- (<span class=\"type\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------ViewController1.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INETimerProxy.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:[INETimerProxy proxyWithTarget:<span class=\"keyword\">self</span>] selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了提高消息转发效率，我们可以让代理直接继承自<code>NSProxy</code>，而不是<code>NSObject</code>。**<code>NSProxy</code>是专门用来做消息转发的，继承自<code>NSObject</code>的类调用方法时会走方法查找 –&gt; 动态方法解析 –&gt; 直接消息转发、完整消息转发这套流程，而继承自<code>NSProxy</code>的类调用方法时只会走方法查找 –&gt; 完整消息转发这两个流程，消息转发效率更高，所以以后但凡要做消息转发就直接继承自<code>NSProxy</code>好了，而不是<code>NSObject</code>。**</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INETimerProxy.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INETimerProxy</span> : <span class=\"title\">NSProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INETimerProxy.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INETimerProxy.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INETimerProxy</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 弱引用target所指向的对象</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"type\">id</span> target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INETimerProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// NSProxy类是没有init方法的，alloc后就可以直接使用</span></span><br><span class=\"line\">    INETimerProxy *proxy = [INETimerProxy alloc];</span><br><span class=\"line\">    proxy.target = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 完整消息转发</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.target methodSignatureForSelector:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [invocation invokeWithTarget:<span class=\"keyword\">self</span>.target];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、copy、mutableCopy\"><a href=\"#二、copy、mutableCopy\" class=\"headerlink\" title=\"二、copy、mutableCopy\"></a>二、<code>copy</code>、<code>mutableCopy</code></h3><h4 id=\"1、深拷贝与浅拷贝\"><a href=\"#1、深拷贝与浅拷贝\" class=\"headerlink\" title=\"1、深拷贝与浅拷贝\"></a>1、深拷贝与浅拷贝</h4><blockquote>\n<ul>\n<li><strong>深拷贝，是指内容拷贝，会产生新的对象，新对象的引用计数为1；浅拷贝，是指指针拷贝，不会产生新的对象，旧对象的引用计数加1，浅拷贝其实就是<code>retain</code>，深拷贝的话新对象和旧对象互不影响，浅拷贝的话改变一个另一个也跟着变了。</strong></li>\n<li><strong>只有不可变对象的不可变拷贝是浅拷贝，其它的都是深拷贝。</strong></li>\n</ul>\n</blockquote>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str1 = <span class=\"string\">@&quot;11&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str2 = [str1 <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 不可变对象的不可变拷贝 --&gt; 浅拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *str3 = [str1 mutableCopy]; <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%p %p %p&quot;</span>, str1, str2, str3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *str4 = [<span class=\"string\">@&quot;11&quot;</span> mutableCopy];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str5 = [str4 <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *str6 = [str4 mutableCopy]; <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%p %p %p&quot;</span>, str4, str5, str6);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">控制台打印：</span><br><span class=\"line\"><span class=\"number\">0x1025260b0</span> <span class=\"number\">0x1025260b0</span> <span class=\"number\">0x600003bc0ab0</span></span><br><span class=\"line\"><span class=\"number\">0x600003b992c0</span> <span class=\"number\">0xc91f17b5d8b748d0</span> <span class=\"number\">0x600003b99890</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、不可变属性最好用copy修饰，而可变属性坚决不能用copy修饰、只能用strong、retain修饰\"><a href=\"#2、不可变属性最好用copy修饰，而可变属性坚决不能用copy修饰、只能用strong、retain修饰\" class=\"headerlink\" title=\"2、不可变属性最好用copy修饰，而可变属性坚决不能用copy修饰、只能用strong、retain修饰\"></a>2、不可变属性最好用<code>copy</code>修饰，而可变属性坚决不能用<code>copy</code>修饰、只能用<code>strong</code>、<code>retain</code>修饰</h4><blockquote>\n<p><code>copy</code>拷贝出来的东西是不可变对象，是不能修改的；</p>\n<p><code>mutableCopy</code>拷贝出来的东西是可变对象，是能修改的。</p>\n</blockquote>\n<ul>\n<li><p><strong>不可变对象最好用<code>copy</code>修饰</strong></p>\n<p>不可变对象最好用<code>copy</code>修饰，因为用<code>strong</code>、<code>retain</code>修饰的话，<code>setter</code>方法内部仅仅是<code>retain</code>，那当我们把一个可变对象赋值给这个不可变属性时，不可变属性仅仅是指针指向了可变对象，修改可变对象的值，也就是不可变属性指向的对象值发生了改变，这不是我们所希望的结果，我们直观的感觉应该是“不可变属性指向的对象不应该随着别人的改变而改变”。</p>\n</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"comment\">//@property (nonatomic, retain) NSString *name;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 可变对象</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *mutableName = [<span class=\"string\">@&quot;张三&quot;</span> mutableCopy];</span><br><span class=\"line\">    <span class=\"comment\">// 可变对象赋值给这个不可变属性</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = mutableName;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 修改可变对象的值</span></span><br><span class=\"line\">    [mutableName appendString:<span class=\"string\">@&quot;丰&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三丰，不可变属性的值也会跟着变化，这不是我们希望看到的</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>而用<code>copy</code>修饰的话，<code>setter</code>方法内部就是<code>copy</code>，那不管你外界传给它一个可变还是不可变对象，该属性最终都是深拷贝出一份不可变的，这样外界就无法影响这个属性的值，除非我们主动修改，符合我们的预期。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 可变对象</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *mutableName = [<span class=\"string\">@&quot;张三&quot;</span> mutableCopy];</span><br><span class=\"line\">    <span class=\"comment\">// 可变对象赋值给这个不可变属性</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = mutableName;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 修改可变对象的值</span></span><br><span class=\"line\">    [mutableName appendString:<span class=\"string\">@&quot;丰&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三，外界无法影响这个属性的值</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@&quot;张三丰&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三丰，我们主动修改属性的值，符合我们的预期</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>而可变属性坚决不能用<code>copy</code>修饰、只能用<code>strong</code>或<code>retain</code>修饰</strong></p>\n<p>可变属性坚决不能用<code>copy</code>修饰，只能用<code>strong</code>、<code>retain</code>修饰，道理和上面一样，<code>copy</code>修饰的属性最终在<code>setter</code>方法里<code>copy</code>出一份不可变的，如果你非要用它来修饰可变属性，那从外在看来好像可以改变这个属性，结果一修改就崩溃了，因为找不到方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSMutableString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = [<span class=\"string\">@&quot;张三&quot;</span> mutableCopy];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.name appendString:<span class=\"string\">@&quot;丰&quot;</span>]; <span class=\"comment\">// 一修改，就崩溃，因为NSString根本没有appendString:方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"三、创建大量autorelease对象时，最好自己创建一个-autoreleasepool\"><a href=\"#三、创建大量autorelease对象时，最好自己创建一个-autoreleasepool\" class=\"headerlink\" title=\"三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {...}\"></a>三、创建大量<code>autorelease</code>对象时，最好自己创建一个<code>@autoreleasepool &#123;...&#125;</code></h3><p>只要不是用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法创建的对象，而是用类方法创建的对象，方法内部都调用了<code>autorelease</code>，都是<code>autorelease</code>对象，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> string];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dict = [<span class=\"built_in\">NSDictionary</span> dictionary];</span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;11&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>因为类方法的内部实现大概如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id)<span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    id obj = [[NSObject alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    [obj autorelease];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法的内部实现大概如下：<strong>所以在创建大量<code>autorelease</code>对象时，最好自己创建一个<code>@autoreleasepool &#123;...&#125;</code>。</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">id</span>)allocObject &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以在创建大量<code>autorelease</code>对象时，最好自己创建一个<code>@autoreleasepool &#123;...&#125;</code>。因为如果主线程RunLoop的某次循环一直忙着处理事情，线程没有休眠或者退出，那本次循环的<code>autoreleasepool</code>就迟迟无法销毁，这就会导致这次循环里的<code>autorelease</code>对象迟迟无法释放掉，因此就很有可能会导致内存的使用峰值过高，从而导致内存溢出。而自己创建<code>@autoreleasepool &#123;...&#125;</code>后，每一次<code>for</code>循环都会出一次<code>@autoreleasepool &#123;...&#125;</code><strong>的作用域而销毁一波</strong><code>autorelease</code>对象，这就可以降低内存的峰值。</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i ++) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *string = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;%d&quot;</span>, i];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, string);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>autoreleasepool</code>的实现原理简述：<code>autoreleasepool</code>其实也是一个对象，它在创建后，内部会有一堆<code>AutoReleasePoolPage</code>对象，这一堆<code>AutoReleasePoolPage</code>对象是通过双向链表组织起来的——即<code>AutoReleasePoolPage</code>对象1的<code>child</code>属性指向<code>AutoReleasePoolPage</code>对象2，<code>AutoReleasePoolPage</code>对象2的<code>child</code>属性指向<code>AutoReleasePoolPage</code>对象3，而<code>AutoReleasePoolPage</code>对象3的<code>parent</code>属性指向<code>AutoReleasePoolPage</code>对象2，<code>AutoReleasePoolPage</code>对象2的<code>parent</code>属性指向<code>AutoReleasePoolPage</code>对象1，这样通过<code>child</code>属性和<code>parent</code>两个属性关联起来的双向数据结构就是双向链表，而每一个<code>AutoReleasePoolPage</code>对象内部都有4040个字节用来存放<code>autorelease</code>对象的内存地址，如果项目里一个<code>AutoReleasePoolPage</code>对象存不下所有的<code>autorelease</code>对象的内存地址，那<code>autoreleasepool</code>在创建的时候就会创建两个<code>AutoReleasePoolPage</code>对象，依次类推，然后当<code>autoreleasepool</code>销毁时就会去<code>AutoReleasePoolPage</code>对象里找到这些对象的地址将它们的引用计数都做一次减1操作。</p>\n<h3 id=\"四、其它一些注意\"><a href=\"#四、其它一些注意\" class=\"headerlink\" title=\"四、其它一些注意\"></a>四、其它一些注意</h3><p>注意代理不要出现循环引用，block不要出现循环引用，KVO和通知要在<code>dealloc</code>的时候释放等。</p>\n<h3 id=\"五、知识扩展-GC和引用计数对比\"><a href=\"#五、知识扩展-GC和引用计数对比\" class=\"headerlink\" title=\"五、知识扩展-GC和引用计数对比\"></a>五、知识扩展-GC和引用计数对比</h3><p>Android 手机通常使用 Java 来开发，而 Java 是使用<a href=\"https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1001.2101.3001.7020\">垃圾回收</a>这种内存管理方式。垃圾回收(Garbage Collection，简称 GC)这种内存管理机制最早由图灵奖获得者 John McCarthy 在 1959 年提出，垃圾回收的理论主要基于一个事实：大部分的对象的生命期都很短。所以，GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到 Old 区。(其实还有一个 Perm 区，但是内存回收算法通常不涉及这个区域)</p>\n<p>当 GC 工作时，GC 认为当前的一些对象是有效的，这些对象包括：全局变量，栈里面的变量等，然后 GC 从这些变量出发，去标记这些变量「可达」的其它变量，这个标记是一个递归的过程，最后就像从树根的内存对象开始，把所有的树枝和树叶都记成可达的了。那除了这些「可达」的变量，别的变量就都需要被回收了。</p>\n<p>听起来很牛逼对不对？那为什么苹果不用呢？实际上苹果在 OS X 10.5 的时候还真用了，不过在 10.7 的时候把 GC 换成了 ARC。那么，GC 有什么问题让苹果不能忍，这就是：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所以说，你知道 Android 手机有时候为什么会卡吧，GC 就相当于春运的最后一天返城高峰。当所有的对象都需要一起回收时，那种体验肯定是当时还在世的乔布斯忍受不了的。</p>\n<ul>\n<li><p><strong>ARC 相对于 GC 的优点：</strong></p>\n<p>1.ARC 工作在编译期，在运行时没有额外开销。</p>\n<p>2.ARC 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 GC 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。</p>\n</li>\n<li><p><strong>ARC 相对于 GC 的缺点：</strong></p>\n<p>1.GC 真的是太简单了，基本上完全不用处理内存管理问题，而 ARC 还是需要处理类似循环引用这种内存管理问题。</p>\n<p>2.GC 一类的语言相对来说学习起来更简单。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一、定时器的循环引入</p>\n<p>二、copy、mutableCopy</p>\n<p>三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}</p>\n<p>四、其他注意事项</p>\n</blockquote>","more":"<h3 id=\"一、定时器的循环引入\"><a href=\"#一、定时器的循环引入\" class=\"headerlink\" title=\"一、定时器的循环引入\"></a>一、定时器的循环引入</h3><p>我们以<code>NSTimer</code>举例，<code>CADisplayLink</code>遇到同样的问题，解决方案也一样。</p>\n<h4 id=\"1-NSTimer的循环引入\"><a href=\"#1-NSTimer的循环引入\" class=\"headerlink\" title=\"1.NSTimer的循环引入\"></a>1.<code>NSTimer</code>的循环引入</h4><p>使用<code>NSTimer</code>，写法通常如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController1.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ViewController1 *vc = [[ViewController1 alloc] init];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController pushViewController:vc animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController1.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController1</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController1</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建timer</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)test &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 退出界面时，使timer失效从而销毁</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.timer invalidate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行代码，点击<code>ViewController</code>进入<code>ViewController1</code>，此时<code>timer</code>跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回<code>ViewController</code>，正常情况下<code>ViewController1</code>应该会销毁，并触发<code>dealloc</code>方法，<code>timer</code>也跟着失效并且销毁。但实际情况却是<code>ViewController1</code>没有销毁，也没有触发<code>dealloc</code>方法，<code>timer</code>还一直跑着，这是因为<code>timer</code>和<code>ViewController1</code>形成了循环引用，导致内存泄漏。</p>\n<p>查看<code>timer</code>的创建方法，可以知道：**<code>timer</code>会强引用<code>target</code>，**也就是说<code>timer</code>确实强引用着<code>ViewController1</code>。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png\" alt=\"creatTimer\"></p>\n<p>而<code>ViewController</code>又强引用着<code>timer</code>。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png\" alt=\"img\"></p>\n<p>那怎么打破<code>NSTimer</code>的循环引用呢？我们知道<code>__weak</code>是专门用来打破循环引用的，那它是不是也能打破<code>NSTimer</code>的循环引用？</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 尝试用__weak打破NSTimer的循环引用</span></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:weakSelf selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行，发现没有效果，那为什么<code>__weak</code>不能打破<code>NSTimer</code>的循环引用？毫无疑问<code>__weak</code>的确是把<code>self</code>搞成了弱指针，但因为<code>NSTimer</code>内部有一个强指针类型的<code>target</code>变量</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"type\">id</span> target;</span><br></pre></td></tr></table></figure>\n\n<p>来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用<code>target</code>，所以用<code>__weak</code>不能打破<code>NSTimer</code>的循环引用。</p>\n<p>那再试试另一条引用线吧，让<code>ViewController1</code>弱引用<code>timer</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController1</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试用weak修饰timer来打破NSTimer的循环引用</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对<code>NSTimer</code>的说明，可以知道：<strong>把<code>timer</code>添加到RunLoop之后，RunLoop会强引用<code>timer</code>，并且建议我们不必自己强引用<code>timer</code>，而解除RunLoop对<code>timer</code>强引用的唯一方式就是调用<code>timer</code>的<code>invalidate</code>方法使<code>timer</code>失效从而销毁。</strong></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png\" alt=\"img\"></p>\n<p>也就是说，实际的引用关系如下：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png\" alt=\"img\"></p>\n<p>所以我们<strong>使用<code>weak</code>修饰<code>timer</code>是正确的，</strong>但这还是不能打破<code>NSTimer</code>的循环引用——更准确地说，这可以解决<code>NSTimer</code>的循环引用，但还是没有解决<code>NSTimer</code>内存泄漏的问题。因为<code>[self.timer invalidate]</code>的调用——即<code>timer</code>的销毁——最好就是发生在<code>ViewController1</code>销毁时，而<code>ViewController1</code>要想销毁就必须得<code>timer</code>先销毁，还是内存泄漏。</p>\n<p>倒腾来倒腾去，还是得<strong>从<code>timer</code>强引用<code>target</code>这条引用线下手，把它搞成弱引用，<code>__weak</code>不起作用，那我们想想别的方案呗。</strong></p>\n<h4 id=\"2、打破NSTimer的循环引用\"><a href=\"#2、打破NSTimer的循环引用\" class=\"headerlink\" title=\"2、打破NSTimer的循环引用\"></a>2、打破<code>NSTimer</code>的循环引用</h4><ul>\n<li>方案一：使用block的方式创建<code>timer</code></li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [weakSelf test];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么能解决呢？因为此时<code>timer</code>是强引用block的，而<code>__weak</code>可以打破block的循环引用，所以block是弱引用<code>self</code>的，所以最终的效果就类似于<code>timer</code>弱引用<code>self</code>。解决是能解决，但用这种方式创建<code>timer</code>要iOS10.0以后才能使用。</p>\n<ul>\n<li><p>方案二：创建一个中间对象——代理</p>\n<p>我们可以把方案一的思路自己实现一下嘛，<strong>即创建一个中间对象（方案一的中间对象就是block嘛），把这个中间对象作为<code>timer</code>的<code>target</code>参数传进去，让<code>timer</code>强引用这个中间对象，而让这个中间对象弱引用<code>ViewController1</code>，这样<code>ViewController1</code>就能正常释放，<code>NSTimer</code>就能正常调用失效方法，RunLoop就能正常解除对<code>NSTimer</code>的强引用，<code>NSTimer</code>就能正常解除对中间对象的强引用，内存泄漏就解决了。</strong>当然<strong>由于中间对象没有<code>target</code>——即<code>ViewController1</code>——的方法，所以我们还要做一步消息转发。</strong></p>\n</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INETimerProxy.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INETimerProxy</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INETimerProxy.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INETimerProxy.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INETimerProxy</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 弱引用target所指向的对象</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"type\">id</span> target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INETimerProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    INETimerProxy *proxy = [[INETimerProxy alloc] init];</span><br><span class=\"line\">    proxy.target = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接消息转发</span></span><br><span class=\"line\">- (<span class=\"type\">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.target;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------ViewController1.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INETimerProxy.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:[INETimerProxy proxyWithTarget:<span class=\"keyword\">self</span>] selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了提高消息转发效率，我们可以让代理直接继承自<code>NSProxy</code>，而不是<code>NSObject</code>。**<code>NSProxy</code>是专门用来做消息转发的，继承自<code>NSObject</code>的类调用方法时会走方法查找 –&gt; 动态方法解析 –&gt; 直接消息转发、完整消息转发这套流程，而继承自<code>NSProxy</code>的类调用方法时只会走方法查找 –&gt; 完整消息转发这两个流程，消息转发效率更高，所以以后但凡要做消息转发就直接继承自<code>NSProxy</code>好了，而不是<code>NSObject</code>。**</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INETimerProxy.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INETimerProxy</span> : <span class=\"title\">NSProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INETimerProxy.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INETimerProxy.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INETimerProxy</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 弱引用target所指向的对象</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"type\">id</span> target;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INETimerProxy</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)proxyWithTarget:(<span class=\"type\">id</span>)target &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// NSProxy类是没有init方法的，alloc后就可以直接使用</span></span><br><span class=\"line\">    INETimerProxy *proxy = [INETimerProxy alloc];</span><br><span class=\"line\">    proxy.target = target;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> proxy;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 完整消息转发</span></span><br><span class=\"line\">- (<span class=\"built_in\">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"keyword\">self</span>.target methodSignatureForSelector:sel];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)forwardInvocation:(<span class=\"built_in\">NSInvocation</span> *)invocation &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [invocation invokeWithTarget:<span class=\"keyword\">self</span>.target];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、copy、mutableCopy\"><a href=\"#二、copy、mutableCopy\" class=\"headerlink\" title=\"二、copy、mutableCopy\"></a>二、<code>copy</code>、<code>mutableCopy</code></h3><h4 id=\"1、深拷贝与浅拷贝\"><a href=\"#1、深拷贝与浅拷贝\" class=\"headerlink\" title=\"1、深拷贝与浅拷贝\"></a>1、深拷贝与浅拷贝</h4><blockquote>\n<ul>\n<li><strong>深拷贝，是指内容拷贝，会产生新的对象，新对象的引用计数为1；浅拷贝，是指指针拷贝，不会产生新的对象，旧对象的引用计数加1，浅拷贝其实就是<code>retain</code>，深拷贝的话新对象和旧对象互不影响，浅拷贝的话改变一个另一个也跟着变了。</strong></li>\n<li><strong>只有不可变对象的不可变拷贝是浅拷贝，其它的都是深拷贝。</strong></li>\n</ul>\n</blockquote>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str1 = <span class=\"string\">@&quot;11&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str2 = [str1 <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 不可变对象的不可变拷贝 --&gt; 浅拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *str3 = [str1 mutableCopy]; <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%p %p %p&quot;</span>, str1, str2, str3);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *str4 = [<span class=\"string\">@&quot;11&quot;</span> mutableCopy];</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *str5 = [str4 <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *str6 = [str4 mutableCopy]; <span class=\"comment\">// 深拷贝</span></span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%p %p %p&quot;</span>, str4, str5, str6);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">控制台打印：</span><br><span class=\"line\"><span class=\"number\">0x1025260b0</span> <span class=\"number\">0x1025260b0</span> <span class=\"number\">0x600003bc0ab0</span></span><br><span class=\"line\"><span class=\"number\">0x600003b992c0</span> <span class=\"number\">0xc91f17b5d8b748d0</span> <span class=\"number\">0x600003b99890</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、不可变属性最好用copy修饰，而可变属性坚决不能用copy修饰、只能用strong、retain修饰\"><a href=\"#2、不可变属性最好用copy修饰，而可变属性坚决不能用copy修饰、只能用strong、retain修饰\" class=\"headerlink\" title=\"2、不可变属性最好用copy修饰，而可变属性坚决不能用copy修饰、只能用strong、retain修饰\"></a>2、不可变属性最好用<code>copy</code>修饰，而可变属性坚决不能用<code>copy</code>修饰、只能用<code>strong</code>、<code>retain</code>修饰</h4><blockquote>\n<p><code>copy</code>拷贝出来的东西是不可变对象，是不能修改的；</p>\n<p><code>mutableCopy</code>拷贝出来的东西是可变对象，是能修改的。</p>\n</blockquote>\n<ul>\n<li><p><strong>不可变对象最好用<code>copy</code>修饰</strong></p>\n<p>不可变对象最好用<code>copy</code>修饰，因为用<code>strong</code>、<code>retain</code>修饰的话，<code>setter</code>方法内部仅仅是<code>retain</code>，那当我们把一个可变对象赋值给这个不可变属性时，不可变属性仅仅是指针指向了可变对象，修改可变对象的值，也就是不可变属性指向的对象值发生了改变，这不是我们所希望的结果，我们直观的感觉应该是“不可变属性指向的对象不应该随着别人的改变而改变”。</p>\n</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"comment\">//@property (nonatomic, retain) NSString *name;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 可变对象</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *mutableName = [<span class=\"string\">@&quot;张三&quot;</span> mutableCopy];</span><br><span class=\"line\">    <span class=\"comment\">// 可变对象赋值给这个不可变属性</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = mutableName;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 修改可变对象的值</span></span><br><span class=\"line\">    [mutableName appendString:<span class=\"string\">@&quot;丰&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三丰，不可变属性的值也会跟着变化，这不是我们希望看到的</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>而用<code>copy</code>修饰的话，<code>setter</code>方法内部就是<code>copy</code>，那不管你外界传给它一个可变还是不可变对象，该属性最终都是深拷贝出一份不可变的，这样外界就无法影响这个属性的值，除非我们主动修改，符合我们的预期。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 可变对象</span></span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *mutableName = [<span class=\"string\">@&quot;张三&quot;</span> mutableCopy];</span><br><span class=\"line\">    <span class=\"comment\">// 可变对象赋值给这个不可变属性</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = mutableName;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 修改可变对象的值</span></span><br><span class=\"line\">    [mutableName appendString:<span class=\"string\">@&quot;丰&quot;</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三，外界无法影响这个属性的值</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = <span class=\"string\">@&quot;张三丰&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, <span class=\"keyword\">self</span>.name); <span class=\"comment\">// 张三丰，我们主动修改属性的值，符合我们的预期</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>而可变属性坚决不能用<code>copy</code>修饰、只能用<code>strong</code>或<code>retain</code>修饰</strong></p>\n<p>可变属性坚决不能用<code>copy</code>修饰，只能用<code>strong</code>、<code>retain</code>修饰，道理和上面一样，<code>copy</code>修饰的属性最终在<code>setter</code>方法里<code>copy</code>出一份不可变的，如果你非要用它来修饰可变属性，那从外在看来好像可以改变这个属性，结果一修改就崩溃了，因为找不到方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSMutableString</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.name = [<span class=\"string\">@&quot;张三&quot;</span> mutableCopy];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.name appendString:<span class=\"string\">@&quot;丰&quot;</span>]; <span class=\"comment\">// 一修改，就崩溃，因为NSString根本没有appendString:方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"三、创建大量autorelease对象时，最好自己创建一个-autoreleasepool\"><a href=\"#三、创建大量autorelease对象时，最好自己创建一个-autoreleasepool\" class=\"headerlink\" title=\"三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {...}\"></a>三、创建大量<code>autorelease</code>对象时，最好自己创建一个<code>@autoreleasepool &#123;...&#125;</code></h3><p>只要不是用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法创建的对象，而是用类方法创建的对象，方法内部都调用了<code>autorelease</code>，都是<code>autorelease</code>对象，例如：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSString</span> *str = [<span class=\"built_in\">NSString</span> string];</span><br><span class=\"line\"><span class=\"built_in\">NSArray</span> *arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\"><span class=\"built_in\">NSDictionary</span> *dict = [<span class=\"built_in\">NSDictionary</span> dictionary];</span><br><span class=\"line\"><span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"string\">@&quot;11&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<p>因为类方法的内部实现大概如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (id)<span class=\"keyword\">object</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    id obj = [[NSObject alloc] <span class=\"keyword\">init</span>];</span><br><span class=\"line\">    [obj autorelease];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法的内部实现大概如下：<strong>所以在创建大量<code>autorelease</code>对象时，最好自己创建一个<code>@autoreleasepool &#123;...&#125;</code>。</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">id</span>)allocObject &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>所以在创建大量<code>autorelease</code>对象时，最好自己创建一个<code>@autoreleasepool &#123;...&#125;</code>。因为如果主线程RunLoop的某次循环一直忙着处理事情，线程没有休眠或者退出，那本次循环的<code>autoreleasepool</code>就迟迟无法销毁，这就会导致这次循环里的<code>autorelease</code>对象迟迟无法释放掉，因此就很有可能会导致内存的使用峰值过高，从而导致内存溢出。而自己创建<code>@autoreleasepool &#123;...&#125;</code>后，每一次<code>for</code>循环都会出一次<code>@autoreleasepool &#123;...&#125;</code><strong>的作用域而销毁一波</strong><code>autorelease</code>对象，这就可以降低内存的峰值。</strong></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i ++) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">@autoreleasepool</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *string = [<span class=\"built_in\">NSString</span> stringWithFormat:<span class=\"string\">@&quot;%d&quot;</span>, i];</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%@&quot;</span>, string);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>autoreleasepool</code>的实现原理简述：<code>autoreleasepool</code>其实也是一个对象，它在创建后，内部会有一堆<code>AutoReleasePoolPage</code>对象，这一堆<code>AutoReleasePoolPage</code>对象是通过双向链表组织起来的——即<code>AutoReleasePoolPage</code>对象1的<code>child</code>属性指向<code>AutoReleasePoolPage</code>对象2，<code>AutoReleasePoolPage</code>对象2的<code>child</code>属性指向<code>AutoReleasePoolPage</code>对象3，而<code>AutoReleasePoolPage</code>对象3的<code>parent</code>属性指向<code>AutoReleasePoolPage</code>对象2，<code>AutoReleasePoolPage</code>对象2的<code>parent</code>属性指向<code>AutoReleasePoolPage</code>对象1，这样通过<code>child</code>属性和<code>parent</code>两个属性关联起来的双向数据结构就是双向链表，而每一个<code>AutoReleasePoolPage</code>对象内部都有4040个字节用来存放<code>autorelease</code>对象的内存地址，如果项目里一个<code>AutoReleasePoolPage</code>对象存不下所有的<code>autorelease</code>对象的内存地址，那<code>autoreleasepool</code>在创建的时候就会创建两个<code>AutoReleasePoolPage</code>对象，依次类推，然后当<code>autoreleasepool</code>销毁时就会去<code>AutoReleasePoolPage</code>对象里找到这些对象的地址将它们的引用计数都做一次减1操作。</p>\n<h3 id=\"四、其它一些注意\"><a href=\"#四、其它一些注意\" class=\"headerlink\" title=\"四、其它一些注意\"></a>四、其它一些注意</h3><p>注意代理不要出现循环引用，block不要出现循环引用，KVO和通知要在<code>dealloc</code>的时候释放等。</p>\n<h3 id=\"五、知识扩展-GC和引用计数对比\"><a href=\"#五、知识扩展-GC和引用计数对比\" class=\"headerlink\" title=\"五、知识扩展-GC和引用计数对比\"></a>五、知识扩展-GC和引用计数对比</h3><p>Android 手机通常使用 Java 来开发，而 Java 是使用<a href=\"https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1001.2101.3001.7020\">垃圾回收</a>这种内存管理方式。垃圾回收(Garbage Collection，简称 GC)这种内存管理机制最早由图灵奖获得者 John McCarthy 在 1959 年提出，垃圾回收的理论主要基于一个事实：大部分的对象的生命期都很短。所以，GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到 Old 区。(其实还有一个 Perm 区，但是内存回收算法通常不涉及这个区域)</p>\n<p>当 GC 工作时，GC 认为当前的一些对象是有效的，这些对象包括：全局变量，栈里面的变量等，然后 GC 从这些变量出发，去标记这些变量「可达」的其它变量，这个标记是一个递归的过程，最后就像从树根的内存对象开始，把所有的树枝和树叶都记成可达的了。那除了这些「可达」的变量，别的变量就都需要被回收了。</p>\n<p>听起来很牛逼对不对？那为什么苹果不用呢？实际上苹果在 OS X 10.5 的时候还真用了，不过在 10.7 的时候把 GC 换成了 ARC。那么，GC 有什么问题让苹果不能忍，这就是：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所以说，你知道 Android 手机有时候为什么会卡吧，GC 就相当于春运的最后一天返城高峰。当所有的对象都需要一起回收时，那种体验肯定是当时还在世的乔布斯忍受不了的。</p>\n<ul>\n<li><p><strong>ARC 相对于 GC 的优点：</strong></p>\n<p>1.ARC 工作在编译期，在运行时没有额外开销。</p>\n<p>2.ARC 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 GC 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。</p>\n</li>\n<li><p><strong>ARC 相对于 GC 的缺点：</strong></p>\n<p>1.GC 真的是太简单了，基本上完全不用处理内存管理问题，而 ARC 还是需要处理类似循环引用这种内存管理问题。</p>\n<p>2.GC 一类的语言相对来说学习起来更简单。</p>\n</li>\n</ul>"},{"title":"【Runtime】Runtime是什么？","date":"2021-07-13T06:30:48.000Z","_content":"\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220717183036199.png)\n\n<!--more-->\n\n**Runtime即运行时，它就是一个库，它的主要作用就是使得OC这门语言具备了面向对象性和动态性。**所谓的面向对象性，我们几个例子，OC对象基于C/C++结构图实现的，OC方法也是基于C/C++函数实现的，OC对象调用OC方法其实就是通过C/C++结构体里面的函数指针找到具体的C/C++函数来执行，这一切都是Runtime库实现的。所谓动态性。我们知道像C/C++等静态语言编写的代码，他们编译成什么运行时就会执行什么，但是像OC这样的动态语言编写的代码，他们编译成什么运行时就不一定会执行什么，比如我们写了这样一段代码`[对象A 方法A]`，方法A的实现是`NSLog(@\"11\")`，还有一个方法B，方法B的实现是`NSLog(@\"22\")`，我们又通过Runtime的API把方法A和方法B的实现做了交换，那么在编译阶段肯定还是对象A调用方法A，预期打印是11，但实际上在运行阶段却是对象A调用了方法B，实际打印却是22，我们甚至可以通过Runtime的API把方法A的调用者改成对象B，这一切都是Runtime库支撑的。","source":"_posts/Runtime是什么？.md","raw":"---\ntitle: 【Runtime】Runtime是什么？\ndate: 2021-07-13 14:30:48\ntags: Runtime系列\n---\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220717183036199.png)\n\n<!--more-->\n\n**Runtime即运行时，它就是一个库，它的主要作用就是使得OC这门语言具备了面向对象性和动态性。**所谓的面向对象性，我们几个例子，OC对象基于C/C++结构图实现的，OC方法也是基于C/C++函数实现的，OC对象调用OC方法其实就是通过C/C++结构体里面的函数指针找到具体的C/C++函数来执行，这一切都是Runtime库实现的。所谓动态性。我们知道像C/C++等静态语言编写的代码，他们编译成什么运行时就会执行什么，但是像OC这样的动态语言编写的代码，他们编译成什么运行时就不一定会执行什么，比如我们写了这样一段代码`[对象A 方法A]`，方法A的实现是`NSLog(@\"11\")`，还有一个方法B，方法B的实现是`NSLog(@\"22\")`，我们又通过Runtime的API把方法A和方法B的实现做了交换，那么在编译阶段肯定还是对象A调用方法A，预期打印是11，但实际上在运行阶段却是对象A调用了方法B，实际打印却是22，我们甚至可以通过Runtime的API把方法A的调用者改成对象B，这一切都是Runtime库支撑的。","slug":"Runtime是什么？","published":1,"updated":"2022-07-17T10:30:45.725Z","_id":"cl5ahys8f0000mcfya1l14aqe","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220717183036199.png\" alt=\"img\"></p>\n<span id=\"more\"></span>\n\n<p><strong>Runtime即运行时，它就是一个库，它的主要作用就是使得OC这门语言具备了面向对象性和动态性。</strong>所谓的面向对象性，我们几个例子，OC对象基于C/C++结构图实现的，OC方法也是基于C/C++函数实现的，OC对象调用OC方法其实就是通过C/C++结构体里面的函数指针找到具体的C/C++函数来执行，这一切都是Runtime库实现的。所谓动态性。我们知道像C/C++等静态语言编写的代码，他们编译成什么运行时就会执行什么，但是像OC这样的动态语言编写的代码，他们编译成什么运行时就不一定会执行什么，比如我们写了这样一段代码<code>[对象A 方法A]</code>，方法A的实现是<code>NSLog(@&quot;11&quot;)</code>，还有一个方法B，方法B的实现是<code>NSLog(@&quot;22&quot;)</code>，我们又通过Runtime的API把方法A和方法B的实现做了交换，那么在编译阶段肯定还是对象A调用方法A，预期打印是11，但实际上在运行阶段却是对象A调用了方法B，实际打印却是22，我们甚至可以通过Runtime的API把方法A的调用者改成对象B，这一切都是Runtime库支撑的。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220717183036199.png\" alt=\"img\"></p>","more":"<p><strong>Runtime即运行时，它就是一个库，它的主要作用就是使得OC这门语言具备了面向对象性和动态性。</strong>所谓的面向对象性，我们几个例子，OC对象基于C/C++结构图实现的，OC方法也是基于C/C++函数实现的，OC对象调用OC方法其实就是通过C/C++结构体里面的函数指针找到具体的C/C++函数来执行，这一切都是Runtime库实现的。所谓动态性。我们知道像C/C++等静态语言编写的代码，他们编译成什么运行时就会执行什么，但是像OC这样的动态语言编写的代码，他们编译成什么运行时就不一定会执行什么，比如我们写了这样一段代码<code>[对象A 方法A]</code>，方法A的实现是<code>NSLog(@&quot;11&quot;)</code>，还有一个方法B，方法B的实现是<code>NSLog(@&quot;22&quot;)</code>，我们又通过Runtime的API把方法A和方法B的实现做了交换，那么在编译阶段肯定还是对象A调用方法A，预期打印是11，但实际上在运行阶段却是对象A调用了方法B，实际打印却是22，我们甚至可以通过Runtime的API把方法A的调用者改成对象B，这一切都是Runtime库支撑的。</p>"},{"title":"RunLoop","date":"2021-07-10T11:11:38.000Z","_content":"\n> 一、RunLoop是什么\n>\n> 二、RunLoop的底层实现\n>\n> ​\t\t1、RunLoop和线程是什么关系\n>\n> ​\t\t2、RunLoop的运行模式\n>\n> ​\t\t3、Source0事件源、Source1事件源、Observer、Timer事件源\n>\n> 三、RunLoop的运行流程\n>\n> 四、RunLoop的实际应用\n>\n> ​\t\t1、处理NSTimer不工作的问题\n>\n> ​\t\t2、常驻线程\n\n<!--more-->\n\n### 一、RunLoop是什么\n\nRunLoop运行循环，它就是一个OC对象，它的主要作用有三个：\n\n**保持App的持续运行**，具体而言，我们的App在启动后就会在`main`函数那里创建并启动主线程对应的RunLoop，这个RunLoop内部维护着一个`do...while`循环，正是因为`do...while`循环的存在，才使得主线程得以保活，即主线程不会执行完任务立即退出，也就是App得以保活，否则App一启动执行完`main`函数就退出了；\n\n- **处理App的各种事件**，具体说，RunLoop内部的`do...while`循环里循环处理着App的各种事件，包括Source0事件、Source1事件、Timer事件；\n- **线程的休眠唤醒则是RunLoop区别于其他语言EventLoop的核心所在，线程没事做就休眠，有事做就唤醒，这样可以节省CPU资源。**\n\n### 二、RunLoop的底层实现\n\nRunLoop是`NSRunLoop`类型的，它的C语言实现为`CFRunLoopRef`，因为[CFRunLoopRef](https://links.jianshu.com/go?to=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2FCF%2F)是开源的，所以接下来我们会从它的源码来看看RunLoop的底层实现。\n\n```objectivec\ntypedef struct __CFRunLoop *CFRunLoopRef;\nstruct __CFRunLoop {\n    pthread_t _pthread; // RunLoop对应的线程\n\n    CFMutableSetRef _modes; // RunLoop所有的运行模式\n    CFRunLoopModeRef _currentMode; // RunLoop当前的运行模式\n\n    CFMutableSetRef _commonModes; // RunLoop“特殊的运行模式”\n    CFMutableSetRef _commonModeItems; // RunLoop“特殊的运行模式“里的items\n};\n\ntypedef struct __CFRunLoopMode *CFRunLoopModeRef;\nstruct __CFRunLoopMode {\n    CFStringRef _name; // 运行模式的名字，如@\"NSDefaultRunLoopMode\"、@\"UITrackingRunLoopMode\"\n    CFMutableSetRef _sources0; // Set，Source0事件源集合\n    CFMutableSetRef _sources1; // Set，Source1事件源集合\n    CFMutableArrayRef _observers; // Array，观察者数组\n    CFMutableArrayRef _timers; // Array，Timer事件源数组\n};\n```\n\n#### 1、RunLoop和线程的关系\n\n苹果并没有为我们提供创建RunLoop的API，仅仅提供了获取RunLoop的API。\n\n```objectivec\n// Core Foundation框架\nCFRunLoopGetMain(); // 获取主线程对应的RunLoop\nCFRunLoopGetCurrent(); // 获取当前线程对应的RunLoop\n\n// Foundation框架，对Core Foundation框架函数的封装\n[NSRunLoop mainRunLoop]; // 获取主线程对应的RunLoop\n[NSRunLoop currentRunLoop]; // 获取当前线程对应的RunLoop\n```\n\n这两套API的底层实现大概如下（伪代码，详见`CFRunLoop.c`文件）：\n\n```objectivec\nCFRunLoopRef CFRunLoopGetMain() {\n    return _CFRunLoopGet(pthread_main_thread_np());\n}\n \nCFRunLoopRef CFRunLoopGetCurrent() {\n    return _CFRunLoopGet(pthread_self());\n}\n\n\n// 一个全局的字典，线程是key，RunLoop是value\nstatic CFMutableDictionaryRef __CFRunLoops;\n\nCFRunLoopRef _CFRunLoopGet(pthread_t thread) {\n    \n    if (!__CFRunLoops) { // 如果是第一次获取RunLoop（那肯定是获取主线程对应的RunLoop，因为App一启动系统就会自动去获取主线程对应的RunLoop，我们自己写的获取且早着呢）\n\n        // 初始化全局的字典\n        __CFRunLoops = CFDictionaryCreateMutable();\n        \n        // 创建主线程对应的RunLoop\n        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n        // 主线程为key，主线程对应的RunLoop为value，存入全局的字典里\n        CFDictionarySetValue(dict, pthread_main_thread_np(), mainLoop);\n    }\n    \n    // 从全局的字典里读取某个线程对应的RunLoop\n    CFRunLoopRef loop = CFDictionaryGetValue(__CFRunLoops, thread);\n    \n    if (!loop) { // 如果读取不到\n        \n        // 创建该线程对应的RunLoop，\n        loop = __CFRunLoopCreate(thread);\n        // 该线程为key，该线程对应的RunLoop为value，存入全局的字典里\n        CFDictionarySetValue(__CFRunLoops, thread, loop);\n    }\n\n    // 注册一个回调，当某个线程销毁时，也销毁该线程对应的RunLoop\n    _CFSetTSD(thread, loop, __CFFinalizeRunLoop);\n\n    return loop;\n}\n```\n\n> - RunLoop是基于线程来管理的，他们是一一对应的关系，共同存在于一个全局的字典里，线程是`key`，RunLoop是`value`；\n> - 对于主线程的RunLoop来说，App一启动系统就会自动创建并启动，而对子线程的RunLoop来说，除非我们主动去获取，否则不会创建，我们获取也就是创建子线程的RunLoop后，还需要手动启动它；\n> - RunLoop的销毁发生在线程销毁时。\n\n#### 2、RunLoop的运行模式\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1140.png)\n\n> - **系统为RunLoop提供了好几种运行模式，其中`NSDefaultRunLoopMode`和`UITrackingRunLoopMode`是我们经常使用的。`NSDefaultRunLoopMode`是RunLoop默认的运行模式，大多数时候RunLoop就运行在这种模式下，`UITrackingRunLoopMode`是界面滑动时RunLoop的运行模式，系统会自动完成不同情况下这两种运行模式的切换；**\n> - **当然RunLoop还有一种“特殊的运行模式”，就是`NSRunLoopCommonModes`，严格来说它不是一种运行模式，而是一些运行模式的组合。比如说系统会默认把`NSDefaultRunLoopMode`和`UITrackingRunLoopMode`添加到`NSRunLoopCommonModes`里，RunLoop运行在`NSRunLoopCommonModes`模式时，并不是说它就真得运行在`NSRunLoopCommonModes`下，而是说RunLoop在切换真正的运行模式时会自动把一个运行模式里面的Source0/Source1/Observer/Timer同步到另一个运行模式里；**\n> - **一个RunLoop可以有多个运行模式，而每个运行模式里又可以有多个Source0/Source1/Observer/Timer，但是RunLoop一次只能运行在一个运行模式下，这个运行模式被称为CurrentMode，如果要切换运行模式，就得退出RunLoop，重新选择一个运行模式运行。RunLoop分Mode的目的就是为了把不同Mode里的Source0/Source1/Observer/Timer给隔离开来，在这个模式下的时候就做专心做这个模式里的事，在那个模式下的时候就专心做那个模式里的事，让它们互相不影响，当然如果你想一件事能在多个模式下做，那就把它扔到`CommonModes`下。**\n\n#### 3、Source0事件源、Source1事件源、Observer、Timer事件源\n\n###### Source0事件源：\n\n###### Source0事件源主要包括原始指针事件、手势事件、`performSelector:onThread:`等事件，这些事件都是我们用代码写的。\n\n###### Source1事件源：\n\nSource1事件源主要包括锁屏、静音、靠近传感器、加速等系统事件，还有基于`Port`的线程间通信事件，这些事件都不是我们用代码写的，是系统发出的。\n\n此外需要注意的是原始指针事件、手势事件也是首先被捕捉为Source1事件来唤醒主线程，然后再包装为Source0事件处理的。\n\n###### Observer：\n\nObserver不是RunLoop的事件源，而是RunLoop的观察者，它主要用来观察RunLoop状态的变化，从而触发回调做一些自定义的处理，比如系统的UI刷新和`autoreleasepool`创建、销毁就是通过Observer观察RunLoop的状态实现的。RunLoop的状态有如下几个：\n\n```objectivec\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL << 0), // 即将进入RunLoop\n    kCFRunLoopBeforeTimers  = (1UL << 1), // 线程即将处理Timer事件\n    kCFRunLoopBeforeSources = (1UL << 2), // 线程即将处理Source事件\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 线程即将进入休眠\n    kCFRunLoopAfterWaiting  = (1UL << 6), // 线程被唤醒\n    kCFRunLoopExit          = (1UL << 7), // 刚刚退出RunLoop\n};\n```\n\n- UI刷新\n\n  App一启动，系统就会添加一个Observer，监听主线程对应的RunLoop，主要负责UI刷新。这个Observer监听的是“线程即将进入休眠”和“刚刚退出RunLoop”两个状态，它的回调里才是真正的刷新UI。也就是说我们编写的UI代码，如设置了view的frame、设置view的背景色等，并不是执行到那一行代码时就立即刷新生效，而是RunLoop的线程即将进入休眠或者刚刚退出退出RunLoop时才刷新生效的。\n\n- `autoreleasepool`的创建和销毁\n\n  App一启动，系统就会添加两个Observer，监听主线程对应的RunLoop，主要负责`autoreleasepool`的创建和销毁。第一个Observer监听的是“即将进入RunLoop”状态，它的回调里会创建一个`autoreleasepool`，这个Observer的优先级最高，以此保证`autoreleasepool`发生在其他所有回调之前，这样我们项目里的`autorelease`对象就可以放在这个`autoreleasepool`里面了。第二个Obsever监听的是“线程即将进入休眠”和“刚刚退出RunLoop”两个状态，“线程即将进入休眠”时，它的回调里会销毁`autoreleasepool`，这个Obsever的优先级最低，以此保证销毁`autoreleasepool`发生在其他所有回调之后，这样我们项目里的`autorelease`对象就可以顺利执行一次`release`操作使得引用计数-1。简单说，我们可以把线程的唤醒做事到线程休眠看作是一次RunLoop循环，App运行过程中会有无数次的RunLoop循环，每一次的RunLoop循环开始时系统都会创建一个`autoreleasepool`，并把这一次的`autorelease`对象都放进去，然后等这一次RunLoop循环结束时统一让`autorelease`对象的引用计数-1。\n\n###### Timer事件源:\n\nTimer事件源主要包括`NSTimer`、`CADisplayLink`、`performSelector:afterDelay:`等定时器触发的事件，这些事件也都是我们用代码写的。\n\n- `NSTimer`\n\n  我们都知道`NSTimer`是基于RunLoop实现的，所以我们得把`NSTimer`添加到RunLoop中它才会工作，那`NSTimer`是怎么基于RunLoop实现的呢？也就是说`NSTimer`的工作原理是怎么样的呢？我们在创建`NSTimer`的时候都会给一个时间间隔（多久触发一次定时器的回调），那么当我们把`NSTimer`添加到RunLoop后，RunLoop内部的处理是每执行一次`do...while`循环就记录下本次循环用了多长时间，然后累加上之前的时间，如果时间大于等于我们设置的时间间隔，就调用一下定时器的回调，否则不调用。比如说我们设置了`NSTimer`每搁1秒钟调用一次回调，假设RunLoop第一次`do-while`循环任务量较少（因为RunLoop不是专门用来处理定时器的，它还有Source0、Source1等很多事件需要处理，这些事件有可能很简单也有可能很繁重）只用了0.2s，第二次`do-while`循环用了0.3s，第三次`do-while`循环也用了0.3s，此时累计用了0.8s，第一次`do-while`循环任务量较多用了0.5s，那累计就是1.3s，也就是1.3s后才触发了定时器的回调，并不是1s，这也就是为什么我们说`NSTimer`有可能不准，所以要想定时器非常准时可以使用GCD定时器，GCD定时器是跟系统内核挂钩的，不依赖于RunLoop，所以非常准时，所以建议能用GCD定时器尽量用GCD定时器。\n\n- `CADisplayLink`\n\n  `CADisplayLink`和`NSTimer`的工作原理基本是一样的，只不过`CADisplayLink`的调用频率和屏幕的刷新频率一样，每1/60秒调用一次。\n\n- `performSelector:afterDelay:`\n\n  `performSelector:afterDelay:`，内部其实就是创建了一个`NSTimer`并添加到当前线程的RunLoop中。\n\n### 三、RunLoop的运行流程\n\nRunLoop的运行流程大概如下图：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200.png)\n\nRunLoop的运行流程大概如下伪代码：\n\n```objectivec\n// 选择DefaultMode进入RunLoop，\n// \n// App一启动，会走main函数，\n// main函数里面会调用UIApplicationMain函数，\n// UIApplicationMain函数里面就调用该函数获取并启动了主线程对应的RunLoop。\nvoid CFRunLoopRun() {\n    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10);\n}\n\n// 选择指定的Mode进入RunLoop，也可以指定RunLoop的超时时间\n// \n// 切换Mode时，系统就会调用这个方法来重新进入RunLoop\nint CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds) {\n    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds);\n}\n\n\nint CFRunLoopRunSpecific(runloop, modeName, seconds) {\n   \n    // 先根据modeName去查找Mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName);\n    // 如果Mode里没有Source0/Source1/Observer/Timer，则直接返回，不进入RunLoop\n    if (__CFRunLoopModeIsEmpty(currentMode)) return;\n\n    \n    // 1、通知Observers：即将进入RunLoop\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n    __CFRunLoopRun(runloop, currentMode, seconds) {\n        \n        int retVal = 0;\n        do { // do...while循环\n            // 2、通知Observers：线程即将处理Timer事件\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n            // 3、通知Observers：线程即将处理Source事件\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);\n            \n            \n            // 4、处理Source0事件\n            __CFRunLoopDoSources0(runloop, currentMode);\n            // 5、判断有没有Source1事件\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg)) {\n                \n                // 如果有，就跳转到handle_msg去处理\n                goto handle_msg;\n            }\n            \n            \n            // 6、如果Source0事件处理完了、而且没有Source1事件，Timer事件的时间点还没到，则通知Observers：线程即将进入休眠\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n            // 7、线程休眠，等待被唤醒，这里是利用内核函数mach_msg实现的。线程进入休眠后，切换到内核态，会卡死在这个地方，因为线程不做任何事情，不占用任何CPU资源，仅仅是等待着被唤醒\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy) {\n                mach_msg(msg, MACH_RCV_MSG, port);\n            }\n    \n            \n            // 8、通知Observers：线程被唤醒，切换到用户态\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n\n            \n        handle_msg: // 9、处理唤醒事件\n            if (msg_is_timer) { // 如果是被Timer事件唤醒的\n                \n                // 则处理Timer事件\n                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n            } else if (msg_is_dispatch) { // 如果是被GCD dispatch到主线程的事件唤醒的\n                \n                // 则处理GCD dispatch到主线程的事件\n                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            } else { // 如果是被Source1事件唤醒的\n                \n                // 则处理Source1事件\n                __CFRunLoopDoSource1(runloop, currentMode, source1, msg);\n            }\n            \n            // 10、根据前面的执行结果，决定如何操作\n            if (timeout) { // 如果RunLoop对应线程的休眠时间超过了超时时间\n                \n                // 则退出RunLoop\n                retVal = kCFRunLoopRunTimedOut;\n            } else if (__CFRunLoopIsStopped(runloop)) { // 如果RunLoop被强行终止了\n                \n                // 则退出RunLoop\n                retVal = kCFRunLoopRunStopped;\n            } if (__CFRunLoopModeIsEmpty(runloop, currentMode, previousMode)) { // 如果RunLoop当前Mode里没有Source0/Source1/Observer/Timer了\n                \n                // 则退出RunLoop\n                retVal = kCFRunLoopRunFinished;\n            }\n\n            // 如果RunLoop没超时，也没被强行终止，当前Mode里也没空，则继续RunLoop\n        } while (0 == retVal);\n    }\n    \n    // 11、通知Observers：刚刚退出RunLoop\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopExit);\n    \n    return retVal;\n}\n```\n\n比如说有这样一个问题：App启动、App运行过程中点击屏幕、App杀死，这个过程系统都发生了什么？\n\nApp 启动后，当走到`main`函数时，会调用`UIApplicationMain`函数，`UIApplicationMain`函数里面就会获取并启动主线程里面的RunLoop；当主线程处理完一件事后，没事做了就会进入休眠状态，而一旦我们点击屏幕。系统就会捕捉到这个事件为Source1事件来唤醒主线程，并把事件包装为Source0事件处理；之后App杀死，主线程销毁，主线程对应的RunLoop也就销毁了。（当然也可以结合事件传递和响应来分析）\n\n### 四、RunLoop的实际应用\n\n##### 1、处理NSTimer不工作的问题\n\nTimer有两种创建方式，一种是`timerWithXXX`，一种是`scheduledWithXXX`。它们的区别是：**`timerWithXXX`只会创建一个Timer，不会把Timer添加到RunLoop中；`scheduledWithXXX`不仅会创建一个Timer，还会把Timer添加到RunLoop中，而且是添加到了`DefaultMode`下。**所以如果你发现Timer不工作，首先看看是不是用了`timerWithXXX`的创建方式，如果是，那么你可以手动把Timer添加到RunLoop中，或者换成`scheduledWithXXX`的创建方式。\n\n```objectivec\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block;\n\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block;\n```\n\n所以如果你发现Timer不工作，首先看看是不是用了`timerWithXXX`的创建方式，如果是，那么你可以手动把Timer添加到RunLoop中，或者换成`scheduledWithXXX`的创建方式。\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 不工作\n    static int count = 0;\n    NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        NSLog(@\"%d\", count++);\n    }];\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 工作\n    static int count = 0;\n    NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        NSLog(@\"%d\", count++);\n    }];\n    // 把Timer添加到RunLoop中\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:(NSDefaultRunLoopMode)];\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 工作\n    static int count = 0;\n    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        NSLog(@\"%d\", count++);\n    }];\n}\n```\n\n如果你发现Timer仅仅是在界面滑动时不工作，那么你可以把Timer添加到`CommonModes`下，因为Timer默认是被添加到`DefaultMode`下，所以在`TrackingMode`下不工作。\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 界面滑动和不滑动时，都可以工作\n    static int count = 0;\n    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        NSLog(@\"%d\", count++);\n    }];\n    // 添加到CommonModes下\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:(NSRunLoopCommonModes)];\n}\n```\n\n如果你是在子线程中使用Timer，Timer默认是不工作的，因为子线程的RunLoop没有启动，虽然已经创建了（把Timer添加到RunLoop时系统会创建），因此我们需要手动启动一下RunLoop。\n\n```objectivec\n// 不工作\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        \n        // 用scheduledWithXXX创建定时器时，不仅会创建一个Timer，还会把Timer添加到RunLoop中，所以这个方法里获取了子线程的RunLoop了，也就是说子线程的RunLoop被创建了，就差启动\n        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n            \n            NSLog(@\"11\");\n        }];\n    });\n}\n\n\n// 工作\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        \n        // 用scheduledWithXXX创建定时器时，不仅会创建一个Timer，还会把Timer添加到RunLoop中，所以这个方法里获取了子线程的RunLoop了，也就是说子线程的RunLoop被创建了，就差启动\n        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n            \n            NSLog(@\"11\");\n        }];\n        \n        // 手动启用一下子线程的RunLoop\n        [[NSRunLoop currentRunLoop] run];\n    });\n}\n```\n\n#### 2、常驻线程\n\n`AFNetworking`里就创建了一个子线程，并且让这个子线程一直活着，将来在某一刻时刻需要这个子线程做事情的时候就告诉它做事情。这样做的好处就是当你需要经常在子线程里做事情的时候可以节省线程的创建和销毁开销，如果你做完一个任务就销毁一个线程，做下一个任务又创建一个线程，做完又销毁，那这个过程是非常耗性能的，所以不如干脆让一个子线程一直存在于内存中。\n\n我们知道**线程一执行完任务，它的生命周期就结束了，生命周期一结束，这个线程就无法再使用了，即便它还存在于内存中，但它已经不能做事情了。**所以我们说的**常驻线程其实是指保住线程的生命周期，不让它结束，而不是保住线程一直存在于内存中，**要想保住线程一直存在于内存中很简单啊，用强指针就可以了，而要想保住线程的生命周期就不能让线程执行完它的任务，那咱们任务里添加个`while(1)`死循环吧，可以是可以，但是这太占用CPU资源了吧，所以我们可以**用RunLoop来实现常驻线程，**即：\n\n- **获取（即创建）子线程的RunLoop**\n- **往RunLoop中添加一个Source或Observer或Timer（通常我们选择添加Source，其它两个太重了犯不着），以保证RunLoop不会因没有Source、Observer、Timer而退出**\n- **启动RunLoop**\n- **而如果想要结束常驻线程，则可以在适当的时机移除掉RunLoop里的Source**\n\n```objectivec\n@interface ViewController ()\n\n@property (nonatomic, strong) NSThread *thread;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 创建一个线程并启动\n    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadAction) object:nil];\n    [self.thread start];\n}\n\n- (void)threadAction {\n    \n    NSLog(@\"threadAction：%@\", [NSThread currentThread]);\n\n    // 获取（即创建）子线程的RunLoop\n    // 往RunLoop中添加一个Source或Observer或Timer（通常我们选择添加Source，其它两个太重了犯不着），以保证RunLoop不会因没有Source、Observer、Timer而退出\n    [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n    // 启动RunLoop\n    [[NSRunLoop currentRunLoop] run];\n}\n\n@end\n```\n\n```objectivec\n// 假设我们要在点击屏幕的时候停掉线程\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    // 千万不能直接这样移除，因为这样[NSRunLoop currentRunLoop]获取的是主线程的RunLoop，而不是子线程的RnuLoop\n//    [[NSRunLoop currentRunLoop] removePort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n    \n    // 一定要在子线程self.thread里移除\n    [self performSelector:@selector(removePort) onThread:self.thread withObject:nil waitUntilDone:YES];\n}\n\n- (void)removePort {\n    // 适当的时机，移除掉RunLoop里的Source，RunLoop就可以顺利退出，线程就会结束生命周期，进而线程销毁时，对应的RunLoop也销毁\n    [[NSRunLoop currentRunLoop] removePort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n}\n```\n\n","source":"_posts/RunLoop.md","raw":"---\ntitle: RunLoop\ndate: 2021-07-10 19:11:38\ntags: RunLoop\n---\n\n> 一、RunLoop是什么\n>\n> 二、RunLoop的底层实现\n>\n> ​\t\t1、RunLoop和线程是什么关系\n>\n> ​\t\t2、RunLoop的运行模式\n>\n> ​\t\t3、Source0事件源、Source1事件源、Observer、Timer事件源\n>\n> 三、RunLoop的运行流程\n>\n> 四、RunLoop的实际应用\n>\n> ​\t\t1、处理NSTimer不工作的问题\n>\n> ​\t\t2、常驻线程\n\n<!--more-->\n\n### 一、RunLoop是什么\n\nRunLoop运行循环，它就是一个OC对象，它的主要作用有三个：\n\n**保持App的持续运行**，具体而言，我们的App在启动后就会在`main`函数那里创建并启动主线程对应的RunLoop，这个RunLoop内部维护着一个`do...while`循环，正是因为`do...while`循环的存在，才使得主线程得以保活，即主线程不会执行完任务立即退出，也就是App得以保活，否则App一启动执行完`main`函数就退出了；\n\n- **处理App的各种事件**，具体说，RunLoop内部的`do...while`循环里循环处理着App的各种事件，包括Source0事件、Source1事件、Timer事件；\n- **线程的休眠唤醒则是RunLoop区别于其他语言EventLoop的核心所在，线程没事做就休眠，有事做就唤醒，这样可以节省CPU资源。**\n\n### 二、RunLoop的底层实现\n\nRunLoop是`NSRunLoop`类型的，它的C语言实现为`CFRunLoopRef`，因为[CFRunLoopRef](https://links.jianshu.com/go?to=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2FCF%2F)是开源的，所以接下来我们会从它的源码来看看RunLoop的底层实现。\n\n```objectivec\ntypedef struct __CFRunLoop *CFRunLoopRef;\nstruct __CFRunLoop {\n    pthread_t _pthread; // RunLoop对应的线程\n\n    CFMutableSetRef _modes; // RunLoop所有的运行模式\n    CFRunLoopModeRef _currentMode; // RunLoop当前的运行模式\n\n    CFMutableSetRef _commonModes; // RunLoop“特殊的运行模式”\n    CFMutableSetRef _commonModeItems; // RunLoop“特殊的运行模式“里的items\n};\n\ntypedef struct __CFRunLoopMode *CFRunLoopModeRef;\nstruct __CFRunLoopMode {\n    CFStringRef _name; // 运行模式的名字，如@\"NSDefaultRunLoopMode\"、@\"UITrackingRunLoopMode\"\n    CFMutableSetRef _sources0; // Set，Source0事件源集合\n    CFMutableSetRef _sources1; // Set，Source1事件源集合\n    CFMutableArrayRef _observers; // Array，观察者数组\n    CFMutableArrayRef _timers; // Array，Timer事件源数组\n};\n```\n\n#### 1、RunLoop和线程的关系\n\n苹果并没有为我们提供创建RunLoop的API，仅仅提供了获取RunLoop的API。\n\n```objectivec\n// Core Foundation框架\nCFRunLoopGetMain(); // 获取主线程对应的RunLoop\nCFRunLoopGetCurrent(); // 获取当前线程对应的RunLoop\n\n// Foundation框架，对Core Foundation框架函数的封装\n[NSRunLoop mainRunLoop]; // 获取主线程对应的RunLoop\n[NSRunLoop currentRunLoop]; // 获取当前线程对应的RunLoop\n```\n\n这两套API的底层实现大概如下（伪代码，详见`CFRunLoop.c`文件）：\n\n```objectivec\nCFRunLoopRef CFRunLoopGetMain() {\n    return _CFRunLoopGet(pthread_main_thread_np());\n}\n \nCFRunLoopRef CFRunLoopGetCurrent() {\n    return _CFRunLoopGet(pthread_self());\n}\n\n\n// 一个全局的字典，线程是key，RunLoop是value\nstatic CFMutableDictionaryRef __CFRunLoops;\n\nCFRunLoopRef _CFRunLoopGet(pthread_t thread) {\n    \n    if (!__CFRunLoops) { // 如果是第一次获取RunLoop（那肯定是获取主线程对应的RunLoop，因为App一启动系统就会自动去获取主线程对应的RunLoop，我们自己写的获取且早着呢）\n\n        // 初始化全局的字典\n        __CFRunLoops = CFDictionaryCreateMutable();\n        \n        // 创建主线程对应的RunLoop\n        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());\n        // 主线程为key，主线程对应的RunLoop为value，存入全局的字典里\n        CFDictionarySetValue(dict, pthread_main_thread_np(), mainLoop);\n    }\n    \n    // 从全局的字典里读取某个线程对应的RunLoop\n    CFRunLoopRef loop = CFDictionaryGetValue(__CFRunLoops, thread);\n    \n    if (!loop) { // 如果读取不到\n        \n        // 创建该线程对应的RunLoop，\n        loop = __CFRunLoopCreate(thread);\n        // 该线程为key，该线程对应的RunLoop为value，存入全局的字典里\n        CFDictionarySetValue(__CFRunLoops, thread, loop);\n    }\n\n    // 注册一个回调，当某个线程销毁时，也销毁该线程对应的RunLoop\n    _CFSetTSD(thread, loop, __CFFinalizeRunLoop);\n\n    return loop;\n}\n```\n\n> - RunLoop是基于线程来管理的，他们是一一对应的关系，共同存在于一个全局的字典里，线程是`key`，RunLoop是`value`；\n> - 对于主线程的RunLoop来说，App一启动系统就会自动创建并启动，而对子线程的RunLoop来说，除非我们主动去获取，否则不会创建，我们获取也就是创建子线程的RunLoop后，还需要手动启动它；\n> - RunLoop的销毁发生在线程销毁时。\n\n#### 2、RunLoop的运行模式\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1140.png)\n\n> - **系统为RunLoop提供了好几种运行模式，其中`NSDefaultRunLoopMode`和`UITrackingRunLoopMode`是我们经常使用的。`NSDefaultRunLoopMode`是RunLoop默认的运行模式，大多数时候RunLoop就运行在这种模式下，`UITrackingRunLoopMode`是界面滑动时RunLoop的运行模式，系统会自动完成不同情况下这两种运行模式的切换；**\n> - **当然RunLoop还有一种“特殊的运行模式”，就是`NSRunLoopCommonModes`，严格来说它不是一种运行模式，而是一些运行模式的组合。比如说系统会默认把`NSDefaultRunLoopMode`和`UITrackingRunLoopMode`添加到`NSRunLoopCommonModes`里，RunLoop运行在`NSRunLoopCommonModes`模式时，并不是说它就真得运行在`NSRunLoopCommonModes`下，而是说RunLoop在切换真正的运行模式时会自动把一个运行模式里面的Source0/Source1/Observer/Timer同步到另一个运行模式里；**\n> - **一个RunLoop可以有多个运行模式，而每个运行模式里又可以有多个Source0/Source1/Observer/Timer，但是RunLoop一次只能运行在一个运行模式下，这个运行模式被称为CurrentMode，如果要切换运行模式，就得退出RunLoop，重新选择一个运行模式运行。RunLoop分Mode的目的就是为了把不同Mode里的Source0/Source1/Observer/Timer给隔离开来，在这个模式下的时候就做专心做这个模式里的事，在那个模式下的时候就专心做那个模式里的事，让它们互相不影响，当然如果你想一件事能在多个模式下做，那就把它扔到`CommonModes`下。**\n\n#### 3、Source0事件源、Source1事件源、Observer、Timer事件源\n\n###### Source0事件源：\n\n###### Source0事件源主要包括原始指针事件、手势事件、`performSelector:onThread:`等事件，这些事件都是我们用代码写的。\n\n###### Source1事件源：\n\nSource1事件源主要包括锁屏、静音、靠近传感器、加速等系统事件，还有基于`Port`的线程间通信事件，这些事件都不是我们用代码写的，是系统发出的。\n\n此外需要注意的是原始指针事件、手势事件也是首先被捕捉为Source1事件来唤醒主线程，然后再包装为Source0事件处理的。\n\n###### Observer：\n\nObserver不是RunLoop的事件源，而是RunLoop的观察者，它主要用来观察RunLoop状态的变化，从而触发回调做一些自定义的处理，比如系统的UI刷新和`autoreleasepool`创建、销毁就是通过Observer观察RunLoop的状态实现的。RunLoop的状态有如下几个：\n\n```objectivec\ntypedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {\n    kCFRunLoopEntry         = (1UL << 0), // 即将进入RunLoop\n    kCFRunLoopBeforeTimers  = (1UL << 1), // 线程即将处理Timer事件\n    kCFRunLoopBeforeSources = (1UL << 2), // 线程即将处理Source事件\n    kCFRunLoopBeforeWaiting = (1UL << 5), // 线程即将进入休眠\n    kCFRunLoopAfterWaiting  = (1UL << 6), // 线程被唤醒\n    kCFRunLoopExit          = (1UL << 7), // 刚刚退出RunLoop\n};\n```\n\n- UI刷新\n\n  App一启动，系统就会添加一个Observer，监听主线程对应的RunLoop，主要负责UI刷新。这个Observer监听的是“线程即将进入休眠”和“刚刚退出RunLoop”两个状态，它的回调里才是真正的刷新UI。也就是说我们编写的UI代码，如设置了view的frame、设置view的背景色等，并不是执行到那一行代码时就立即刷新生效，而是RunLoop的线程即将进入休眠或者刚刚退出退出RunLoop时才刷新生效的。\n\n- `autoreleasepool`的创建和销毁\n\n  App一启动，系统就会添加两个Observer，监听主线程对应的RunLoop，主要负责`autoreleasepool`的创建和销毁。第一个Observer监听的是“即将进入RunLoop”状态，它的回调里会创建一个`autoreleasepool`，这个Observer的优先级最高，以此保证`autoreleasepool`发生在其他所有回调之前，这样我们项目里的`autorelease`对象就可以放在这个`autoreleasepool`里面了。第二个Obsever监听的是“线程即将进入休眠”和“刚刚退出RunLoop”两个状态，“线程即将进入休眠”时，它的回调里会销毁`autoreleasepool`，这个Obsever的优先级最低，以此保证销毁`autoreleasepool`发生在其他所有回调之后，这样我们项目里的`autorelease`对象就可以顺利执行一次`release`操作使得引用计数-1。简单说，我们可以把线程的唤醒做事到线程休眠看作是一次RunLoop循环，App运行过程中会有无数次的RunLoop循环，每一次的RunLoop循环开始时系统都会创建一个`autoreleasepool`，并把这一次的`autorelease`对象都放进去，然后等这一次RunLoop循环结束时统一让`autorelease`对象的引用计数-1。\n\n###### Timer事件源:\n\nTimer事件源主要包括`NSTimer`、`CADisplayLink`、`performSelector:afterDelay:`等定时器触发的事件，这些事件也都是我们用代码写的。\n\n- `NSTimer`\n\n  我们都知道`NSTimer`是基于RunLoop实现的，所以我们得把`NSTimer`添加到RunLoop中它才会工作，那`NSTimer`是怎么基于RunLoop实现的呢？也就是说`NSTimer`的工作原理是怎么样的呢？我们在创建`NSTimer`的时候都会给一个时间间隔（多久触发一次定时器的回调），那么当我们把`NSTimer`添加到RunLoop后，RunLoop内部的处理是每执行一次`do...while`循环就记录下本次循环用了多长时间，然后累加上之前的时间，如果时间大于等于我们设置的时间间隔，就调用一下定时器的回调，否则不调用。比如说我们设置了`NSTimer`每搁1秒钟调用一次回调，假设RunLoop第一次`do-while`循环任务量较少（因为RunLoop不是专门用来处理定时器的，它还有Source0、Source1等很多事件需要处理，这些事件有可能很简单也有可能很繁重）只用了0.2s，第二次`do-while`循环用了0.3s，第三次`do-while`循环也用了0.3s，此时累计用了0.8s，第一次`do-while`循环任务量较多用了0.5s，那累计就是1.3s，也就是1.3s后才触发了定时器的回调，并不是1s，这也就是为什么我们说`NSTimer`有可能不准，所以要想定时器非常准时可以使用GCD定时器，GCD定时器是跟系统内核挂钩的，不依赖于RunLoop，所以非常准时，所以建议能用GCD定时器尽量用GCD定时器。\n\n- `CADisplayLink`\n\n  `CADisplayLink`和`NSTimer`的工作原理基本是一样的，只不过`CADisplayLink`的调用频率和屏幕的刷新频率一样，每1/60秒调用一次。\n\n- `performSelector:afterDelay:`\n\n  `performSelector:afterDelay:`，内部其实就是创建了一个`NSTimer`并添加到当前线程的RunLoop中。\n\n### 三、RunLoop的运行流程\n\nRunLoop的运行流程大概如下图：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200.png)\n\nRunLoop的运行流程大概如下伪代码：\n\n```objectivec\n// 选择DefaultMode进入RunLoop，\n// \n// App一启动，会走main函数，\n// main函数里面会调用UIApplicationMain函数，\n// UIApplicationMain函数里面就调用该函数获取并启动了主线程对应的RunLoop。\nvoid CFRunLoopRun() {\n    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10);\n}\n\n// 选择指定的Mode进入RunLoop，也可以指定RunLoop的超时时间\n// \n// 切换Mode时，系统就会调用这个方法来重新进入RunLoop\nint CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds) {\n    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds);\n}\n\n\nint CFRunLoopRunSpecific(runloop, modeName, seconds) {\n   \n    // 先根据modeName去查找Mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName);\n    // 如果Mode里没有Source0/Source1/Observer/Timer，则直接返回，不进入RunLoop\n    if (__CFRunLoopModeIsEmpty(currentMode)) return;\n\n    \n    // 1、通知Observers：即将进入RunLoop\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);\n    __CFRunLoopRun(runloop, currentMode, seconds) {\n        \n        int retVal = 0;\n        do { // do...while循环\n            // 2、通知Observers：线程即将处理Timer事件\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);\n            // 3、通知Observers：线程即将处理Source事件\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);\n            \n            \n            // 4、处理Source0事件\n            __CFRunLoopDoSources0(runloop, currentMode);\n            // 5、判断有没有Source1事件\n            if (__CFRunLoopServiceMachPort(dispatchPort, &msg)) {\n                \n                // 如果有，就跳转到handle_msg去处理\n                goto handle_msg;\n            }\n            \n            \n            // 6、如果Source0事件处理完了、而且没有Source1事件，Timer事件的时间点还没到，则通知Observers：线程即将进入休眠\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);\n            // 7、线程休眠，等待被唤醒，这里是利用内核函数mach_msg实现的。线程进入休眠后，切换到内核态，会卡死在这个地方，因为线程不做任何事情，不占用任何CPU资源，仅仅是等待着被唤醒\n            __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy) {\n                mach_msg(msg, MACH_RCV_MSG, port);\n            }\n    \n            \n            // 8、通知Observers：线程被唤醒，切换到用户态\n            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);\n\n            \n        handle_msg: // 9、处理唤醒事件\n            if (msg_is_timer) { // 如果是被Timer事件唤醒的\n                \n                // 则处理Timer事件\n                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())\n            } else if (msg_is_dispatch) { // 如果是被GCD dispatch到主线程的事件唤醒的\n                \n                // 则处理GCD dispatch到主线程的事件\n                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);\n            } else { // 如果是被Source1事件唤醒的\n                \n                // 则处理Source1事件\n                __CFRunLoopDoSource1(runloop, currentMode, source1, msg);\n            }\n            \n            // 10、根据前面的执行结果，决定如何操作\n            if (timeout) { // 如果RunLoop对应线程的休眠时间超过了超时时间\n                \n                // 则退出RunLoop\n                retVal = kCFRunLoopRunTimedOut;\n            } else if (__CFRunLoopIsStopped(runloop)) { // 如果RunLoop被强行终止了\n                \n                // 则退出RunLoop\n                retVal = kCFRunLoopRunStopped;\n            } if (__CFRunLoopModeIsEmpty(runloop, currentMode, previousMode)) { // 如果RunLoop当前Mode里没有Source0/Source1/Observer/Timer了\n                \n                // 则退出RunLoop\n                retVal = kCFRunLoopRunFinished;\n            }\n\n            // 如果RunLoop没超时，也没被强行终止，当前Mode里也没空，则继续RunLoop\n        } while (0 == retVal);\n    }\n    \n    // 11、通知Observers：刚刚退出RunLoop\n    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopExit);\n    \n    return retVal;\n}\n```\n\n比如说有这样一个问题：App启动、App运行过程中点击屏幕、App杀死，这个过程系统都发生了什么？\n\nApp 启动后，当走到`main`函数时，会调用`UIApplicationMain`函数，`UIApplicationMain`函数里面就会获取并启动主线程里面的RunLoop；当主线程处理完一件事后，没事做了就会进入休眠状态，而一旦我们点击屏幕。系统就会捕捉到这个事件为Source1事件来唤醒主线程，并把事件包装为Source0事件处理；之后App杀死，主线程销毁，主线程对应的RunLoop也就销毁了。（当然也可以结合事件传递和响应来分析）\n\n### 四、RunLoop的实际应用\n\n##### 1、处理NSTimer不工作的问题\n\nTimer有两种创建方式，一种是`timerWithXXX`，一种是`scheduledWithXXX`。它们的区别是：**`timerWithXXX`只会创建一个Timer，不会把Timer添加到RunLoop中；`scheduledWithXXX`不仅会创建一个Timer，还会把Timer添加到RunLoop中，而且是添加到了`DefaultMode`下。**所以如果你发现Timer不工作，首先看看是不是用了`timerWithXXX`的创建方式，如果是，那么你可以手动把Timer添加到RunLoop中，或者换成`scheduledWithXXX`的创建方式。\n\n```objectivec\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block;\n\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;\n+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block;\n```\n\n所以如果你发现Timer不工作，首先看看是不是用了`timerWithXXX`的创建方式，如果是，那么你可以手动把Timer添加到RunLoop中，或者换成`scheduledWithXXX`的创建方式。\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 不工作\n    static int count = 0;\n    NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        NSLog(@\"%d\", count++);\n    }];\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 工作\n    static int count = 0;\n    NSTimer *timer = [NSTimer timerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        NSLog(@\"%d\", count++);\n    }];\n    // 把Timer添加到RunLoop中\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:(NSDefaultRunLoopMode)];\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 工作\n    static int count = 0;\n    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        NSLog(@\"%d\", count++);\n    }];\n}\n```\n\n如果你发现Timer仅仅是在界面滑动时不工作，那么你可以把Timer添加到`CommonModes`下，因为Timer默认是被添加到`DefaultMode`下，所以在`TrackingMode`下不工作。\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 界面滑动和不滑动时，都可以工作\n    static int count = 0;\n    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        NSLog(@\"%d\", count++);\n    }];\n    // 添加到CommonModes下\n    [[NSRunLoop currentRunLoop] addTimer:timer forMode:(NSRunLoopCommonModes)];\n}\n```\n\n如果你是在子线程中使用Timer，Timer默认是不工作的，因为子线程的RunLoop没有启动，虽然已经创建了（把Timer添加到RunLoop时系统会创建），因此我们需要手动启动一下RunLoop。\n\n```objectivec\n// 不工作\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        \n        // 用scheduledWithXXX创建定时器时，不仅会创建一个Timer，还会把Timer添加到RunLoop中，所以这个方法里获取了子线程的RunLoop了，也就是说子线程的RunLoop被创建了，就差启动\n        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n            \n            NSLog(@\"11\");\n        }];\n    });\n}\n\n\n// 工作\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        \n        // 用scheduledWithXXX创建定时器时，不仅会创建一个Timer，还会把Timer添加到RunLoop中，所以这个方法里获取了子线程的RunLoop了，也就是说子线程的RunLoop被创建了，就差启动\n        [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n            \n            NSLog(@\"11\");\n        }];\n        \n        // 手动启用一下子线程的RunLoop\n        [[NSRunLoop currentRunLoop] run];\n    });\n}\n```\n\n#### 2、常驻线程\n\n`AFNetworking`里就创建了一个子线程，并且让这个子线程一直活着，将来在某一刻时刻需要这个子线程做事情的时候就告诉它做事情。这样做的好处就是当你需要经常在子线程里做事情的时候可以节省线程的创建和销毁开销，如果你做完一个任务就销毁一个线程，做下一个任务又创建一个线程，做完又销毁，那这个过程是非常耗性能的，所以不如干脆让一个子线程一直存在于内存中。\n\n我们知道**线程一执行完任务，它的生命周期就结束了，生命周期一结束，这个线程就无法再使用了，即便它还存在于内存中，但它已经不能做事情了。**所以我们说的**常驻线程其实是指保住线程的生命周期，不让它结束，而不是保住线程一直存在于内存中，**要想保住线程一直存在于内存中很简单啊，用强指针就可以了，而要想保住线程的生命周期就不能让线程执行完它的任务，那咱们任务里添加个`while(1)`死循环吧，可以是可以，但是这太占用CPU资源了吧，所以我们可以**用RunLoop来实现常驻线程，**即：\n\n- **获取（即创建）子线程的RunLoop**\n- **往RunLoop中添加一个Source或Observer或Timer（通常我们选择添加Source，其它两个太重了犯不着），以保证RunLoop不会因没有Source、Observer、Timer而退出**\n- **启动RunLoop**\n- **而如果想要结束常驻线程，则可以在适当的时机移除掉RunLoop里的Source**\n\n```objectivec\n@interface ViewController ()\n\n@property (nonatomic, strong) NSThread *thread;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    // 创建一个线程并启动\n    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadAction) object:nil];\n    [self.thread start];\n}\n\n- (void)threadAction {\n    \n    NSLog(@\"threadAction：%@\", [NSThread currentThread]);\n\n    // 获取（即创建）子线程的RunLoop\n    // 往RunLoop中添加一个Source或Observer或Timer（通常我们选择添加Source，其它两个太重了犯不着），以保证RunLoop不会因没有Source、Observer、Timer而退出\n    [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n    // 启动RunLoop\n    [[NSRunLoop currentRunLoop] run];\n}\n\n@end\n```\n\n```objectivec\n// 假设我们要在点击屏幕的时候停掉线程\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    // 千万不能直接这样移除，因为这样[NSRunLoop currentRunLoop]获取的是主线程的RunLoop，而不是子线程的RnuLoop\n//    [[NSRunLoop currentRunLoop] removePort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n    \n    // 一定要在子线程self.thread里移除\n    [self performSelector:@selector(removePort) onThread:self.thread withObject:nil waitUntilDone:YES];\n}\n\n- (void)removePort {\n    // 适当的时机，移除掉RunLoop里的Source，RunLoop就可以顺利退出，线程就会结束生命周期，进而线程销毁时，对应的RunLoop也销毁\n    [[NSRunLoop currentRunLoop] removePort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n}\n```\n\n","slug":"RunLoop","published":1,"updated":"2022-07-17T03:05:41.748Z","_id":"cl5g66h3j0000ed2rhi1k2wow","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>一、RunLoop是什么</p>\n<p>二、RunLoop的底层实现</p>\n<p>​        1、RunLoop和线程是什么关系</p>\n<p>​        2、RunLoop的运行模式</p>\n<p>​        3、Source0事件源、Source1事件源、Observer、Timer事件源</p>\n<p>三、RunLoop的运行流程</p>\n<p>四、RunLoop的实际应用</p>\n<p>​        1、处理NSTimer不工作的问题</p>\n<p>​        2、常驻线程</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3 id=\"一、RunLoop是什么\"><a href=\"#一、RunLoop是什么\" class=\"headerlink\" title=\"一、RunLoop是什么\"></a>一、RunLoop是什么</h3><p>RunLoop运行循环，它就是一个OC对象，它的主要作用有三个：</p>\n<p><strong>保持App的持续运行</strong>，具体而言，我们的App在启动后就会在<code>main</code>函数那里创建并启动主线程对应的RunLoop，这个RunLoop内部维护着一个<code>do...while</code>循环，正是因为<code>do...while</code>循环的存在，才使得主线程得以保活，即主线程不会执行完任务立即退出，也就是App得以保活，否则App一启动执行完<code>main</code>函数就退出了；</p>\n<ul>\n<li><strong>处理App的各种事件</strong>，具体说，RunLoop内部的<code>do...while</code>循环里循环处理着App的各种事件，包括Source0事件、Source1事件、Timer事件；</li>\n<li><strong>线程的休眠唤醒则是RunLoop区别于其他语言EventLoop的核心所在，线程没事做就休眠，有事做就唤醒，这样可以节省CPU资源。</strong></li>\n</ul>\n<h3 id=\"二、RunLoop的底层实现\"><a href=\"#二、RunLoop的底层实现\" class=\"headerlink\" title=\"二、RunLoop的底层实现\"></a>二、RunLoop的底层实现</h3><p>RunLoop是<code>NSRunLoop</code>类型的，它的C语言实现为<code>CFRunLoopRef</code>，因为<a href=\"https://links.jianshu.com/go?to=https://opensource.apple.com/tarballs/CF/\">CFRunLoopRef</a>是开源的，所以接下来我们会从它的源码来看看RunLoop的底层实现。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> __CFRunLoop *<span class=\"built_in\">CFRunLoopRef</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    pthread_t _pthread; <span class=\"comment\">// RunLoop对应的线程</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes; <span class=\"comment\">// RunLoop所有的运行模式</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode; <span class=\"comment\">// RunLoop当前的运行模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes; <span class=\"comment\">// RunLoop“特殊的运行模式”</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// RunLoop“特殊的运行模式“里的items</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> __CFRunLoopMode *<span class=\"built_in\">CFRunLoopModeRef</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name; <span class=\"comment\">// 运行模式的名字，如@&quot;NSDefaultRunLoopMode&quot;、@&quot;UITrackingRunLoopMode&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0; <span class=\"comment\">// Set，Source0事件源集合</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1; <span class=\"comment\">// Set，Source1事件源集合</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array，观察者数组</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers; <span class=\"comment\">// Array，Timer事件源数组</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1、RunLoop和线程的关系\"><a href=\"#1、RunLoop和线程的关系\" class=\"headerlink\" title=\"1、RunLoop和线程的关系\"></a>1、RunLoop和线程的关系</h4><p>苹果并没有为我们提供创建RunLoop的API，仅仅提供了获取RunLoop的API。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Core Foundation框架</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopGetMain</span>(); <span class=\"comment\">// 获取主线程对应的RunLoop</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopGetCurrent</span>(); <span class=\"comment\">// 获取当前线程对应的RunLoop</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foundation框架，对Core Foundation框架函数的封装</span></span><br><span class=\"line\">[<span class=\"built_in\">NSRunLoop</span> mainRunLoop]; <span class=\"comment\">// 获取主线程对应的RunLoop</span></span><br><span class=\"line\">[<span class=\"built_in\">NSRunLoop</span> currentRunLoop]; <span class=\"comment\">// 获取当前线程对应的RunLoop</span></span><br></pre></td></tr></table></figure>\n\n<p>这两套API的底层实现大概如下（伪代码，详见<code>CFRunLoop.c</code>文件）：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetMain</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetCurrent</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_self());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个全局的字典，线程是key，RunLoop是value</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFMutableDictionaryRef</span> __CFRunLoops;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__CFRunLoops) &#123; <span class=\"comment\">// 如果是第一次获取RunLoop（那肯定是获取主线程对应的RunLoop，因为App一启动系统就会自动去获取主线程对应的RunLoop，我们自己写的获取且早着呢）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化全局的字典</span></span><br><span class=\"line\">        __CFRunLoops = <span class=\"built_in\">CFDictionaryCreateMutable</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 创建主线程对应的RunLoop</span></span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class=\"line\">        <span class=\"comment\">// 主线程为key，主线程对应的RunLoop为value，存入全局的字典里</span></span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(dict, pthread_main_thread_np(), mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从全局的字典里读取某个线程对应的RunLoop</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> loop = <span class=\"built_in\">CFDictionaryGetValue</span>(__CFRunLoops, thread);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123; <span class=\"comment\">// 如果读取不到</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 创建该线程对应的RunLoop，</span></span><br><span class=\"line\">        loop = __CFRunLoopCreate(thread);</span><br><span class=\"line\">        <span class=\"comment\">// 该线程为key，该线程对应的RunLoop为value，存入全局的字典里</span></span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(__CFRunLoops, thread, loop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注册一个回调，当某个线程销毁时，也销毁该线程对应的RunLoop</span></span><br><span class=\"line\">    _CFSetTSD(thread, loop, __CFFinalizeRunLoop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>RunLoop是基于线程来管理的，他们是一一对应的关系，共同存在于一个全局的字典里，线程是<code>key</code>，RunLoop是<code>value</code>；</li>\n<li>对于主线程的RunLoop来说，App一启动系统就会自动创建并启动，而对子线程的RunLoop来说，除非我们主动去获取，否则不会创建，我们获取也就是创建子线程的RunLoop后，还需要手动启动它；</li>\n<li>RunLoop的销毁发生在线程销毁时。</li>\n</ul>\n</blockquote>\n<h4 id=\"2、RunLoop的运行模式\"><a href=\"#2、RunLoop的运行模式\" class=\"headerlink\" title=\"2、RunLoop的运行模式\"></a>2、RunLoop的运行模式</h4><p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1140.png\" alt=\"img\"></p>\n<blockquote>\n<ul>\n<li><strong>系统为RunLoop提供了好几种运行模式，其中<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>是我们经常使用的。<code>NSDefaultRunLoopMode</code>是RunLoop默认的运行模式，大多数时候RunLoop就运行在这种模式下，<code>UITrackingRunLoopMode</code>是界面滑动时RunLoop的运行模式，系统会自动完成不同情况下这两种运行模式的切换；</strong></li>\n<li><strong>当然RunLoop还有一种“特殊的运行模式”，就是<code>NSRunLoopCommonModes</code>，严格来说它不是一种运行模式，而是一些运行模式的组合。比如说系统会默认把<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>添加到<code>NSRunLoopCommonModes</code>里，RunLoop运行在<code>NSRunLoopCommonModes</code>模式时，并不是说它就真得运行在<code>NSRunLoopCommonModes</code>下，而是说RunLoop在切换真正的运行模式时会自动把一个运行模式里面的Source0/Source1/Observer/Timer同步到另一个运行模式里；</strong></li>\n<li><strong>一个RunLoop可以有多个运行模式，而每个运行模式里又可以有多个Source0/Source1/Observer/Timer，但是RunLoop一次只能运行在一个运行模式下，这个运行模式被称为CurrentMode，如果要切换运行模式，就得退出RunLoop，重新选择一个运行模式运行。RunLoop分Mode的目的就是为了把不同Mode里的Source0/Source1/Observer/Timer给隔离开来，在这个模式下的时候就做专心做这个模式里的事，在那个模式下的时候就专心做那个模式里的事，让它们互相不影响，当然如果你想一件事能在多个模式下做，那就把它扔到<code>CommonModes</code>下。</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"3、Source0事件源、Source1事件源、Observer、Timer事件源\"><a href=\"#3、Source0事件源、Source1事件源、Observer、Timer事件源\" class=\"headerlink\" title=\"3、Source0事件源、Source1事件源、Observer、Timer事件源\"></a>3、Source0事件源、Source1事件源、Observer、Timer事件源</h4><h6 id=\"Source0事件源：\"><a href=\"#Source0事件源：\" class=\"headerlink\" title=\"Source0事件源：\"></a>Source0事件源：</h6><h6 id=\"Source0事件源主要包括原始指针事件、手势事件、performSelector-onThread-等事件，这些事件都是我们用代码写的。\"><a href=\"#Source0事件源主要包括原始指针事件、手势事件、performSelector-onThread-等事件，这些事件都是我们用代码写的。\" class=\"headerlink\" title=\"Source0事件源主要包括原始指针事件、手势事件、performSelector:onThread:等事件，这些事件都是我们用代码写的。\"></a>Source0事件源主要包括原始指针事件、手势事件、<code>performSelector:onThread:</code>等事件，这些事件都是我们用代码写的。</h6><h6 id=\"Source1事件源：\"><a href=\"#Source1事件源：\" class=\"headerlink\" title=\"Source1事件源：\"></a>Source1事件源：</h6><p>Source1事件源主要包括锁屏、静音、靠近传感器、加速等系统事件，还有基于<code>Port</code>的线程间通信事件，这些事件都不是我们用代码写的，是系统发出的。</p>\n<p>此外需要注意的是原始指针事件、手势事件也是首先被捕捉为Source1事件来唤醒主线程，然后再包装为Source0事件处理的。</p>\n<h6 id=\"Observer：\"><a href=\"#Observer：\" class=\"headerlink\" title=\"Observer：\"></a>Observer：</h6><p>Observer不是RunLoop的事件源，而是RunLoop的观察者，它主要用来观察RunLoop状态的变化，从而触发回调做一些自定义的处理，比如系统的UI刷新和<code>autoreleasepool</code>创建、销毁就是通过Observer观察RunLoop的状态实现的。RunLoop的状态有如下几个：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CF_OPTIONS</span>(<span class=\"built_in\">CFOptionFlags</span>, <span class=\"built_in\">CFRunLoopActivity</span>) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>), <span class=\"comment\">// 即将进入RunLoop</span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>), <span class=\"comment\">// 线程即将处理Timer事件</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>), <span class=\"comment\">// 线程即将处理Source事件</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>), <span class=\"comment\">// 线程即将进入休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>), <span class=\"comment\">// 线程被唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit          = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>), <span class=\"comment\">// 刚刚退出RunLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>UI刷新</p>\n<p>App一启动，系统就会添加一个Observer，监听主线程对应的RunLoop，主要负责UI刷新。这个Observer监听的是“线程即将进入休眠”和“刚刚退出RunLoop”两个状态，它的回调里才是真正的刷新UI。也就是说我们编写的UI代码，如设置了view的frame、设置view的背景色等，并不是执行到那一行代码时就立即刷新生效，而是RunLoop的线程即将进入休眠或者刚刚退出退出RunLoop时才刷新生效的。</p>\n</li>\n<li><p><code>autoreleasepool</code>的创建和销毁</p>\n<p>App一启动，系统就会添加两个Observer，监听主线程对应的RunLoop，主要负责<code>autoreleasepool</code>的创建和销毁。第一个Observer监听的是“即将进入RunLoop”状态，它的回调里会创建一个<code>autoreleasepool</code>，这个Observer的优先级最高，以此保证<code>autoreleasepool</code>发生在其他所有回调之前，这样我们项目里的<code>autorelease</code>对象就可以放在这个<code>autoreleasepool</code>里面了。第二个Obsever监听的是“线程即将进入休眠”和“刚刚退出RunLoop”两个状态，“线程即将进入休眠”时，它的回调里会销毁<code>autoreleasepool</code>，这个Obsever的优先级最低，以此保证销毁<code>autoreleasepool</code>发生在其他所有回调之后，这样我们项目里的<code>autorelease</code>对象就可以顺利执行一次<code>release</code>操作使得引用计数-1。简单说，我们可以把线程的唤醒做事到线程休眠看作是一次RunLoop循环，App运行过程中会有无数次的RunLoop循环，每一次的RunLoop循环开始时系统都会创建一个<code>autoreleasepool</code>，并把这一次的<code>autorelease</code>对象都放进去，然后等这一次RunLoop循环结束时统一让<code>autorelease</code>对象的引用计数-1。</p>\n</li>\n</ul>\n<h6 id=\"Timer事件源\"><a href=\"#Timer事件源\" class=\"headerlink\" title=\"Timer事件源:\"></a>Timer事件源:</h6><p>Timer事件源主要包括<code>NSTimer</code>、<code>CADisplayLink</code>、<code>performSelector:afterDelay:</code>等定时器触发的事件，这些事件也都是我们用代码写的。</p>\n<ul>\n<li><p><code>NSTimer</code></p>\n<p>我们都知道<code>NSTimer</code>是基于RunLoop实现的，所以我们得把<code>NSTimer</code>添加到RunLoop中它才会工作，那<code>NSTimer</code>是怎么基于RunLoop实现的呢？也就是说<code>NSTimer</code>的工作原理是怎么样的呢？我们在创建<code>NSTimer</code>的时候都会给一个时间间隔（多久触发一次定时器的回调），那么当我们把<code>NSTimer</code>添加到RunLoop后，RunLoop内部的处理是每执行一次<code>do...while</code>循环就记录下本次循环用了多长时间，然后累加上之前的时间，如果时间大于等于我们设置的时间间隔，就调用一下定时器的回调，否则不调用。比如说我们设置了<code>NSTimer</code>每搁1秒钟调用一次回调，假设RunLoop第一次<code>do-while</code>循环任务量较少（因为RunLoop不是专门用来处理定时器的，它还有Source0、Source1等很多事件需要处理，这些事件有可能很简单也有可能很繁重）只用了0.2s，第二次<code>do-while</code>循环用了0.3s，第三次<code>do-while</code>循环也用了0.3s，此时累计用了0.8s，第一次<code>do-while</code>循环任务量较多用了0.5s，那累计就是1.3s，也就是1.3s后才触发了定时器的回调，并不是1s，这也就是为什么我们说<code>NSTimer</code>有可能不准，所以要想定时器非常准时可以使用GCD定时器，GCD定时器是跟系统内核挂钩的，不依赖于RunLoop，所以非常准时，所以建议能用GCD定时器尽量用GCD定时器。</p>\n</li>\n<li><p><code>CADisplayLink</code></p>\n<p><code>CADisplayLink</code>和<code>NSTimer</code>的工作原理基本是一样的，只不过<code>CADisplayLink</code>的调用频率和屏幕的刷新频率一样，每1/60秒调用一次。</p>\n</li>\n<li><p><code>performSelector:afterDelay:</code></p>\n<p><code>performSelector:afterDelay:</code>，内部其实就是创建了一个<code>NSTimer</code>并添加到当前线程的RunLoop中。</p>\n</li>\n</ul>\n<h3 id=\"三、RunLoop的运行流程\"><a href=\"#三、RunLoop的运行流程\" class=\"headerlink\" title=\"三、RunLoop的运行流程\"></a>三、RunLoop的运行流程</h3><p>RunLoop的运行流程大概如下图：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200.png\" alt=\"img\"></p>\n<p>RunLoop的运行流程大概如下伪代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选择DefaultMode进入RunLoop，</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// App一启动，会走main函数，</span></span><br><span class=\"line\"><span class=\"comment\">// main函数里面会调用UIApplicationMain函数，</span></span><br><span class=\"line\"><span class=\"comment\">// UIApplicationMain函数里面就调用该函数获取并启动了主线程对应的RunLoop。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"built_in\">CFRunLoopRun</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class=\"number\">1.0e10</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选择指定的Mode进入RunLoop，也可以指定RunLoop的超时时间</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 切换Mode时，系统就会调用这个方法来重新进入RunLoop</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"built_in\">CFRunLoopRunInMode</span>(<span class=\"built_in\">CFStringRef</span> modeName, <span class=\"built_in\">CFTimeInterval</span> seconds) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), modeName, seconds);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"built_in\">CFRunLoopRunSpecific</span>(runloop, modeName, seconds) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// 先根据modeName去查找Mode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(runloop, modeName);</span><br><span class=\"line\">    <span class=\"comment\">// 如果Mode里没有Source0/Source1/Observer/Timer，则直接返回，不进入RunLoop</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1、通知Observers：即将进入RunLoop</span></span><br><span class=\"line\">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class=\"line\">    __CFRunLoopRun(runloop, currentMode, seconds) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> retVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123; <span class=\"comment\">// do...while循环</span></span><br><span class=\"line\">            <span class=\"comment\">// 2、通知Observers：线程即将处理Timer事件</span></span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class=\"line\">            <span class=\"comment\">// 3、通知Observers：线程即将处理Source事件</span></span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 4、处理Source0事件</span></span><br><span class=\"line\">            __CFRunLoopDoSources0(runloop, currentMode);</span><br><span class=\"line\">            <span class=\"comment\">// 5、判断有没有Source1事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg)) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 如果有，就跳转到handle_msg去处理</span></span><br><span class=\"line\">                <span class=\"keyword\">goto</span> handle_msg;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 6、如果Source0事件处理完了、而且没有Source1事件，Timer事件的时间点还没到，则通知Observers：线程即将进入休眠</span></span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class=\"line\">            <span class=\"comment\">// 7、线程休眠，等待被唤醒，这里是利用内核函数mach_msg实现的。线程进入休眠后，切换到内核态，会卡死在这个地方，因为线程不做任何事情，不占用任何CPU资源，仅仅是等待着被唤醒</span></span><br><span class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class=\"number\">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy) &#123;</span><br><span class=\"line\">                mach_msg(msg, MACH_RCV_MSG, port);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 8、通知Observers：线程被唤醒，切换到用户态</span></span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class=\"line\"></span><br><span class=\"line\">            </span><br><span class=\"line\">        handle_msg: <span class=\"comment\">// 9、处理唤醒事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg_is_timer) &#123; <span class=\"comment\">// 如果是被Timer事件唤醒的</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则处理Timer事件</span></span><br><span class=\"line\">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (msg_is_dispatch) &#123; <span class=\"comment\">// 如果是被GCD dispatch到主线程的事件唤醒的</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则处理GCD dispatch到主线程的事件</span></span><br><span class=\"line\">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 如果是被Source1事件唤醒的</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则处理Source1事件</span></span><br><span class=\"line\">                __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 10、根据前面的执行结果，决定如何操作</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeout) &#123; <span class=\"comment\">// 如果RunLoop对应线程的休眠时间超过了超时时间</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则退出RunLoop</span></span><br><span class=\"line\">                retVal = kCFRunLoopRunTimedOut;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopIsStopped(runloop)) &#123; <span class=\"comment\">// 如果RunLoop被强行终止了</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则退出RunLoop</span></span><br><span class=\"line\">                retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode, previousMode)) &#123; <span class=\"comment\">// 如果RunLoop当前Mode里没有Source0/Source1/Observer/Timer了</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则退出RunLoop</span></span><br><span class=\"line\">                retVal = kCFRunLoopRunFinished;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果RunLoop没超时，也没被强行终止，当前Mode里也没空，则继续RunLoop</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span> == retVal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 11、通知Observers：刚刚退出RunLoop</span></span><br><span class=\"line\">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopExit);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> retVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如说有这样一个问题：App启动、App运行过程中点击屏幕、App杀死，这个过程系统都发生了什么？</p>\n<p>App 启动后，当走到<code>main</code>函数时，会调用<code>UIApplicationMain</code>函数，<code>UIApplicationMain</code>函数里面就会获取并启动主线程里面的RunLoop；当主线程处理完一件事后，没事做了就会进入休眠状态，而一旦我们点击屏幕。系统就会捕捉到这个事件为Source1事件来唤醒主线程，并把事件包装为Source0事件处理；之后App杀死，主线程销毁，主线程对应的RunLoop也就销毁了。（当然也可以结合事件传递和响应来分析）</p>\n<h3 id=\"四、RunLoop的实际应用\"><a href=\"#四、RunLoop的实际应用\" class=\"headerlink\" title=\"四、RunLoop的实际应用\"></a>四、RunLoop的实际应用</h3><h5 id=\"1、处理NSTimer不工作的问题\"><a href=\"#1、处理NSTimer不工作的问题\" class=\"headerlink\" title=\"1、处理NSTimer不工作的问题\"></a>1、处理NSTimer不工作的问题</h5><p>Timer有两种创建方式，一种是<code>timerWithXXX</code>，一种是<code>scheduledWithXXX</code>。它们的区别是：**<code>timerWithXXX</code>只会创建一个Timer，不会把Timer添加到RunLoop中；<code>scheduledWithXXX</code>不仅会创建一个Timer，还会把Timer添加到RunLoop中，而且是添加到了<code>DefaultMode</code>下。**所以如果你发现Timer不工作，首先看看是不是用了<code>timerWithXXX</code>的创建方式，如果是，那么你可以手动把Timer添加到RunLoop中，或者换成<code>scheduledWithXXX</code>的创建方式。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)ti target:(<span class=\"type\">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span>)userInfo repeats:(<span class=\"type\">BOOL</span>)yesOrNo;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:(<span class=\"type\">BOOL</span>)repeats block:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)ti target:(<span class=\"type\">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span>)userInfo repeats:(<span class=\"type\">BOOL</span>)yesOrNo;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:(<span class=\"type\">BOOL</span>)repeats block:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block;</span><br></pre></td></tr></table></figure>\n\n<p>所以如果你发现Timer不工作，首先看看是不是用了<code>timerWithXXX</code>的创建方式，如果是，那么你可以手动把Timer添加到RunLoop中，或者换成<code>scheduledWithXXX</code>的创建方式。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不工作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, count++);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, count++);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"comment\">// 把Timer添加到RunLoop中</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:(<span class=\"built_in\">NSDefaultRunLoopMode</span>)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, count++);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你发现Timer仅仅是在界面滑动时不工作，那么你可以把Timer添加到<code>CommonModes</code>下，因为Timer默认是被添加到<code>DefaultMode</code>下，所以在<code>TrackingMode</code>下不工作。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 界面滑动和不滑动时，都可以工作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, count++);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"comment\">// 添加到CommonModes下</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:(<span class=\"built_in\">NSRunLoopCommonModes</span>)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你是在子线程中使用Timer，Timer默认是不工作的，因为子线程的RunLoop没有启动，虽然已经创建了（把Timer添加到RunLoop时系统会创建），因此我们需要手动启动一下RunLoop。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不工作</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 用scheduledWithXXX创建定时器时，不仅会创建一个Timer，还会把Timer添加到RunLoop中，所以这个方法里获取了子线程的RunLoop了，也就是说子线程的RunLoop被创建了，就差启动</span></span><br><span class=\"line\">        [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11&quot;</span>);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工作</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 用scheduledWithXXX创建定时器时，不仅会创建一个Timer，还会把Timer添加到RunLoop中，所以这个方法里获取了子线程的RunLoop了，也就是说子线程的RunLoop被创建了，就差启动</span></span><br><span class=\"line\">        [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11&quot;</span>);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 手动启用一下子线程的RunLoop</span></span><br><span class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、常驻线程\"><a href=\"#2、常驻线程\" class=\"headerlink\" title=\"2、常驻线程\"></a>2、常驻线程</h4><p><code>AFNetworking</code>里就创建了一个子线程，并且让这个子线程一直活着，将来在某一刻时刻需要这个子线程做事情的时候就告诉它做事情。这样做的好处就是当你需要经常在子线程里做事情的时候可以节省线程的创建和销毁开销，如果你做完一个任务就销毁一个线程，做下一个任务又创建一个线程，做完又销毁，那这个过程是非常耗性能的，所以不如干脆让一个子线程一直存在于内存中。</p>\n<p>我们知道<strong>线程一执行完任务，它的生命周期就结束了，生命周期一结束，这个线程就无法再使用了，即便它还存在于内存中，但它已经不能做事情了。</strong>所以我们说的<strong>常驻线程其实是指保住线程的生命周期，不让它结束，而不是保住线程一直存在于内存中，</strong>要想保住线程一直存在于内存中很简单啊，用强指针就可以了，而要想保住线程的生命周期就不能让线程执行完它的任务，那咱们任务里添加个<code>while(1)</code>死循环吧，可以是可以，但是这太占用CPU资源了吧，所以我们可以<strong>用RunLoop来实现常驻线程，</strong>即：</p>\n<ul>\n<li><strong>获取（即创建）子线程的RunLoop</strong></li>\n<li><strong>往RunLoop中添加一个Source或Observer或Timer（通常我们选择添加Source，其它两个太重了犯不着），以保证RunLoop不会因没有Source、Observer、Timer而退出</strong></li>\n<li><strong>启动RunLoop</strong></li>\n<li><strong>而如果想要结束常驻线程，则可以在适当的时机移除掉RunLoop里的Source</strong></li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSThread</span> *thread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个线程并启动</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(threadAction) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)threadAction &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;threadAction：%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取（即创建）子线程的RunLoop</span></span><br><span class=\"line\">    <span class=\"comment\">// 往RunLoop中添加一个Source或Observer或Timer（通常我们选择添加Source，其它两个太重了犯不着），以保证RunLoop不会因没有Source、Observer、Timer而退出</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 启动RunLoop</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设我们要在点击屏幕的时候停掉线程</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 千万不能直接这样移除，因为这样[NSRunLoop currentRunLoop]获取的是主线程的RunLoop，而不是子线程的RnuLoop</span></span><br><span class=\"line\"><span class=\"comment\">//    [[NSRunLoop currentRunLoop] removePort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 一定要在子线程self.thread里移除</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(removePort) onThread:<span class=\"keyword\">self</span>.thread withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)removePort &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 适当的时机，移除掉RunLoop里的Source，RunLoop就可以顺利退出，线程就会结束生命周期，进而线程销毁时，对应的RunLoop也销毁</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] removePort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一、RunLoop是什么</p>\n<p>二、RunLoop的底层实现</p>\n<p>​        1、RunLoop和线程是什么关系</p>\n<p>​        2、RunLoop的运行模式</p>\n<p>​        3、Source0事件源、Source1事件源、Observer、Timer事件源</p>\n<p>三、RunLoop的运行流程</p>\n<p>四、RunLoop的实际应用</p>\n<p>​        1、处理NSTimer不工作的问题</p>\n<p>​        2、常驻线程</p>\n</blockquote>","more":"<h3 id=\"一、RunLoop是什么\"><a href=\"#一、RunLoop是什么\" class=\"headerlink\" title=\"一、RunLoop是什么\"></a>一、RunLoop是什么</h3><p>RunLoop运行循环，它就是一个OC对象，它的主要作用有三个：</p>\n<p><strong>保持App的持续运行</strong>，具体而言，我们的App在启动后就会在<code>main</code>函数那里创建并启动主线程对应的RunLoop，这个RunLoop内部维护着一个<code>do...while</code>循环，正是因为<code>do...while</code>循环的存在，才使得主线程得以保活，即主线程不会执行完任务立即退出，也就是App得以保活，否则App一启动执行完<code>main</code>函数就退出了；</p>\n<ul>\n<li><strong>处理App的各种事件</strong>，具体说，RunLoop内部的<code>do...while</code>循环里循环处理着App的各种事件，包括Source0事件、Source1事件、Timer事件；</li>\n<li><strong>线程的休眠唤醒则是RunLoop区别于其他语言EventLoop的核心所在，线程没事做就休眠，有事做就唤醒，这样可以节省CPU资源。</strong></li>\n</ul>\n<h3 id=\"二、RunLoop的底层实现\"><a href=\"#二、RunLoop的底层实现\" class=\"headerlink\" title=\"二、RunLoop的底层实现\"></a>二、RunLoop的底层实现</h3><p>RunLoop是<code>NSRunLoop</code>类型的，它的C语言实现为<code>CFRunLoopRef</code>，因为<a href=\"https://links.jianshu.com/go?to=https://opensource.apple.com/tarballs/CF/\">CFRunLoopRef</a>是开源的，所以接下来我们会从它的源码来看看RunLoop的底层实现。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> __CFRunLoop *<span class=\"built_in\">CFRunLoopRef</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoop &#123;</span><br><span class=\"line\">    pthread_t _pthread; <span class=\"comment\">// RunLoop对应的线程</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _modes; <span class=\"comment\">// RunLoop所有的运行模式</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> _currentMode; <span class=\"comment\">// RunLoop当前的运行模式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModes; <span class=\"comment\">// RunLoop“特殊的运行模式”</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _commonModeItems; <span class=\"comment\">// RunLoop“特殊的运行模式“里的items</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> __CFRunLoopMode *<span class=\"built_in\">CFRunLoopModeRef</span>;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> __CFRunLoopMode &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFStringRef</span> _name; <span class=\"comment\">// 运行模式的名字，如@&quot;NSDefaultRunLoopMode&quot;、@&quot;UITrackingRunLoopMode&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources0; <span class=\"comment\">// Set，Source0事件源集合</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableSetRef</span> _sources1; <span class=\"comment\">// Set，Source1事件源集合</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _observers; <span class=\"comment\">// Array，观察者数组</span></span><br><span class=\"line\">    <span class=\"built_in\">CFMutableArrayRef</span> _timers; <span class=\"comment\">// Array，Timer事件源数组</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1、RunLoop和线程的关系\"><a href=\"#1、RunLoop和线程的关系\" class=\"headerlink\" title=\"1、RunLoop和线程的关系\"></a>1、RunLoop和线程的关系</h4><p>苹果并没有为我们提供创建RunLoop的API，仅仅提供了获取RunLoop的API。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Core Foundation框架</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopGetMain</span>(); <span class=\"comment\">// 获取主线程对应的RunLoop</span></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopGetCurrent</span>(); <span class=\"comment\">// 获取当前线程对应的RunLoop</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Foundation框架，对Core Foundation框架函数的封装</span></span><br><span class=\"line\">[<span class=\"built_in\">NSRunLoop</span> mainRunLoop]; <span class=\"comment\">// 获取主线程对应的RunLoop</span></span><br><span class=\"line\">[<span class=\"built_in\">NSRunLoop</span> currentRunLoop]; <span class=\"comment\">// 获取当前线程对应的RunLoop</span></span><br></pre></td></tr></table></figure>\n\n<p>这两套API的底层实现大概如下（伪代码，详见<code>CFRunLoop.c</code>文件）：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetMain</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> <span class=\"built_in\">CFRunLoopGetCurrent</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet(pthread_self());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个全局的字典，线程是key，RunLoop是value</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">CFMutableDictionaryRef</span> __CFRunLoops;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__CFRunLoops) &#123; <span class=\"comment\">// 如果是第一次获取RunLoop（那肯定是获取主线程对应的RunLoop，因为App一启动系统就会自动去获取主线程对应的RunLoop，我们自己写的获取且早着呢）</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 初始化全局的字典</span></span><br><span class=\"line\">        __CFRunLoops = <span class=\"built_in\">CFDictionaryCreateMutable</span>();</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 创建主线程对应的RunLoop</span></span><br><span class=\"line\">        <span class=\"built_in\">CFRunLoopRef</span> mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class=\"line\">        <span class=\"comment\">// 主线程为key，主线程对应的RunLoop为value，存入全局的字典里</span></span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(dict, pthread_main_thread_np(), mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 从全局的字典里读取某个线程对应的RunLoop</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRef</span> loop = <span class=\"built_in\">CFDictionaryGetValue</span>(__CFRunLoops, thread);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123; <span class=\"comment\">// 如果读取不到</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 创建该线程对应的RunLoop，</span></span><br><span class=\"line\">        loop = __CFRunLoopCreate(thread);</span><br><span class=\"line\">        <span class=\"comment\">// 该线程为key，该线程对应的RunLoop为value，存入全局的字典里</span></span><br><span class=\"line\">        <span class=\"built_in\">CFDictionarySetValue</span>(__CFRunLoops, thread, loop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注册一个回调，当某个线程销毁时，也销毁该线程对应的RunLoop</span></span><br><span class=\"line\">    _CFSetTSD(thread, loop, __CFFinalizeRunLoop);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>RunLoop是基于线程来管理的，他们是一一对应的关系，共同存在于一个全局的字典里，线程是<code>key</code>，RunLoop是<code>value</code>；</li>\n<li>对于主线程的RunLoop来说，App一启动系统就会自动创建并启动，而对子线程的RunLoop来说，除非我们主动去获取，否则不会创建，我们获取也就是创建子线程的RunLoop后，还需要手动启动它；</li>\n<li>RunLoop的销毁发生在线程销毁时。</li>\n</ul>\n</blockquote>\n<h4 id=\"2、RunLoop的运行模式\"><a href=\"#2、RunLoop的运行模式\" class=\"headerlink\" title=\"2、RunLoop的运行模式\"></a>2、RunLoop的运行模式</h4><p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1140.png\" alt=\"img\"></p>\n<blockquote>\n<ul>\n<li><strong>系统为RunLoop提供了好几种运行模式，其中<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>是我们经常使用的。<code>NSDefaultRunLoopMode</code>是RunLoop默认的运行模式，大多数时候RunLoop就运行在这种模式下，<code>UITrackingRunLoopMode</code>是界面滑动时RunLoop的运行模式，系统会自动完成不同情况下这两种运行模式的切换；</strong></li>\n<li><strong>当然RunLoop还有一种“特殊的运行模式”，就是<code>NSRunLoopCommonModes</code>，严格来说它不是一种运行模式，而是一些运行模式的组合。比如说系统会默认把<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>添加到<code>NSRunLoopCommonModes</code>里，RunLoop运行在<code>NSRunLoopCommonModes</code>模式时，并不是说它就真得运行在<code>NSRunLoopCommonModes</code>下，而是说RunLoop在切换真正的运行模式时会自动把一个运行模式里面的Source0/Source1/Observer/Timer同步到另一个运行模式里；</strong></li>\n<li><strong>一个RunLoop可以有多个运行模式，而每个运行模式里又可以有多个Source0/Source1/Observer/Timer，但是RunLoop一次只能运行在一个运行模式下，这个运行模式被称为CurrentMode，如果要切换运行模式，就得退出RunLoop，重新选择一个运行模式运行。RunLoop分Mode的目的就是为了把不同Mode里的Source0/Source1/Observer/Timer给隔离开来，在这个模式下的时候就做专心做这个模式里的事，在那个模式下的时候就专心做那个模式里的事，让它们互相不影响，当然如果你想一件事能在多个模式下做，那就把它扔到<code>CommonModes</code>下。</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"3、Source0事件源、Source1事件源、Observer、Timer事件源\"><a href=\"#3、Source0事件源、Source1事件源、Observer、Timer事件源\" class=\"headerlink\" title=\"3、Source0事件源、Source1事件源、Observer、Timer事件源\"></a>3、Source0事件源、Source1事件源、Observer、Timer事件源</h4><h6 id=\"Source0事件源：\"><a href=\"#Source0事件源：\" class=\"headerlink\" title=\"Source0事件源：\"></a>Source0事件源：</h6><h6 id=\"Source0事件源主要包括原始指针事件、手势事件、performSelector-onThread-等事件，这些事件都是我们用代码写的。\"><a href=\"#Source0事件源主要包括原始指针事件、手势事件、performSelector-onThread-等事件，这些事件都是我们用代码写的。\" class=\"headerlink\" title=\"Source0事件源主要包括原始指针事件、手势事件、performSelector:onThread:等事件，这些事件都是我们用代码写的。\"></a>Source0事件源主要包括原始指针事件、手势事件、<code>performSelector:onThread:</code>等事件，这些事件都是我们用代码写的。</h6><h6 id=\"Source1事件源：\"><a href=\"#Source1事件源：\" class=\"headerlink\" title=\"Source1事件源：\"></a>Source1事件源：</h6><p>Source1事件源主要包括锁屏、静音、靠近传感器、加速等系统事件，还有基于<code>Port</code>的线程间通信事件，这些事件都不是我们用代码写的，是系统发出的。</p>\n<p>此外需要注意的是原始指针事件、手势事件也是首先被捕捉为Source1事件来唤醒主线程，然后再包装为Source0事件处理的。</p>\n<h6 id=\"Observer：\"><a href=\"#Observer：\" class=\"headerlink\" title=\"Observer：\"></a>Observer：</h6><p>Observer不是RunLoop的事件源，而是RunLoop的观察者，它主要用来观察RunLoop状态的变化，从而触发回调做一些自定义的处理，比如系统的UI刷新和<code>autoreleasepool</code>创建、销毁就是通过Observer观察RunLoop的状态实现的。RunLoop的状态有如下几个：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">CF_OPTIONS</span>(<span class=\"built_in\">CFOptionFlags</span>, <span class=\"built_in\">CFRunLoopActivity</span>) &#123;</span><br><span class=\"line\">    kCFRunLoopEntry         = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">0</span>), <span class=\"comment\">// 即将进入RunLoop</span></span><br><span class=\"line\">    kCFRunLoopBeforeTimers  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">1</span>), <span class=\"comment\">// 线程即将处理Timer事件</span></span><br><span class=\"line\">    kCFRunLoopBeforeSources = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">2</span>), <span class=\"comment\">// 线程即将处理Source事件</span></span><br><span class=\"line\">    kCFRunLoopBeforeWaiting = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">5</span>), <span class=\"comment\">// 线程即将进入休眠</span></span><br><span class=\"line\">    kCFRunLoopAfterWaiting  = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">6</span>), <span class=\"comment\">// 线程被唤醒</span></span><br><span class=\"line\">    kCFRunLoopExit          = (<span class=\"number\">1</span>UL &lt;&lt; <span class=\"number\">7</span>), <span class=\"comment\">// 刚刚退出RunLoop</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>UI刷新</p>\n<p>App一启动，系统就会添加一个Observer，监听主线程对应的RunLoop，主要负责UI刷新。这个Observer监听的是“线程即将进入休眠”和“刚刚退出RunLoop”两个状态，它的回调里才是真正的刷新UI。也就是说我们编写的UI代码，如设置了view的frame、设置view的背景色等，并不是执行到那一行代码时就立即刷新生效，而是RunLoop的线程即将进入休眠或者刚刚退出退出RunLoop时才刷新生效的。</p>\n</li>\n<li><p><code>autoreleasepool</code>的创建和销毁</p>\n<p>App一启动，系统就会添加两个Observer，监听主线程对应的RunLoop，主要负责<code>autoreleasepool</code>的创建和销毁。第一个Observer监听的是“即将进入RunLoop”状态，它的回调里会创建一个<code>autoreleasepool</code>，这个Observer的优先级最高，以此保证<code>autoreleasepool</code>发生在其他所有回调之前，这样我们项目里的<code>autorelease</code>对象就可以放在这个<code>autoreleasepool</code>里面了。第二个Obsever监听的是“线程即将进入休眠”和“刚刚退出RunLoop”两个状态，“线程即将进入休眠”时，它的回调里会销毁<code>autoreleasepool</code>，这个Obsever的优先级最低，以此保证销毁<code>autoreleasepool</code>发生在其他所有回调之后，这样我们项目里的<code>autorelease</code>对象就可以顺利执行一次<code>release</code>操作使得引用计数-1。简单说，我们可以把线程的唤醒做事到线程休眠看作是一次RunLoop循环，App运行过程中会有无数次的RunLoop循环，每一次的RunLoop循环开始时系统都会创建一个<code>autoreleasepool</code>，并把这一次的<code>autorelease</code>对象都放进去，然后等这一次RunLoop循环结束时统一让<code>autorelease</code>对象的引用计数-1。</p>\n</li>\n</ul>\n<h6 id=\"Timer事件源\"><a href=\"#Timer事件源\" class=\"headerlink\" title=\"Timer事件源:\"></a>Timer事件源:</h6><p>Timer事件源主要包括<code>NSTimer</code>、<code>CADisplayLink</code>、<code>performSelector:afterDelay:</code>等定时器触发的事件，这些事件也都是我们用代码写的。</p>\n<ul>\n<li><p><code>NSTimer</code></p>\n<p>我们都知道<code>NSTimer</code>是基于RunLoop实现的，所以我们得把<code>NSTimer</code>添加到RunLoop中它才会工作，那<code>NSTimer</code>是怎么基于RunLoop实现的呢？也就是说<code>NSTimer</code>的工作原理是怎么样的呢？我们在创建<code>NSTimer</code>的时候都会给一个时间间隔（多久触发一次定时器的回调），那么当我们把<code>NSTimer</code>添加到RunLoop后，RunLoop内部的处理是每执行一次<code>do...while</code>循环就记录下本次循环用了多长时间，然后累加上之前的时间，如果时间大于等于我们设置的时间间隔，就调用一下定时器的回调，否则不调用。比如说我们设置了<code>NSTimer</code>每搁1秒钟调用一次回调，假设RunLoop第一次<code>do-while</code>循环任务量较少（因为RunLoop不是专门用来处理定时器的，它还有Source0、Source1等很多事件需要处理，这些事件有可能很简单也有可能很繁重）只用了0.2s，第二次<code>do-while</code>循环用了0.3s，第三次<code>do-while</code>循环也用了0.3s，此时累计用了0.8s，第一次<code>do-while</code>循环任务量较多用了0.5s，那累计就是1.3s，也就是1.3s后才触发了定时器的回调，并不是1s，这也就是为什么我们说<code>NSTimer</code>有可能不准，所以要想定时器非常准时可以使用GCD定时器，GCD定时器是跟系统内核挂钩的，不依赖于RunLoop，所以非常准时，所以建议能用GCD定时器尽量用GCD定时器。</p>\n</li>\n<li><p><code>CADisplayLink</code></p>\n<p><code>CADisplayLink</code>和<code>NSTimer</code>的工作原理基本是一样的，只不过<code>CADisplayLink</code>的调用频率和屏幕的刷新频率一样，每1/60秒调用一次。</p>\n</li>\n<li><p><code>performSelector:afterDelay:</code></p>\n<p><code>performSelector:afterDelay:</code>，内部其实就是创建了一个<code>NSTimer</code>并添加到当前线程的RunLoop中。</p>\n</li>\n</ul>\n<h3 id=\"三、RunLoop的运行流程\"><a href=\"#三、RunLoop的运行流程\" class=\"headerlink\" title=\"三、RunLoop的运行流程\"></a>三、RunLoop的运行流程</h3><p>RunLoop的运行流程大概如下图：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200.png\" alt=\"img\"></p>\n<p>RunLoop的运行流程大概如下伪代码：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 选择DefaultMode进入RunLoop，</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// App一启动，会走main函数，</span></span><br><span class=\"line\"><span class=\"comment\">// main函数里面会调用UIApplicationMain函数，</span></span><br><span class=\"line\"><span class=\"comment\">// UIApplicationMain函数里面就调用该函数获取并启动了主线程对应的RunLoop。</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"built_in\">CFRunLoopRun</span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class=\"number\">1.0e10</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 选择指定的Mode进入RunLoop，也可以指定RunLoop的超时时间</span></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"comment\">// 切换Mode时，系统就会调用这个方法来重新进入RunLoop</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"built_in\">CFRunLoopRunInMode</span>(<span class=\"built_in\">CFStringRef</span> modeName, <span class=\"built_in\">CFTimeInterval</span> seconds) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CFRunLoopRunSpecific</span>(<span class=\"built_in\">CFRunLoopGetCurrent</span>(), modeName, seconds);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"built_in\">CFRunLoopRunSpecific</span>(runloop, modeName, seconds) &#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">// 先根据modeName去查找Mode</span></span><br><span class=\"line\">    <span class=\"built_in\">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(runloop, modeName);</span><br><span class=\"line\">    <span class=\"comment\">// 如果Mode里没有Source0/Source1/Observer/Timer，则直接返回，不进入RunLoop</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 1、通知Observers：即将进入RunLoop</span></span><br><span class=\"line\">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class=\"line\">    __CFRunLoopRun(runloop, currentMode, seconds) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> retVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123; <span class=\"comment\">// do...while循环</span></span><br><span class=\"line\">            <span class=\"comment\">// 2、通知Observers：线程即将处理Timer事件</span></span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class=\"line\">            <span class=\"comment\">// 3、通知Observers：线程即将处理Source事件</span></span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 4、处理Source0事件</span></span><br><span class=\"line\">            __CFRunLoopDoSources0(runloop, currentMode);</span><br><span class=\"line\">            <span class=\"comment\">// 5、判断有没有Source1事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg)) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 如果有，就跳转到handle_msg去处理</span></span><br><span class=\"line\">                <span class=\"keyword\">goto</span> handle_msg;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 6、如果Source0事件处理完了、而且没有Source1事件，Timer事件的时间点还没到，则通知Observers：线程即将进入休眠</span></span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class=\"line\">            <span class=\"comment\">// 7、线程休眠，等待被唤醒，这里是利用内核函数mach_msg实现的。线程进入休眠后，切换到内核态，会卡死在这个地方，因为线程不做任何事情，不占用任何CPU资源，仅仅是等待着被唤醒</span></span><br><span class=\"line\">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class=\"number\">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy) &#123;</span><br><span class=\"line\">                mach_msg(msg, MACH_RCV_MSG, port);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 8、通知Observers：线程被唤醒，切换到用户态</span></span><br><span class=\"line\">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class=\"line\"></span><br><span class=\"line\">            </span><br><span class=\"line\">        handle_msg: <span class=\"comment\">// 9、处理唤醒事件</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (msg_is_timer) &#123; <span class=\"comment\">// 如果是被Timer事件唤醒的</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则处理Timer事件</span></span><br><span class=\"line\">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (msg_is_dispatch) &#123; <span class=\"comment\">// 如果是被GCD dispatch到主线程的事件唤醒的</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则处理GCD dispatch到主线程的事件</span></span><br><span class=\"line\">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 如果是被Source1事件唤醒的</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则处理Source1事件</span></span><br><span class=\"line\">                __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 10、根据前面的执行结果，决定如何操作</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timeout) &#123; <span class=\"comment\">// 如果RunLoop对应线程的休眠时间超过了超时时间</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则退出RunLoop</span></span><br><span class=\"line\">                retVal = kCFRunLoopRunTimedOut;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (__CFRunLoopIsStopped(runloop)) &#123; <span class=\"comment\">// 如果RunLoop被强行终止了</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则退出RunLoop</span></span><br><span class=\"line\">                retVal = kCFRunLoopRunStopped;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode, previousMode)) &#123; <span class=\"comment\">// 如果RunLoop当前Mode里没有Source0/Source1/Observer/Timer了</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 则退出RunLoop</span></span><br><span class=\"line\">                retVal = kCFRunLoopRunFinished;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 如果RunLoop没超时，也没被强行终止，当前Mode里也没空，则继续RunLoop</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span> == retVal);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 11、通知Observers：刚刚退出RunLoop</span></span><br><span class=\"line\">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopExit);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> retVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比如说有这样一个问题：App启动、App运行过程中点击屏幕、App杀死，这个过程系统都发生了什么？</p>\n<p>App 启动后，当走到<code>main</code>函数时，会调用<code>UIApplicationMain</code>函数，<code>UIApplicationMain</code>函数里面就会获取并启动主线程里面的RunLoop；当主线程处理完一件事后，没事做了就会进入休眠状态，而一旦我们点击屏幕。系统就会捕捉到这个事件为Source1事件来唤醒主线程，并把事件包装为Source0事件处理；之后App杀死，主线程销毁，主线程对应的RunLoop也就销毁了。（当然也可以结合事件传递和响应来分析）</p>\n<h3 id=\"四、RunLoop的实际应用\"><a href=\"#四、RunLoop的实际应用\" class=\"headerlink\" title=\"四、RunLoop的实际应用\"></a>四、RunLoop的实际应用</h3><h5 id=\"1、处理NSTimer不工作的问题\"><a href=\"#1、处理NSTimer不工作的问题\" class=\"headerlink\" title=\"1、处理NSTimer不工作的问题\"></a>1、处理NSTimer不工作的问题</h5><p>Timer有两种创建方式，一种是<code>timerWithXXX</code>，一种是<code>scheduledWithXXX</code>。它们的区别是：**<code>timerWithXXX</code>只会创建一个Timer，不会把Timer添加到RunLoop中；<code>scheduledWithXXX</code>不仅会创建一个Timer，还会把Timer添加到RunLoop中，而且是添加到了<code>DefaultMode</code>下。**所以如果你发现Timer不工作，首先看看是不是用了<code>timerWithXXX</code>的创建方式，如果是，那么你可以手动把Timer添加到RunLoop中，或者换成<code>scheduledWithXXX</code>的创建方式。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)ti target:(<span class=\"type\">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span>)userInfo repeats:(<span class=\"type\">BOOL</span>)yesOrNo;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)timerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:(<span class=\"type\">BOOL</span>)repeats block:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)ti target:(<span class=\"type\">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span>)userInfo repeats:(<span class=\"type\">BOOL</span>)yesOrNo;</span><br><span class=\"line\">+ (<span class=\"built_in\">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class=\"built_in\">NSTimeInterval</span>)interval repeats:(<span class=\"type\">BOOL</span>)repeats block:(<span class=\"type\">void</span> (^)(<span class=\"built_in\">NSTimer</span> *timer))block;</span><br></pre></td></tr></table></figure>\n\n<p>所以如果你发现Timer不工作，首先看看是不是用了<code>timerWithXXX</code>的创建方式，如果是，那么你可以手动把Timer添加到RunLoop中，或者换成<code>scheduledWithXXX</code>的创建方式。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 不工作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, count++);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> timerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, count++);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"comment\">// 把Timer添加到RunLoop中</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:(<span class=\"built_in\">NSDefaultRunLoopMode</span>)];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 工作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, count++);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你发现Timer仅仅是在界面滑动时不工作，那么你可以把Timer添加到<code>CommonModes</code>下，因为Timer默认是被添加到<code>DefaultMode</code>下，所以在<code>TrackingMode</code>下不工作。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 界面滑动和不滑动时，都可以工作</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSTimer</span> *timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%d&quot;</span>, count++);</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">    <span class=\"comment\">// 添加到CommonModes下</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:(<span class=\"built_in\">NSRunLoopCommonModes</span>)];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你是在子线程中使用Timer，Timer默认是不工作的，因为子线程的RunLoop没有启动，虽然已经创建了（把Timer添加到RunLoop时系统会创建），因此我们需要手动启动一下RunLoop。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不工作</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 用scheduledWithXXX创建定时器时，不仅会创建一个Timer，还会把Timer添加到RunLoop中，所以这个方法里获取了子线程的RunLoop了，也就是说子线程的RunLoop被创建了，就差启动</span></span><br><span class=\"line\">        [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11&quot;</span>);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工作</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 用scheduledWithXXX创建定时器时，不仅会创建一个Timer，还会把Timer添加到RunLoop中，所以这个方法里获取了子线程的RunLoop了，也就是说子线程的RunLoop被创建了，就差启动</span></span><br><span class=\"line\">        [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11&quot;</span>);</span><br><span class=\"line\">        &#125;];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 手动启用一下子线程的RunLoop</span></span><br><span class=\"line\">        [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、常驻线程\"><a href=\"#2、常驻线程\" class=\"headerlink\" title=\"2、常驻线程\"></a>2、常驻线程</h4><p><code>AFNetworking</code>里就创建了一个子线程，并且让这个子线程一直活着，将来在某一刻时刻需要这个子线程做事情的时候就告诉它做事情。这样做的好处就是当你需要经常在子线程里做事情的时候可以节省线程的创建和销毁开销，如果你做完一个任务就销毁一个线程，做下一个任务又创建一个线程，做完又销毁，那这个过程是非常耗性能的，所以不如干脆让一个子线程一直存在于内存中。</p>\n<p>我们知道<strong>线程一执行完任务，它的生命周期就结束了，生命周期一结束，这个线程就无法再使用了，即便它还存在于内存中，但它已经不能做事情了。</strong>所以我们说的<strong>常驻线程其实是指保住线程的生命周期，不让它结束，而不是保住线程一直存在于内存中，</strong>要想保住线程一直存在于内存中很简单啊，用强指针就可以了，而要想保住线程的生命周期就不能让线程执行完它的任务，那咱们任务里添加个<code>while(1)</code>死循环吧，可以是可以，但是这太占用CPU资源了吧，所以我们可以<strong>用RunLoop来实现常驻线程，</strong>即：</p>\n<ul>\n<li><strong>获取（即创建）子线程的RunLoop</strong></li>\n<li><strong>往RunLoop中添加一个Source或Observer或Timer（通常我们选择添加Source，其它两个太重了犯不着），以保证RunLoop不会因没有Source、Observer、Timer而退出</strong></li>\n<li><strong>启动RunLoop</strong></li>\n<li><strong>而如果想要结束常驻线程，则可以在适当的时机移除掉RunLoop里的Source</strong></li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSThread</span> *thread;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建一个线程并启动</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.thread = [[<span class=\"built_in\">NSThread</span> alloc] initWithTarget:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(threadAction) object:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.thread start];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)threadAction &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;threadAction：%@&quot;</span>, [<span class=\"built_in\">NSThread</span> currentThread]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取（即创建）子线程的RunLoop</span></span><br><span class=\"line\">    <span class=\"comment\">// 往RunLoop中添加一个Source或Observer或Timer（通常我们选择添加Source，其它两个太重了犯不着），以保证RunLoop不会因没有Source、Observer、Timer而退出</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] addPort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 启动RunLoop</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] run];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设我们要在点击屏幕的时候停掉线程</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 千万不能直接这样移除，因为这样[NSRunLoop currentRunLoop]获取的是主线程的RunLoop，而不是子线程的RnuLoop</span></span><br><span class=\"line\"><span class=\"comment\">//    [[NSRunLoop currentRunLoop] removePort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 一定要在子线程self.thread里移除</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> performSelector:<span class=\"keyword\">@selector</span>(removePort) onThread:<span class=\"keyword\">self</span>.thread withObject:<span class=\"literal\">nil</span> waitUntilDone:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)removePort &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 适当的时机，移除掉RunLoop里的Source，RunLoop就可以顺利退出，线程就会结束生命周期，进而线程销毁时，对应的RunLoop也销毁</span></span><br><span class=\"line\">    [[<span class=\"built_in\">NSRunLoop</span> currentRunLoop] removePort:[<span class=\"built_in\">NSMachPort</span> port] forMode:<span class=\"built_in\">NSDefaultRunLoopMode</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"【Runtime】对象、类、元类、分类的本质","date":"2021-07-13T01:31:03.000Z","_content":"\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713093308752.png)\n\n### 序言\n\n弄明白对象、类、元类内存里存储的是什么东西就行\n\n<!--more-->\n\n> 一、对象的本质\n>\n> 二、类的本质\n>\n> 三、元类的本质\n>\n> 四、分类的本质\n\n> 2006年苹果发布了OC2.0，其中对Runtime的很多API做了改进，并把OC1.0中Runtime的很多API标记为“将来会被废弃”。 但是两套API的核心实现思路还是一样的，而旧API比较简单，所以我们会分析旧API，然后看看新API作了哪些变化，这里有[最新的Runtime源码](https://links.jianshu.com/go?to=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2Fobjc4%2F)。\n\n### 一、对象的本质\n\n#### 1、OC1.0\n\n通过查看RunTIme的源码（`objc.h`文件），我们得到对象的定义如下（伪代码）：\n\n```objectivec\nstruct objc_object {\n    // 固定的成员变量\n    Class isa;\n\n    // 我们自定义的成员变量\n    NSSring *_name;\n    NSSring *_sex;\n    int _age;\n};\n\ntypedef struct objc_object *id; // id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象\n```\n\n可见对象的本质就是一个`objc_object`类型的结构体。该结构体内部只有一个固定的成员变量`isa`，它是一个`Class`类型的结构体指针，存储着一个地址，指向该对象所属的类。当然结构体内部还可能有很多我们自定义的成员变量，存储着该对象这些成员变量具体的值。\n\n#### 2、OC2.0\n\n通过查看Runtime的源码（`objc-private.h`文件），我们得到对象的定义如下（伪代码）：\n\n```cpp\nstruct objc_object {\n    // 固定的成员变量\n    isa_t isa;\n\n    // 自定义的成员变量\n    NSSring *_name;\n    NSSring *_sex;\n    int _age;\n}\n\n// 共用体isa_t\n//\n// 共用体也是C语言的一种数据类型，和结构体差不多，\n// 都可以定义很多的成员变量，但两者的主要区别就在于内存的使用。\n//\n// 一个结构体占用的内存等于它所有成员变量占用内存之和，而且要遵守内存对齐规则，而一个共用体占用的内存等于它最宽成员变量占用的内存。\n// 结构体里所有的成员变量各自有各自的内存，而共用体里所有的成员变量共用这一块内存。\n// 所以共用体可以更加节省内存，但是我们要把数据处理好，否则很容易出现数据覆盖。\nunion isa_t {\n    Class cls;\n    \n    unsigned long bits; // 8个字节，64位\n    struct { // 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着什么数据\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n        unsigned long nonpointer        : 1;\n        unsigned long has_assoc         : 1;\n        unsigned long has_cxx_dtor      : 1;\n        unsigned long shiftcls          : 33; // 当前对象所属类的地址信息\n        unsigned long magic             : 6;\n        unsigned long weakly_referenced : 1; // 当前对象是否有弱引用\n        unsigned long deallocating      : 1;\n        unsigned long has_sidetable_rc  : 1; // 引用计数表里是否有当前对象的引用计数\n        unsigned long extra_rc          : 19; // 对象的引用计数 - 1，存不下了就会放到引用计数表里\n# endif\n    };\n};\n\ntypedef struct objc_object *id; // id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象\n```\n\n可见对象的本质还是一个`objc_object`类型结构体。该结构体内部也还只有一个固定成员变量`isa`，只不过64位操作系统以后，对`isa`做了内存优化，它不再直接是一个指针，而是一个`isa_t`类型的共用体，它同样占用8个字节64位，但其中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1）、存储不下就放到引用计数表里，还有一位用来存储对象是否有弱引用，其他位上则存储这各种各样的标记信息。\n\n- `nonpointer`：占1位，标记`isa`是否经过内存优化。如果值为0，代表`isa`没经过内存优化，它就是一个普通的`isa`指针，64位全都用来存储该对象所属类的地址；如果值为1，代表`isa`经过了内存优化，只有33位用来存储对象所属类的地址信息，其它位则另有用途，了解一下即可；\n- `has_assoc`：占1位，标记当前对象是否有关联对象，如果没有，对象销毁时会更快，了解一下即可；\n- `has_cxx_dtor`：占1位，标记当前对象是否有C++析构函数，如果没有，对象销毁时会更快，了解一下即可；\n- **`shiftcls`：占33位，存储着当前对象所属类的地址信息；**\n- `magic`：占1位，用来标记在调试时当前对象是否未完成初始化，了解一下即可；\n- **`weakly_referenced`：占1位，标记弱引用表里是否有当前对象的弱指针数组——即当前对象是否被弱指针指向着、当前对象是否有弱引用；**\n- `deallocating`：占1位，标记当前对象是否正在释放，了解一下即可；\n- **`has_sidetable_rc`：占1位，标记引用计数表里是否有当前对象的引用计数；**\n- **`extra_rc`：占19位，存储着（对象的引用计数 - 1），存不下了就会放到引用计数表里，存值范围为0~255。**\n\n### 二、类的本质\n\n#### 1、OC1.0\n\n通过查看Runtime的源码（`runtime.h`文件），我们得到类的定义如下（伪代码）：\n可见类的本质就是一个`objc_class`类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：\n\n```cpp\nstruct objc_class {\n    Class isa;\n    Class super_class;\n\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n    const ivar_list_t *ivars;\n\n    cache_t cache;\n   \n    const char *name;\n    long instance_size;\n    long version;\n    long info;\n};\n\ntypedef struct objc_class *Class; // Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类\n```\n\n- **`isa指针`：存储着一个地址，指向该类所属的类——即元类；**\n- **`superclass指针`：存储着一个地址，指向该类的父类；**\n- **`methods`：数组指针，存储着该类所有的实例方法信息；**\n- **`properties`：数组指针，存储着该类所有的属性信息；**\n- **`protocols`：数组指针，存储着该类所有遵守的协议信息；**\n- **`ivars`：数组指针，存储着该类所有的成员变量信息；**\n- **`cache`：结构体，存储着该类所有的方法缓存信息。**\n\n#### 2、OC2.0\n\n通过查看Runtime的源码（`objc-runtime-new.h`文件），我们得到类的定义如下（伪代码）\n\n```objective-c\nstruct objc_class : objc_object {\n//    isa_t isa; // objc_class继承自objc_object，所以不考虑内存对齐的前提下，可以直接把isa成员变量搬过来\n    Class superclass;\n    \n    class_data_bits_t bits; // 存储着该类的具体信息，按位与掩码FAST_DATA_MASK便可得到class_rw_t\n    \n    cache_t cache;\n}\n\n// class_rw_t结构体就是该类的可读可写信息（rw即readwrite）\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro; // 该类的只读信息\n\n    method_array_t methods; // 存储着该类所有的实例方法信息，包括分类的\n    property_array_t properties; // 存储着该类所有的属性信息，包括分类的\n    protocol_array_t protocols; // 存储着该类所有遵守的协议信息，包括分类的\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n\n    char *demangledName;\n}\n\n// class_ro_t结构体就是该类的只读信息（ro即readonly）\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;\n    method_list_t * baseMethodList; // 存储着该类本身的实例方法信息\n    protocol_list_t * baseProtocols; // 存储着该类本身遵守的协议信息\n    const ivar_list_t * ivars; // 存储着该类本身的成员变量信息\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties; // 存储着该类本身的属性信息\n}\n\ntypedef struct objc_class *Class; // Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类\n```\n\n可见类的本质还是一个`objc_class`类型的结构体，我们重点关注的那几个成员变量还是可以顺利找到的，只不过它内部结构套了两层`rw`和`ro`，我们先说一下`ro`，`ro`内部存储着经过编译后一个类本身定义的所有实例方法、属性、协议、成员变量，它是只读的，然后运行时才会生成`rw`，把`ro`里类本身定义的所有实例方法、属性、协议搞到`rw`里，并把这个类所有分类的实例方法、属性、协议合并到`rw`里，`rw`是可读写的，这在解释“分类为什么不能给类扩展成员变量”提供了一个很好的证据。\n\n### 三、元类的本质\n\n所谓元类，是指一个类所属的类，我们每创建一个类，系统就会自动帮我们创建好该类所属的类——即元类。如果你觉得不太好理解，这里就多说两句：我们常说“在面向对象编程里，万事万物皆对象”，因此在OC里对象其实分为实例对象、类对象、元类对象三类，我们开发中经常说的“对象”其实是指狭义的对象——实例对象，知道了这一点就好理解了，实例对象有它所属的类——即一个类对象，类对象也有它所属的类——即一个元类对象，元类对象也有它所属的类——即基类的元类对象。\n\n**其实元类和类的本质都是`objc_class`结构体，只不过它们的用途不一样，类的`methods`成员变量里存储着该类所有的实例方法信息，而元类的`methods`成员变量里存储着该类所有的类方法信息。**\n\n### 四、分类的本质\n\n#### 1、分类是什么，我们一般用分类做什么\n\n**分类是OC的一个高级特性，我们一般用它来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现。**\n\n举个简单例子：\n\n比如我们给`NSObject`类扩展一个`test`方法。\n\n```objectivec\n-----------NSObject+INETest.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface NSObject (INETest)\n\n- (void)ine_test;\n\n@end\n\n\n-----------NSObject+INETest.m-----------\n\n#import \"NSObject+INETest.h\"\n\n@implementation NSObject (INETest)\n\n- (void)ine_test {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n比如我们有一个`INEPerson`类，保持它的主体，然后把它“吃”、“喝”的功能分散到不同的模块里去实现。\n\n```objectivec\n-----------INEPerson.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface INEPerson : NSObject\n\n@property (nonatomic, assign) NSInteger age;\n\n@end\n\n\n-----------INEPerson.m-----------\n\n#import \"INEPerson.h\"\n\n@implementation INEPerson\n\n@end\n```\n\n```objectivec\n-----------INEPerson+INEEat.h-----------\n\n#import \"INEPerson.h\"\n\n@interface INEPerson (INEEat)\n\n- (void)ine_eat;\n\n@end\n\n\n-----------INEPerson+INEEat.m-----------\n\n#import \"INEPerson+INEEat.h\"\n\n@implementation INEPerson (INEEat)\n\n- (void)ine_eat {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n```objectivec\n-----------INEPerson+INEDrink.h-----------\n\n#import \"INEPerson.h\"\n\n@interface INEPerson (INEDrink)\n\n- (void)ine_drink;\n\n@end\n\n\n-----------INEPerson+INEDrink.m-----------\n\n#import \"INEPerson+INEDrink.h\"\n\n@implementation INEPerson (INEDrink)\n\n- (void)ine_drink {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n```dart\n-----------ViewController.m-----------\n\n#import \"INEPerson.h\"\n#import \"INEPerson+INEEat.h\"\n#import \"INEPerson+INEDrink.h\"\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    INEPerson *person = [[INEPerson alloc] init];\n    [person ine_eat];// INEPerson (INEEat) eat\n    [person ine_drink];// INEPerson (INEDrink) drink\n}\n```\n\n> 分类和延展的区别：\n>\n> - **分类一般用来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现；而延展一般用来给我们自定义的类添加私有属性。**\n> - **分类的数据不是在编译时就合并到类里面的，而是在运行时；而延展的数据是在编译时就合并到类里面的。**\n\n#### 2、分类的本质\n\n通过查看Runtime的源码（`objc-runtime-new.h`文件），我们得到分类的定义如下：（伪代码）\n\n```objective-c\nstruct category_t {\n    const char *name; // 该分类所属的类的名字\n    struct classref *cls; // 指向该分类所属的类\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n};\n\ntypedef struct category_t *Category;\n```\n\n可见分类的本质是一个`category_t`类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：\n\n- **`classMethods`：该分类为类扩展的类方法列表；**\n- **`instanceMethods`：该分类为类扩展的实例方法列表；**\n- **`instanceProperties`：该分类为类扩展的属性列表；**\n- **`protocols`：该分类为类扩展的协议列表。**\n\n注意分类的本质里没有“该分类为类扩展的成员变量列表”喔，这在解释“为什么分类不能给类扩展成员变量”时又是一个很好的证据。\n\n#### 3、分类的实现原理\n\n我们知道一个类所有的实例方法都存储在类里面，所有的类方法都存储在元类里面，而对象调用方法的流程就是根据`isa`指针先找到相应的类或元类，然后在类或元类里再找到相应的方法来调用，那`person`对象是怎么找到分类里的`ine_eat`和`ine_drink`方法来调用的呢？\n\n现在我们可以大胆猜测，因为对象内部只有一个`isa`指针，指向它所属的类，所以不可能再有一套类似的方法查找机制让它专门去分类里面查找方法，难道系统会把分类里的方法合并到类里面去？如果会合并的话，那是编译时合并的，还是运行时合并的？很简单，我们只需要看看编译后类里面是否已经包含了分类的方法就行。\n\n> 先给出结论：**系统不是在编译时让编译器把分类的数据合并到类、元类里面的，而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的，而且分类的数据还放在类本身数据的前面，越晚编译的分类越在前面，所以如果分类里面有和类里面同名的方法，会优先调用分类里面的方法，如果多个分类里面有同名的方法，会优先调用后编译分类里面的方法，我们可以去Compile Sources里控制分类编译的顺序。**\n\n- 系统不是在编译时让编译器把分类的数据合并到类、元类里面的\n\n接着上面`INEPerson`类的例子，我们用`clang`编译器把`INEPerson.m`文件转换成C/C++代码，以便窥探编译后`INEPerson`类里面是否已经包含了分类的方法。\n\n```objective-c\nstruct objc_class OBJC_CLASS_$_INEPerson = {\n    0, // &OBJC_METACLASS_$_INEPerson,\n    0, // &OBJC_CLASS_$_NSObject,\n    0, // (void *)&_objc_empty_cache,\n    \n    // 可读可写的\n    [\"age\", \"setAge:\"], // 所有的实例方法\n    [\"age\"], // 所有的属性\n    [], // 所有遵循的协议\n    \n    // 只读的\n    \"INEPerson\", // 类名\n    [\"_age\"], // 所有的成员变量\n    16, // 实例对象的实际大小\n};\n```\n\n可见经过编译后，`INEPerson`类里面的数据还是它本身拥有的那些数据，并没有分类的方法，这就表明系统不是在编译时让编译器把分类的数据合并到类、元类里面的。\n\n- 而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的\n\n既然系统不是在编译时就把分类的数据合并到类里面的，那就只能是在运行时了，接下来我们就找找运行时（Runtime）的相关源码（`objc-runtime-new.mm`文件），看看系统到底是怎么把分类合并到类里面的：\n\n运行时，系统读取镜像阶段，会读取所有的类，并且如果发现有分类，也会读取所有的分类，然后遍历所有的分类，根据分类的`cls指针`找到它所属的类，重新组织一下这个类的内部结构——即合并分类的数据。\n\n```objective-c\n// 系统读取镜像\nvoid _read_images()\n{\n    // 读取所有的类\n    // ...\n\n    // 发现有分类\n    // 读取所有的分类\n    category_t **catlist = _getObjc2CategoryList(hi, &count);\n    // 遍历所有的分类\n    for (i = 0; i < count; i++) {\n        // 读取某一个分类\n        category_t *cat = catlist[I];\n        \n        // 根据分类的cls指针找到它所属的类\n        Class cls = cat->cls;\n        // 重新组织一下这个类的内部结构——即合并分类的数据\n        remethodizeClass(cls);\n    }\n}\n```\n\n那具体怎么个合并法呢？**系统会去获取这个类所有的分类，然后倒序遍历这所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里**（因为是倒序遍历分类的，所以越晚编译的分类的实例方法列表反而越会放在二维数组的前面），**然后再把这个二维数组内所有一维数组的首地址复制进`methods`成员变量指向的那块内存里（注意这个存储过程会把类本身的实例方法列表挪到最后——即高内存地址上，而把分类的实例方法列表存在前面）。**\n\n```objective-c\n// 重新组织一下这个类的内部结构——即合并分类的数据\nstatic void remethodizeClass(Class cls)\n{\n    // 系统会去获取这个类所有的分类（没有合并过的）\n    category_list *cats = unattachedCategoriesForClass(cls);\n    // 把所有分类的数据合并到类里面\n    attachCategories(cls, cats);\n    free(cats);\n}\n\n/**\n * 把所有分类的数据合并到类里面\n *\n * @param cls 当前类\n * @param cats 当前类所有的分类\n */\nstatic void attachCategories(Class cls, category_list *cats)\n{\n#pragma mark - 倒序遍历所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里\n    /*\n     创建一个二维数组，用来存放每个分类里的实例方法列表，最终结果类似下面这样：\n     [\n        [instanceMethod1, instanceMethod2, ...] --> 分类1所有实例方法\n        [instanceMethod1, instanceMethod2, ...] --> 分类2所有实例方法\n        ...\n     ]\n     */\n    method_list_t **mlists = (method_list_t **) malloc(cats->count * sizeof(*mlists));\n    \n    // 属性\n    property_list_t **proplists = (property_list_t **) malloc(cats->count * sizeof(*proplists));\n    \n    // 协议\n    protocol_list_t **protolists = (protocol_list_t **) malloc(cats->count * sizeof(*protolists));\n    \n    int mcount = 0;\n    int propcount = 0;\n    int protocount = 0;\n    int i = cats->count;\n    // 注意：这里是倒序遍历所有的分类\n    while (i--) {\n        // 获取一个分类\n        auto cat = cats[I];\n        \n        // 获取分类的实例方法列表，存进二维数组\n        method_list_t *mlist = cat->methods;\n        mlists[mcount++] = mlist;\n        \n        // 属性\n        protocol_list_t *protolist = cat->protocols;\n        protolists[protocount++] = protolist;\n        \n        // 协议\n        property_list_t *proplist = cat->properties;\n        proplists[propcount++] = proplist;\n    }\n    \n    \n#pragma mark - 把这个二维数组内所有一维数组的首地址存进methods成员变量所指向的那块内存空间里\n    \n    // 获取当前类的数据（包括实例方法列表、属性列表、协议列表等）\n    auto classData = cls->data();\n    \n    // 给当前类的实例方法列表附加所有分类的实例方法列表\n    classData->methods.attachLists(mlists, mcount);\n    free(mlists);\n    \n    // 属性\n    classData->properties.attachLists(proplists, propcount);\n    free(proplists);\n    \n    // 协议\n    classData->protocols.attachLists(protolists, protocount);\n    free(protolists);\n}\n\n/**\n * 给当前类的实例方法列表附加所有分类的实例方法列表\n *\n * @param addedLists 所有分类的实例方法列表（就是那个二维数组，但其实是那个二维数组的首地址）\n * @param addedCount 分类的个数\n */\nvoid attachLists(List* const * addedLists, unsigned int addedCount) {\n#pragma mark - 重新为类的methods成员变量分配内存\n    // 获取类原来methods成员变量的元素个数（注意：一个类的methods成员变量是一个数组，存储着若干个指针，指向相应的方法列表，而不是直接就是个方法列表存储方法）\n    unsigned int oldCount = array()->count;\n    // 加上分类的个数，得到新的methods成员变量该有多少个元素\n    unsigned int newCount = oldCount + addedCount;\n    // 重新为methods成员变量所指向的数组分配内存，一个指针占8个字节\n    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n    array()->count = newCount;\n    \n    \n#pragma mark - 为类的methods成员变量重新分配完内存后，对其内存数据进行移动和复制操作\n    //\n    /*\n     内存复制：\n     memmove(dst, src, len)，从src所指向的内存空间复制len个字节的数据到dst所指向的内存空间，内部处理了内存覆盖。\n     memcpy(dst, src, n)，从src所指向的内存空间复制n个字节的数据到dst所指向的内存空间，内部没处理内存覆盖。\n     */\n    // 把类原来的实例方法列表复制到最后面（但其实是把类原来的实例方法列表，在methods成员变量里对应的那个指针————原来的实例方法列表的首地址————复制到最后面了）\n    memmove(array()->lists + addedCount, array()->lists,\n            oldCount * sizeof(array()->lists[0]));\n    // 把所有分类的实例方法列表放在前面（同理，其实是把所有分类的的实例方法列表的首地址复制到前面了，因为methods成员变量里存放的是指针————即实例方法列表的地址，不过这里二维数组的内存拷贝会拷贝它里面所有一维数组的首地址，而不仅仅这个二维数组的首地址）\n    memcpy(array()->lists, addedLists,\n           addedCount * sizeof(array()->lists[0]));\n}\n```\n\n这样就把所有分类的实例方法列表全都合并到类里面去了，最终类的方法列表结构如下：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713113333032.png)\n\n以上我们只是说明了分类为类扩展实例方法的底层实现，至于分类为类扩展类方法、属性、协议是同理的。\n\n#### 4、分类的`+load`方法和`+initialize`方法\n\n|                   |                  调用时机                   |                           调用方式                           |                           调用顺序                           |\n| :---------------: | :-----------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n|    `+load`方法    | `+load`方法是系统把类和分类载入内存时调用的 | `+load`方法是通过内存地址直接调用的，所以分类的`+load`方法不会覆盖类的`+load`方法，也就是说如果类和分类里面都实现了`+load`方法，那么它们都会被调用 | 会先调用所有类的`+load`方法，然后再调用所有分类的`+load`方法 |\n| `+initialize`方法 |   `+initialize`方法是类初始化的时候调用的   | `+initialize`方法是通过消息发送机制调用的，所以分类的`+initialize`方法会覆盖类的`+initialize`方法，也就是说如果类和分类里面都实现了`+initialize`方法，那么只有分类里面的会被调用 |              会优先调用分类的`+initialize`方法               |\n\n> 苹果提供类、分类的`+load`方法和`+initialize`方法，其实就是给我们开发者暴露两个接口，让我们根据这俩方法的特点来合理使用。比如我们想在某个类被载入内存时做一些事情，就可以在`+load`方法里做操作，想在某个类初始化时做一些事情，就可以在`+initialize`方法里做操作。\n\n###### 4.1 `+load`方法\n\n- 调用时机\n\n假设有一个`INEPerson`类，并且为它创建了两个分类`INEEat`和`INEDrink`。\n\n\n\n```objectivec\n-----------INEPerson.m-----------\n\n#import \"INEPerson.h\"\n\n@implementation INEPerson\n\n+ (void)load {\n    \n    NSLog(@\"INEPerson +load\");\n}\n\n@end\n\n\n-----------INEPerson+INEEat.m-----------\n\n#import \"INEPerson+INEEat.h\"\n\n@implementation INEPerson (INEEat)\n\n+ (void)load {\n    \n    NSLog(@\"INEPerson (INEEat) +load\");\n}\n\n@end\n\n\n-----------INEPerson+INEDrink.m-----------\n\n#import \"INEPerson+INEDrink.h\"\n\n@implementation INEPerson (INEDrink)\n\n+ (void)load {\n    \n    NSLog(@\"INEPerson (INEDrink) +load\");\n}\n\n@end\n```\n\n我们什么都不做，不使用`Person`类，甚至连它的头文件也不导入。\n\n\n\n```css\n-----------ViewController.m-----------\n\n#import \"ViewController.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n}\n\n@end\n```\n\n直接运行程序，发现控制台打印如下：\n\n\n\n```undefined\nINEPerson +load\nINEPerson (INEEat) +load\nINEPerson (INEDrink) +load\n```\n\n于是我们就可以得出结论：**`+load`方法是系统把类和分类载入内存时调用的，**它和我们代码里使用不使用这个类和分类无关。并且因为`+load`方法只会在类和分类被载入内存时调用，所以**每个类和分类的`+load`方法在程序的整个生命周期中肯定会被调用且只调用一次。**\n\n- 调用方式\n\n这里先回想一下，上面第三部分我们说过**分类的方法列表会合并到类本身的方法列表里，并且分类的方法列表还会在类本身方法列表的前面，**因此分类的方法会覆盖掉类里同名的方法。\n\n但不知道你注意没有，上面第1小节的例子，控制台打印了三个东西，也就是说分类的`+load`方法和类的`+load`方法都走了，这很奇怪啊，按理说应该只走其中某一个分类的`+load`方法才对啊，怎么会三个都走呢？也就是说为什么分类的`+load`方法没有覆盖掉类的`+load`方法？\n\n接下来我们就找找运行时（Runtime）的相关源码（`objc-runtime-new.mm`文件），看看能不能得到答案：（伪代码）\n\n\n\n```cpp\n// 系统加载镜像\nvoid load_images()\n{\n    call_load_methods();\n}\n\n// 调用+load方法\nvoid call_load_methods()\n{\n    // 1、首先调用所有类的+load方法\n    call_class_loads();\n\n    // 2、然后调用所有分类的+load方法\n    call_category_loads();\n}\n\n// 调用所有类的+load方法\nstatic void call_class_loads()\n{\n    // 获取到所有的类\n    struct loadable_class *classes = loadable_classes;\n    \n    for (int i = 0; i < loadable_classes_used; i++) {\n        \n        // 获取到某个类\n        Class cls = classes[i].cls;\n        // 获取到某个类+load方法的地址\n        load_method_t load_method = (load_method_t)classes[i].method;\n    \n        // 直接调用该类的+load方法\n        (*load_method)(cls, SEL_load);\n    }\n}\n\n// 调用所有分类的+load方法\nstatic void call_category_loads()\n{\n    // 获取到所有的分类\n    struct loadable_category *cats = loadable_categories;\n    \n    for (i = 0; i < loadable_categories_used; i++) {\n        \n        // 获取到某个分类\n        Category cat = cats[i].cat;\n        // 获取到某个分类+load方法的地址\n        load_method_t load_method = (load_method_t)cats[i].method;\n\n        // 直接调用该分类的+load方法\n        (*load_method)(cls, SEL_load);\n    }\n}\n```\n\n可见**`+load`方法是通过内存地址直接调用的，**而不像普通方法那样走消息发送机制。因此就解释了我们留下的疑惑，虽然说分类的方法列表在类本身方法列表的前面，但是对`+load`方法根本不起作用，人家不走你那一套，**所以分类的`+load`方法不会覆盖类的`+load`方法。**\n\n- 调用顺序\n\n这里就直接给出结论了，感兴趣的话，可以像第2小节那样去看源码（核心代码就集中在上面那几个方法里）并敲代码验证验证。\n\n**会先调用所有类的`+load`方法，先编译的类先调用；如果存在继承关系，那么在调用子类的`+load`方法之前会先去调用父类的`+load`方法。**\n\n**然后再调用所有分类的`+load`方法，先编译的分类先调用。**\n\n###### 4.2 `+initialize`方法\n\n- 调用时机\n\n假设有一个`INEPerson`类和一个继承自`INEPerson`类的`INEStudent`类，并且为`INEStudent`类创建了两个分类`INEEat`和`INEDrink`。\n\n\n\n```objectivec\n-----------INEPerson.m-----------\n\n#import \"INEPerson.h\"\n\n@implementation INEPerson\n\n+ (void)initialize {\n    \n    NSLog(@\"INEPerson +initialize\");\n}\n\n@end\n\n\n-----------INEStudent.m-----------\n\n#import \"INEStudent.h\"\n\n@implementation INEStudent\n\n+ (void)initialize {\n    \n    NSLog(@\"INEStudent +initialize\");\n}\n\n@end\n\n\n-----------INEStudent+INEEat.m-----------\n\n#import \"INEStudent+INEEat.h\"\n\n@implementation INEStudent (INEEat)\n\n+ (void)initialize {\n    \n    NSLog(@\"INEStudent (INEEat) +initialize\");\n}\n\n@end\n\n\n-----------INEStudent+INEDrink.m-----------\n\n#import \"INEStudent+INEDrink.h\"\n\n@implementation INEStudent (INEDrink)\n\n+ (void)initialize {\n    \n    NSLog(@\"INEStudent (INEDrink) +initialize\");\n}\n\n@end\n```\n\n我们什么都不做，直接运行程序，发现控制台什么都没打印。\n\n\n\n```css\n-----------ViewController.m-----------\n\n#import \"ViewController.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n}\n\n@end\n```\n\n此时我们调用一下`Student`类的`+alloc`方法。\n\n\n\n```css\n-----------ViewController.m-----------\n\n#import \"ViewController.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [INEStudent alloc];\n}\n\n@end\n```\n\n运行程序，发现控制台打印如下：\n\n\n\n```undefined\nINEPerson +initialize\nINEStudent (INEDrink) +initialize\n```\n\n于是我们就可以得出结论：**`+initialize`方法是类初始化的时候调用的，**所以严格地来讲，我们不能说“`+initialize`方法是第一次使用类的时候调用的”，你看上面例子中我们根本没使用`INEPerson`类嘛，但它的`+initialize`方法照样被调用了。**如果我们压根儿不使用这个类，它的`+initialize`方法被调用0次，但是我们不能说一个类的`+initialize`方法最多被调用1次，因为`+initialize`方法是通过消息发送机制来调用的，如果好几个子类都继承自某一个类，而这些子类都没有实现自己的`+initialize`方法，那就都会去调用这个父类的`+initialize`方法，这不就是调用N次了嘛。**\n\n- 调用方式\n\n上面第1小节的例子，控制台打印了一个：\n\n\n\n```undefined\nINEStudent (INEDrink) +initialize\n```\n\n这就明显表明：**`+initialize`方法的调用方式不同于`+load`方法，它是通过消息发送机制调用的，所以才会只走分类里面的 `+initialize`方法，也就是说分类的`+initialize`方法会覆盖类的`+initialize`方法。**\n\n但有一点很奇怪，因为控制台还打印了：\n\n\n\n```undefined\nINEPerson +initialize\n```\n\n这是父类的`+initialize`方法呀！既然`+initialize`方法是通过消息发送机制调用的，那它在自己类的内部找到某个方法后，就不应该再调用父类里面的方法了呀，怎么回事？\n\n接下来我们就找找运行时（Runtime）的相关源码（`objc-runtime-new.mm`文件），看看能不能得到答案：（伪代码）\n\n\n\n```cpp\n// 查找方法的实现：类接收到消息后，会去查找这个消息的实现并调用，那我们就从查找这个消息的实现下手吧，前面的源码没有相关信息\nIMP lookUpImpOrForward(Class cls, SEL sel)\n{\n    // 在查找方法的过程中，如果发现这个类没被初始化过\n    if (!cls->isInitialized()) {\n        // 则初始化这个类\n        initializeNonMetaClass(cls);\n    }\n}\n\n// 初始化一个类\nvoid initializeNonMetaClass(Class cls)\n{\n    // 在初始化一个类的过程中\n    Class supercls = cls->superclass;\n    if (supercls  &&  !supercls->isInitialized()) {// 如果发现这个类的父类没被初始化过\n        // 则递归，一层一层地先初始化父类，直到NSObject，直到nil\n        initializeNonMetaClass(supercls);\n        \n        // 一层一层初始化完之后，才会一层一层自上而下地调用各个类的+initialize方法\n        callInitialize(cls);\n    } else {// 如果发现这个类的父类被初始化过了\n        // 则直接初始化自己\n        initializeNonMetaClass(cls);\n        // 并调用自己的+initialize方法，\n        // 如果自己没有实现，则会去找父类的+initialize方法调用。（因为+initialize方法是通过消息发送机制调用的嘛）\n        callInitialize(cls);\n    }\n}\n\nvoid callInitialize(Class cls)\n{\n    // +initialize方法确实是通过消息发送机制调用的\n    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);\n}\n```\n\n可见**系统在调用一个类的`+initialize`方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的`+initialize`方法，然后再初始化自己并调用自己的`+initialize`方法；如果它的父类初始化了，则直接初始化自己并调用自己的`+initialize`方法，如果自己没有实现，则会去找父类的`+initialize`方法调用。**\n\n- 调用顺序\n\n这里就直接给出结论了。\n\n**系统在调用一个类的`+initialize`方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的`+initialize`方法，然后再初始化自己并调用自己的`+initialize`方法；如果它的父类初始化了，则直接初始化自己并调用自己的`+initialize`方法，如果自己没有实现，则会去找父类的`+initialize`方法调用。**\n\n**如果分类里也实现了`+initialize`方法，会优先调用分类的。**\n\n### temp、行文至此，我们举个例子串一下上面的内容\n\n定义一个`INEPerson`类，并为它创建一个分类`INEDrink`，然后创建两个`person`对象。\n\n```objectivec\n-----------INEPerson.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface INEPerson : NSObject <NSCopying>\n\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *sex;\n@property (nonatomic, assign) NSInteger age;\n\n- (void)eat;\n+ (void)sleep;\n\n@end\n\n\n-----------INEPerson.m-----------\n\n#import \"INEPerson.h\"\n\n@implementation INEPerson\n\n- (void)eat {\n    NSLog(@\"对象方法：吃\");\n}\n\n+ (void)sleep {\n    NSLog(@\"类方法：睡\");\n}\n\n- (id)copyWithZone:(nullable NSZone *)zone {\n    // 浅拷贝一下\n    return self;\n}\n\n@end\n```\n\n\n\n```objectivec\n-----------INEPerson+INEDrink.h-----------\n\n#import \"INEPerson.h\"\n\n@interface INEPerson (INEDrink)\n\n- (void)ine_drinkWater;\n+ (void)ine_drinkTea;\n\n@end\n\n\n-----------INEPerson+INEDrink.m-----------\n\n#import \"INEPerson+INEDrink.h\"\n\n@implementation INEPerson (INEDrink)\n\n- (void)ine_drinkWater {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n+ (void)ine_drinkTea {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n\n\n```objectivec\n-----------ViewController.m-----------\n\n#import \"ViewController.h\"\n#import \"INEPerson.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    INEPerson *person1 = [[INEPerson alloc] init];\n    person1.name = @\"张三\";\n    person1.sex = @\"男\";\n    person1.age = 19;\n    [person1 eat];\n    \n    INEPerson *person2 = [[INEPerson alloc] init];\n    person2.name = @\"李四\";\n    person2.sex = @\"女\";\n    person2.age = 18;\n    \n    [INEPerson sleep];\n}\n\n@end\n```\n\n当我们启动App时，系统就会把`INEPerson`类、`INEPerson`类的元类还有`INEPerson`类的分类加载到内存中，然后把分类的数据合并到类和元类里，并且这些类会被存储到静态全局区，因为类只要一份就够了嘛 + 类还得能在项目的任何地方都能访问到，直到杀死App，这些类的内存才会被释放。那么`INEPerson`类在静态全局区的那块内存里存储着什么呢？`isa`指针存储着一个地址，指向`INEPerson`类的元类，这个地址就是`INEPerson`类的元类在静态全局区的内存地址；`superClass`指针存储着一个地址，指向`NSObject`类，这个地址就是`NSObject`类在静态全局区的内存地址；`methods`成员变量存储着`ine_drinkWater`和`eat`这两个实例方法的信息，`properties`成员变量存储着`name`、`sex`、`age`这些属性的信息，`protocols`成员变量存储着`NSCopying`协议的信息，`ivars`成员变量存储着`_name`、`_sex`、`_age`这些成员变量的信息，`cache`缓存着`eat`方法的信息。`INEPerson`类的元类在静态全局区的那块内存里存储着什么呢？`isa`指针存储着一个地址，指向基类`NSObject`类的元类，这个地址就是基类`NSObject`类的元类在静态全局区的内存地址；`superClass`指针存储着一个地址，同样指向基类`NSObject`类的元类，这个地址就是基类`NSObject`类的元类在静态全局区的内存地址；`methods`成员变量存储着`ine_drinkTea`和`sleep`这个类方法的信息，`cache`缓存着`sleep`方法的信息。\n\n当我们`alloc init`一个`person`对象时，就会在堆区分配一块内存，直到没有强引用引用这个对象了，这块内存才会被释放。那么`person`对象在堆区的那块内存里存储着什么呢？`isa`指针存储着一个地址，指向`INEPerson`类，这个地址就是`INEPerson`类在静态全局区的内存地址；`person1`对象接下来会存储`_name`成员变量的值\"张三\"，当然它存储的也是一个常量区的地址，指向\"张三\"这个字符串常量，还有`_sex`成员变量的值\"男\"，当然它存储的也是一个常量区的地址，指向\"男\"这个字符串常量，还有`_age`成员变量的值“19”，当然“19”就是直接存储了，因为它是个立即数；`person2`对象接下来则会存储`_name`成员变量的值\"李四\"，`_sex`成员变量的值\"女\"，`_age`成员变量的值“18”，注意对象的内存里存储的是成员变量的值，而类的内存里存储的是成员变量的信息——比如`INEPerson`类有一个成员变量是“_name”，它的类型是`NSString`这样。","source":"_posts/对象、类、元类、分类的本质.md","raw":"---\ntitle: 【Runtime】对象、类、元类、分类的本质\ndate: 2021-07-13 09:31:03\ntags: Runtime系列\n---\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713093308752.png)\n\n### 序言\n\n弄明白对象、类、元类内存里存储的是什么东西就行\n\n<!--more-->\n\n> 一、对象的本质\n>\n> 二、类的本质\n>\n> 三、元类的本质\n>\n> 四、分类的本质\n\n> 2006年苹果发布了OC2.0，其中对Runtime的很多API做了改进，并把OC1.0中Runtime的很多API标记为“将来会被废弃”。 但是两套API的核心实现思路还是一样的，而旧API比较简单，所以我们会分析旧API，然后看看新API作了哪些变化，这里有[最新的Runtime源码](https://links.jianshu.com/go?to=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2Fobjc4%2F)。\n\n### 一、对象的本质\n\n#### 1、OC1.0\n\n通过查看RunTIme的源码（`objc.h`文件），我们得到对象的定义如下（伪代码）：\n\n```objectivec\nstruct objc_object {\n    // 固定的成员变量\n    Class isa;\n\n    // 我们自定义的成员变量\n    NSSring *_name;\n    NSSring *_sex;\n    int _age;\n};\n\ntypedef struct objc_object *id; // id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象\n```\n\n可见对象的本质就是一个`objc_object`类型的结构体。该结构体内部只有一个固定的成员变量`isa`，它是一个`Class`类型的结构体指针，存储着一个地址，指向该对象所属的类。当然结构体内部还可能有很多我们自定义的成员变量，存储着该对象这些成员变量具体的值。\n\n#### 2、OC2.0\n\n通过查看Runtime的源码（`objc-private.h`文件），我们得到对象的定义如下（伪代码）：\n\n```cpp\nstruct objc_object {\n    // 固定的成员变量\n    isa_t isa;\n\n    // 自定义的成员变量\n    NSSring *_name;\n    NSSring *_sex;\n    int _age;\n}\n\n// 共用体isa_t\n//\n// 共用体也是C语言的一种数据类型，和结构体差不多，\n// 都可以定义很多的成员变量，但两者的主要区别就在于内存的使用。\n//\n// 一个结构体占用的内存等于它所有成员变量占用内存之和，而且要遵守内存对齐规则，而一个共用体占用的内存等于它最宽成员变量占用的内存。\n// 结构体里所有的成员变量各自有各自的内存，而共用体里所有的成员变量共用这一块内存。\n// 所以共用体可以更加节省内存，但是我们要把数据处理好，否则很容易出现数据覆盖。\nunion isa_t {\n    Class cls;\n    \n    unsigned long bits; // 8个字节，64位\n    struct { // 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着什么数据\n# if __arm64__\n#   define ISA_MASK        0x0000000ffffffff8ULL\n        unsigned long nonpointer        : 1;\n        unsigned long has_assoc         : 1;\n        unsigned long has_cxx_dtor      : 1;\n        unsigned long shiftcls          : 33; // 当前对象所属类的地址信息\n        unsigned long magic             : 6;\n        unsigned long weakly_referenced : 1; // 当前对象是否有弱引用\n        unsigned long deallocating      : 1;\n        unsigned long has_sidetable_rc  : 1; // 引用计数表里是否有当前对象的引用计数\n        unsigned long extra_rc          : 19; // 对象的引用计数 - 1，存不下了就会放到引用计数表里\n# endif\n    };\n};\n\ntypedef struct objc_object *id; // id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象\n```\n\n可见对象的本质还是一个`objc_object`类型结构体。该结构体内部也还只有一个固定成员变量`isa`，只不过64位操作系统以后，对`isa`做了内存优化，它不再直接是一个指针，而是一个`isa_t`类型的共用体，它同样占用8个字节64位，但其中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1）、存储不下就放到引用计数表里，还有一位用来存储对象是否有弱引用，其他位上则存储这各种各样的标记信息。\n\n- `nonpointer`：占1位，标记`isa`是否经过内存优化。如果值为0，代表`isa`没经过内存优化，它就是一个普通的`isa`指针，64位全都用来存储该对象所属类的地址；如果值为1，代表`isa`经过了内存优化，只有33位用来存储对象所属类的地址信息，其它位则另有用途，了解一下即可；\n- `has_assoc`：占1位，标记当前对象是否有关联对象，如果没有，对象销毁时会更快，了解一下即可；\n- `has_cxx_dtor`：占1位，标记当前对象是否有C++析构函数，如果没有，对象销毁时会更快，了解一下即可；\n- **`shiftcls`：占33位，存储着当前对象所属类的地址信息；**\n- `magic`：占1位，用来标记在调试时当前对象是否未完成初始化，了解一下即可；\n- **`weakly_referenced`：占1位，标记弱引用表里是否有当前对象的弱指针数组——即当前对象是否被弱指针指向着、当前对象是否有弱引用；**\n- `deallocating`：占1位，标记当前对象是否正在释放，了解一下即可；\n- **`has_sidetable_rc`：占1位，标记引用计数表里是否有当前对象的引用计数；**\n- **`extra_rc`：占19位，存储着（对象的引用计数 - 1），存不下了就会放到引用计数表里，存值范围为0~255。**\n\n### 二、类的本质\n\n#### 1、OC1.0\n\n通过查看Runtime的源码（`runtime.h`文件），我们得到类的定义如下（伪代码）：\n可见类的本质就是一个`objc_class`类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：\n\n```cpp\nstruct objc_class {\n    Class isa;\n    Class super_class;\n\n    method_array_t methods;\n    property_array_t properties;\n    protocol_array_t protocols;\n    const ivar_list_t *ivars;\n\n    cache_t cache;\n   \n    const char *name;\n    long instance_size;\n    long version;\n    long info;\n};\n\ntypedef struct objc_class *Class; // Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类\n```\n\n- **`isa指针`：存储着一个地址，指向该类所属的类——即元类；**\n- **`superclass指针`：存储着一个地址，指向该类的父类；**\n- **`methods`：数组指针，存储着该类所有的实例方法信息；**\n- **`properties`：数组指针，存储着该类所有的属性信息；**\n- **`protocols`：数组指针，存储着该类所有遵守的协议信息；**\n- **`ivars`：数组指针，存储着该类所有的成员变量信息；**\n- **`cache`：结构体，存储着该类所有的方法缓存信息。**\n\n#### 2、OC2.0\n\n通过查看Runtime的源码（`objc-runtime-new.h`文件），我们得到类的定义如下（伪代码）\n\n```objective-c\nstruct objc_class : objc_object {\n//    isa_t isa; // objc_class继承自objc_object，所以不考虑内存对齐的前提下，可以直接把isa成员变量搬过来\n    Class superclass;\n    \n    class_data_bits_t bits; // 存储着该类的具体信息，按位与掩码FAST_DATA_MASK便可得到class_rw_t\n    \n    cache_t cache;\n}\n\n// class_rw_t结构体就是该类的可读可写信息（rw即readwrite）\nstruct class_rw_t {\n    uint32_t flags;\n    uint32_t version;\n\n    const class_ro_t *ro; // 该类的只读信息\n\n    method_array_t methods; // 存储着该类所有的实例方法信息，包括分类的\n    property_array_t properties; // 存储着该类所有的属性信息，包括分类的\n    protocol_array_t protocols; // 存储着该类所有遵守的协议信息，包括分类的\n\n    Class firstSubclass;\n    Class nextSiblingClass;\n\n    char *demangledName;\n}\n\n// class_ro_t结构体就是该类的只读信息（ro即readonly）\nstruct class_ro_t {\n    uint32_t flags;\n    uint32_t instanceStart;\n    uint32_t instanceSize;\n#ifdef __LP64__\n    uint32_t reserved;\n#endif\n\n    const uint8_t * ivarLayout;\n    \n    const char * name;\n    method_list_t * baseMethodList; // 存储着该类本身的实例方法信息\n    protocol_list_t * baseProtocols; // 存储着该类本身遵守的协议信息\n    const ivar_list_t * ivars; // 存储着该类本身的成员变量信息\n\n    const uint8_t * weakIvarLayout;\n    property_list_t *baseProperties; // 存储着该类本身的属性信息\n}\n\ntypedef struct objc_class *Class; // Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类\n```\n\n可见类的本质还是一个`objc_class`类型的结构体，我们重点关注的那几个成员变量还是可以顺利找到的，只不过它内部结构套了两层`rw`和`ro`，我们先说一下`ro`，`ro`内部存储着经过编译后一个类本身定义的所有实例方法、属性、协议、成员变量，它是只读的，然后运行时才会生成`rw`，把`ro`里类本身定义的所有实例方法、属性、协议搞到`rw`里，并把这个类所有分类的实例方法、属性、协议合并到`rw`里，`rw`是可读写的，这在解释“分类为什么不能给类扩展成员变量”提供了一个很好的证据。\n\n### 三、元类的本质\n\n所谓元类，是指一个类所属的类，我们每创建一个类，系统就会自动帮我们创建好该类所属的类——即元类。如果你觉得不太好理解，这里就多说两句：我们常说“在面向对象编程里，万事万物皆对象”，因此在OC里对象其实分为实例对象、类对象、元类对象三类，我们开发中经常说的“对象”其实是指狭义的对象——实例对象，知道了这一点就好理解了，实例对象有它所属的类——即一个类对象，类对象也有它所属的类——即一个元类对象，元类对象也有它所属的类——即基类的元类对象。\n\n**其实元类和类的本质都是`objc_class`结构体，只不过它们的用途不一样，类的`methods`成员变量里存储着该类所有的实例方法信息，而元类的`methods`成员变量里存储着该类所有的类方法信息。**\n\n### 四、分类的本质\n\n#### 1、分类是什么，我们一般用分类做什么\n\n**分类是OC的一个高级特性，我们一般用它来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现。**\n\n举个简单例子：\n\n比如我们给`NSObject`类扩展一个`test`方法。\n\n```objectivec\n-----------NSObject+INETest.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface NSObject (INETest)\n\n- (void)ine_test;\n\n@end\n\n\n-----------NSObject+INETest.m-----------\n\n#import \"NSObject+INETest.h\"\n\n@implementation NSObject (INETest)\n\n- (void)ine_test {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n比如我们有一个`INEPerson`类，保持它的主体，然后把它“吃”、“喝”的功能分散到不同的模块里去实现。\n\n```objectivec\n-----------INEPerson.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface INEPerson : NSObject\n\n@property (nonatomic, assign) NSInteger age;\n\n@end\n\n\n-----------INEPerson.m-----------\n\n#import \"INEPerson.h\"\n\n@implementation INEPerson\n\n@end\n```\n\n```objectivec\n-----------INEPerson+INEEat.h-----------\n\n#import \"INEPerson.h\"\n\n@interface INEPerson (INEEat)\n\n- (void)ine_eat;\n\n@end\n\n\n-----------INEPerson+INEEat.m-----------\n\n#import \"INEPerson+INEEat.h\"\n\n@implementation INEPerson (INEEat)\n\n- (void)ine_eat {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n```objectivec\n-----------INEPerson+INEDrink.h-----------\n\n#import \"INEPerson.h\"\n\n@interface INEPerson (INEDrink)\n\n- (void)ine_drink;\n\n@end\n\n\n-----------INEPerson+INEDrink.m-----------\n\n#import \"INEPerson+INEDrink.h\"\n\n@implementation INEPerson (INEDrink)\n\n- (void)ine_drink {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n```dart\n-----------ViewController.m-----------\n\n#import \"INEPerson.h\"\n#import \"INEPerson+INEEat.h\"\n#import \"INEPerson+INEDrink.h\"\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    INEPerson *person = [[INEPerson alloc] init];\n    [person ine_eat];// INEPerson (INEEat) eat\n    [person ine_drink];// INEPerson (INEDrink) drink\n}\n```\n\n> 分类和延展的区别：\n>\n> - **分类一般用来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现；而延展一般用来给我们自定义的类添加私有属性。**\n> - **分类的数据不是在编译时就合并到类里面的，而是在运行时；而延展的数据是在编译时就合并到类里面的。**\n\n#### 2、分类的本质\n\n通过查看Runtime的源码（`objc-runtime-new.h`文件），我们得到分类的定义如下：（伪代码）\n\n```objective-c\nstruct category_t {\n    const char *name; // 该分类所属的类的名字\n    struct classref *cls; // 指向该分类所属的类\n    struct method_list_t *instanceMethods;\n    struct method_list_t *classMethods;\n    struct protocol_list_t *protocols;\n    struct property_list_t *instanceProperties;\n};\n\ntypedef struct category_t *Category;\n```\n\n可见分类的本质是一个`category_t`类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：\n\n- **`classMethods`：该分类为类扩展的类方法列表；**\n- **`instanceMethods`：该分类为类扩展的实例方法列表；**\n- **`instanceProperties`：该分类为类扩展的属性列表；**\n- **`protocols`：该分类为类扩展的协议列表。**\n\n注意分类的本质里没有“该分类为类扩展的成员变量列表”喔，这在解释“为什么分类不能给类扩展成员变量”时又是一个很好的证据。\n\n#### 3、分类的实现原理\n\n我们知道一个类所有的实例方法都存储在类里面，所有的类方法都存储在元类里面，而对象调用方法的流程就是根据`isa`指针先找到相应的类或元类，然后在类或元类里再找到相应的方法来调用，那`person`对象是怎么找到分类里的`ine_eat`和`ine_drink`方法来调用的呢？\n\n现在我们可以大胆猜测，因为对象内部只有一个`isa`指针，指向它所属的类，所以不可能再有一套类似的方法查找机制让它专门去分类里面查找方法，难道系统会把分类里的方法合并到类里面去？如果会合并的话，那是编译时合并的，还是运行时合并的？很简单，我们只需要看看编译后类里面是否已经包含了分类的方法就行。\n\n> 先给出结论：**系统不是在编译时让编译器把分类的数据合并到类、元类里面的，而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的，而且分类的数据还放在类本身数据的前面，越晚编译的分类越在前面，所以如果分类里面有和类里面同名的方法，会优先调用分类里面的方法，如果多个分类里面有同名的方法，会优先调用后编译分类里面的方法，我们可以去Compile Sources里控制分类编译的顺序。**\n\n- 系统不是在编译时让编译器把分类的数据合并到类、元类里面的\n\n接着上面`INEPerson`类的例子，我们用`clang`编译器把`INEPerson.m`文件转换成C/C++代码，以便窥探编译后`INEPerson`类里面是否已经包含了分类的方法。\n\n```objective-c\nstruct objc_class OBJC_CLASS_$_INEPerson = {\n    0, // &OBJC_METACLASS_$_INEPerson,\n    0, // &OBJC_CLASS_$_NSObject,\n    0, // (void *)&_objc_empty_cache,\n    \n    // 可读可写的\n    [\"age\", \"setAge:\"], // 所有的实例方法\n    [\"age\"], // 所有的属性\n    [], // 所有遵循的协议\n    \n    // 只读的\n    \"INEPerson\", // 类名\n    [\"_age\"], // 所有的成员变量\n    16, // 实例对象的实际大小\n};\n```\n\n可见经过编译后，`INEPerson`类里面的数据还是它本身拥有的那些数据，并没有分类的方法，这就表明系统不是在编译时让编译器把分类的数据合并到类、元类里面的。\n\n- 而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的\n\n既然系统不是在编译时就把分类的数据合并到类里面的，那就只能是在运行时了，接下来我们就找找运行时（Runtime）的相关源码（`objc-runtime-new.mm`文件），看看系统到底是怎么把分类合并到类里面的：\n\n运行时，系统读取镜像阶段，会读取所有的类，并且如果发现有分类，也会读取所有的分类，然后遍历所有的分类，根据分类的`cls指针`找到它所属的类，重新组织一下这个类的内部结构——即合并分类的数据。\n\n```objective-c\n// 系统读取镜像\nvoid _read_images()\n{\n    // 读取所有的类\n    // ...\n\n    // 发现有分类\n    // 读取所有的分类\n    category_t **catlist = _getObjc2CategoryList(hi, &count);\n    // 遍历所有的分类\n    for (i = 0; i < count; i++) {\n        // 读取某一个分类\n        category_t *cat = catlist[I];\n        \n        // 根据分类的cls指针找到它所属的类\n        Class cls = cat->cls;\n        // 重新组织一下这个类的内部结构——即合并分类的数据\n        remethodizeClass(cls);\n    }\n}\n```\n\n那具体怎么个合并法呢？**系统会去获取这个类所有的分类，然后倒序遍历这所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里**（因为是倒序遍历分类的，所以越晚编译的分类的实例方法列表反而越会放在二维数组的前面），**然后再把这个二维数组内所有一维数组的首地址复制进`methods`成员变量指向的那块内存里（注意这个存储过程会把类本身的实例方法列表挪到最后——即高内存地址上，而把分类的实例方法列表存在前面）。**\n\n```objective-c\n// 重新组织一下这个类的内部结构——即合并分类的数据\nstatic void remethodizeClass(Class cls)\n{\n    // 系统会去获取这个类所有的分类（没有合并过的）\n    category_list *cats = unattachedCategoriesForClass(cls);\n    // 把所有分类的数据合并到类里面\n    attachCategories(cls, cats);\n    free(cats);\n}\n\n/**\n * 把所有分类的数据合并到类里面\n *\n * @param cls 当前类\n * @param cats 当前类所有的分类\n */\nstatic void attachCategories(Class cls, category_list *cats)\n{\n#pragma mark - 倒序遍历所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里\n    /*\n     创建一个二维数组，用来存放每个分类里的实例方法列表，最终结果类似下面这样：\n     [\n        [instanceMethod1, instanceMethod2, ...] --> 分类1所有实例方法\n        [instanceMethod1, instanceMethod2, ...] --> 分类2所有实例方法\n        ...\n     ]\n     */\n    method_list_t **mlists = (method_list_t **) malloc(cats->count * sizeof(*mlists));\n    \n    // 属性\n    property_list_t **proplists = (property_list_t **) malloc(cats->count * sizeof(*proplists));\n    \n    // 协议\n    protocol_list_t **protolists = (protocol_list_t **) malloc(cats->count * sizeof(*protolists));\n    \n    int mcount = 0;\n    int propcount = 0;\n    int protocount = 0;\n    int i = cats->count;\n    // 注意：这里是倒序遍历所有的分类\n    while (i--) {\n        // 获取一个分类\n        auto cat = cats[I];\n        \n        // 获取分类的实例方法列表，存进二维数组\n        method_list_t *mlist = cat->methods;\n        mlists[mcount++] = mlist;\n        \n        // 属性\n        protocol_list_t *protolist = cat->protocols;\n        protolists[protocount++] = protolist;\n        \n        // 协议\n        property_list_t *proplist = cat->properties;\n        proplists[propcount++] = proplist;\n    }\n    \n    \n#pragma mark - 把这个二维数组内所有一维数组的首地址存进methods成员变量所指向的那块内存空间里\n    \n    // 获取当前类的数据（包括实例方法列表、属性列表、协议列表等）\n    auto classData = cls->data();\n    \n    // 给当前类的实例方法列表附加所有分类的实例方法列表\n    classData->methods.attachLists(mlists, mcount);\n    free(mlists);\n    \n    // 属性\n    classData->properties.attachLists(proplists, propcount);\n    free(proplists);\n    \n    // 协议\n    classData->protocols.attachLists(protolists, protocount);\n    free(protolists);\n}\n\n/**\n * 给当前类的实例方法列表附加所有分类的实例方法列表\n *\n * @param addedLists 所有分类的实例方法列表（就是那个二维数组，但其实是那个二维数组的首地址）\n * @param addedCount 分类的个数\n */\nvoid attachLists(List* const * addedLists, unsigned int addedCount) {\n#pragma mark - 重新为类的methods成员变量分配内存\n    // 获取类原来methods成员变量的元素个数（注意：一个类的methods成员变量是一个数组，存储着若干个指针，指向相应的方法列表，而不是直接就是个方法列表存储方法）\n    unsigned int oldCount = array()->count;\n    // 加上分类的个数，得到新的methods成员变量该有多少个元素\n    unsigned int newCount = oldCount + addedCount;\n    // 重新为methods成员变量所指向的数组分配内存，一个指针占8个字节\n    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));\n    array()->count = newCount;\n    \n    \n#pragma mark - 为类的methods成员变量重新分配完内存后，对其内存数据进行移动和复制操作\n    //\n    /*\n     内存复制：\n     memmove(dst, src, len)，从src所指向的内存空间复制len个字节的数据到dst所指向的内存空间，内部处理了内存覆盖。\n     memcpy(dst, src, n)，从src所指向的内存空间复制n个字节的数据到dst所指向的内存空间，内部没处理内存覆盖。\n     */\n    // 把类原来的实例方法列表复制到最后面（但其实是把类原来的实例方法列表，在methods成员变量里对应的那个指针————原来的实例方法列表的首地址————复制到最后面了）\n    memmove(array()->lists + addedCount, array()->lists,\n            oldCount * sizeof(array()->lists[0]));\n    // 把所有分类的实例方法列表放在前面（同理，其实是把所有分类的的实例方法列表的首地址复制到前面了，因为methods成员变量里存放的是指针————即实例方法列表的地址，不过这里二维数组的内存拷贝会拷贝它里面所有一维数组的首地址，而不仅仅这个二维数组的首地址）\n    memcpy(array()->lists, addedLists,\n           addedCount * sizeof(array()->lists[0]));\n}\n```\n\n这样就把所有分类的实例方法列表全都合并到类里面去了，最终类的方法列表结构如下：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713113333032.png)\n\n以上我们只是说明了分类为类扩展实例方法的底层实现，至于分类为类扩展类方法、属性、协议是同理的。\n\n#### 4、分类的`+load`方法和`+initialize`方法\n\n|                   |                  调用时机                   |                           调用方式                           |                           调用顺序                           |\n| :---------------: | :-----------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n|    `+load`方法    | `+load`方法是系统把类和分类载入内存时调用的 | `+load`方法是通过内存地址直接调用的，所以分类的`+load`方法不会覆盖类的`+load`方法，也就是说如果类和分类里面都实现了`+load`方法，那么它们都会被调用 | 会先调用所有类的`+load`方法，然后再调用所有分类的`+load`方法 |\n| `+initialize`方法 |   `+initialize`方法是类初始化的时候调用的   | `+initialize`方法是通过消息发送机制调用的，所以分类的`+initialize`方法会覆盖类的`+initialize`方法，也就是说如果类和分类里面都实现了`+initialize`方法，那么只有分类里面的会被调用 |              会优先调用分类的`+initialize`方法               |\n\n> 苹果提供类、分类的`+load`方法和`+initialize`方法，其实就是给我们开发者暴露两个接口，让我们根据这俩方法的特点来合理使用。比如我们想在某个类被载入内存时做一些事情，就可以在`+load`方法里做操作，想在某个类初始化时做一些事情，就可以在`+initialize`方法里做操作。\n\n###### 4.1 `+load`方法\n\n- 调用时机\n\n假设有一个`INEPerson`类，并且为它创建了两个分类`INEEat`和`INEDrink`。\n\n\n\n```objectivec\n-----------INEPerson.m-----------\n\n#import \"INEPerson.h\"\n\n@implementation INEPerson\n\n+ (void)load {\n    \n    NSLog(@\"INEPerson +load\");\n}\n\n@end\n\n\n-----------INEPerson+INEEat.m-----------\n\n#import \"INEPerson+INEEat.h\"\n\n@implementation INEPerson (INEEat)\n\n+ (void)load {\n    \n    NSLog(@\"INEPerson (INEEat) +load\");\n}\n\n@end\n\n\n-----------INEPerson+INEDrink.m-----------\n\n#import \"INEPerson+INEDrink.h\"\n\n@implementation INEPerson (INEDrink)\n\n+ (void)load {\n    \n    NSLog(@\"INEPerson (INEDrink) +load\");\n}\n\n@end\n```\n\n我们什么都不做，不使用`Person`类，甚至连它的头文件也不导入。\n\n\n\n```css\n-----------ViewController.m-----------\n\n#import \"ViewController.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n}\n\n@end\n```\n\n直接运行程序，发现控制台打印如下：\n\n\n\n```undefined\nINEPerson +load\nINEPerson (INEEat) +load\nINEPerson (INEDrink) +load\n```\n\n于是我们就可以得出结论：**`+load`方法是系统把类和分类载入内存时调用的，**它和我们代码里使用不使用这个类和分类无关。并且因为`+load`方法只会在类和分类被载入内存时调用，所以**每个类和分类的`+load`方法在程序的整个生命周期中肯定会被调用且只调用一次。**\n\n- 调用方式\n\n这里先回想一下，上面第三部分我们说过**分类的方法列表会合并到类本身的方法列表里，并且分类的方法列表还会在类本身方法列表的前面，**因此分类的方法会覆盖掉类里同名的方法。\n\n但不知道你注意没有，上面第1小节的例子，控制台打印了三个东西，也就是说分类的`+load`方法和类的`+load`方法都走了，这很奇怪啊，按理说应该只走其中某一个分类的`+load`方法才对啊，怎么会三个都走呢？也就是说为什么分类的`+load`方法没有覆盖掉类的`+load`方法？\n\n接下来我们就找找运行时（Runtime）的相关源码（`objc-runtime-new.mm`文件），看看能不能得到答案：（伪代码）\n\n\n\n```cpp\n// 系统加载镜像\nvoid load_images()\n{\n    call_load_methods();\n}\n\n// 调用+load方法\nvoid call_load_methods()\n{\n    // 1、首先调用所有类的+load方法\n    call_class_loads();\n\n    // 2、然后调用所有分类的+load方法\n    call_category_loads();\n}\n\n// 调用所有类的+load方法\nstatic void call_class_loads()\n{\n    // 获取到所有的类\n    struct loadable_class *classes = loadable_classes;\n    \n    for (int i = 0; i < loadable_classes_used; i++) {\n        \n        // 获取到某个类\n        Class cls = classes[i].cls;\n        // 获取到某个类+load方法的地址\n        load_method_t load_method = (load_method_t)classes[i].method;\n    \n        // 直接调用该类的+load方法\n        (*load_method)(cls, SEL_load);\n    }\n}\n\n// 调用所有分类的+load方法\nstatic void call_category_loads()\n{\n    // 获取到所有的分类\n    struct loadable_category *cats = loadable_categories;\n    \n    for (i = 0; i < loadable_categories_used; i++) {\n        \n        // 获取到某个分类\n        Category cat = cats[i].cat;\n        // 获取到某个分类+load方法的地址\n        load_method_t load_method = (load_method_t)cats[i].method;\n\n        // 直接调用该分类的+load方法\n        (*load_method)(cls, SEL_load);\n    }\n}\n```\n\n可见**`+load`方法是通过内存地址直接调用的，**而不像普通方法那样走消息发送机制。因此就解释了我们留下的疑惑，虽然说分类的方法列表在类本身方法列表的前面，但是对`+load`方法根本不起作用，人家不走你那一套，**所以分类的`+load`方法不会覆盖类的`+load`方法。**\n\n- 调用顺序\n\n这里就直接给出结论了，感兴趣的话，可以像第2小节那样去看源码（核心代码就集中在上面那几个方法里）并敲代码验证验证。\n\n**会先调用所有类的`+load`方法，先编译的类先调用；如果存在继承关系，那么在调用子类的`+load`方法之前会先去调用父类的`+load`方法。**\n\n**然后再调用所有分类的`+load`方法，先编译的分类先调用。**\n\n###### 4.2 `+initialize`方法\n\n- 调用时机\n\n假设有一个`INEPerson`类和一个继承自`INEPerson`类的`INEStudent`类，并且为`INEStudent`类创建了两个分类`INEEat`和`INEDrink`。\n\n\n\n```objectivec\n-----------INEPerson.m-----------\n\n#import \"INEPerson.h\"\n\n@implementation INEPerson\n\n+ (void)initialize {\n    \n    NSLog(@\"INEPerson +initialize\");\n}\n\n@end\n\n\n-----------INEStudent.m-----------\n\n#import \"INEStudent.h\"\n\n@implementation INEStudent\n\n+ (void)initialize {\n    \n    NSLog(@\"INEStudent +initialize\");\n}\n\n@end\n\n\n-----------INEStudent+INEEat.m-----------\n\n#import \"INEStudent+INEEat.h\"\n\n@implementation INEStudent (INEEat)\n\n+ (void)initialize {\n    \n    NSLog(@\"INEStudent (INEEat) +initialize\");\n}\n\n@end\n\n\n-----------INEStudent+INEDrink.m-----------\n\n#import \"INEStudent+INEDrink.h\"\n\n@implementation INEStudent (INEDrink)\n\n+ (void)initialize {\n    \n    NSLog(@\"INEStudent (INEDrink) +initialize\");\n}\n\n@end\n```\n\n我们什么都不做，直接运行程序，发现控制台什么都没打印。\n\n\n\n```css\n-----------ViewController.m-----------\n\n#import \"ViewController.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n}\n\n@end\n```\n\n此时我们调用一下`Student`类的`+alloc`方法。\n\n\n\n```css\n-----------ViewController.m-----------\n\n#import \"ViewController.h\"\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [INEStudent alloc];\n}\n\n@end\n```\n\n运行程序，发现控制台打印如下：\n\n\n\n```undefined\nINEPerson +initialize\nINEStudent (INEDrink) +initialize\n```\n\n于是我们就可以得出结论：**`+initialize`方法是类初始化的时候调用的，**所以严格地来讲，我们不能说“`+initialize`方法是第一次使用类的时候调用的”，你看上面例子中我们根本没使用`INEPerson`类嘛，但它的`+initialize`方法照样被调用了。**如果我们压根儿不使用这个类，它的`+initialize`方法被调用0次，但是我们不能说一个类的`+initialize`方法最多被调用1次，因为`+initialize`方法是通过消息发送机制来调用的，如果好几个子类都继承自某一个类，而这些子类都没有实现自己的`+initialize`方法，那就都会去调用这个父类的`+initialize`方法，这不就是调用N次了嘛。**\n\n- 调用方式\n\n上面第1小节的例子，控制台打印了一个：\n\n\n\n```undefined\nINEStudent (INEDrink) +initialize\n```\n\n这就明显表明：**`+initialize`方法的调用方式不同于`+load`方法，它是通过消息发送机制调用的，所以才会只走分类里面的 `+initialize`方法，也就是说分类的`+initialize`方法会覆盖类的`+initialize`方法。**\n\n但有一点很奇怪，因为控制台还打印了：\n\n\n\n```undefined\nINEPerson +initialize\n```\n\n这是父类的`+initialize`方法呀！既然`+initialize`方法是通过消息发送机制调用的，那它在自己类的内部找到某个方法后，就不应该再调用父类里面的方法了呀，怎么回事？\n\n接下来我们就找找运行时（Runtime）的相关源码（`objc-runtime-new.mm`文件），看看能不能得到答案：（伪代码）\n\n\n\n```cpp\n// 查找方法的实现：类接收到消息后，会去查找这个消息的实现并调用，那我们就从查找这个消息的实现下手吧，前面的源码没有相关信息\nIMP lookUpImpOrForward(Class cls, SEL sel)\n{\n    // 在查找方法的过程中，如果发现这个类没被初始化过\n    if (!cls->isInitialized()) {\n        // 则初始化这个类\n        initializeNonMetaClass(cls);\n    }\n}\n\n// 初始化一个类\nvoid initializeNonMetaClass(Class cls)\n{\n    // 在初始化一个类的过程中\n    Class supercls = cls->superclass;\n    if (supercls  &&  !supercls->isInitialized()) {// 如果发现这个类的父类没被初始化过\n        // 则递归，一层一层地先初始化父类，直到NSObject，直到nil\n        initializeNonMetaClass(supercls);\n        \n        // 一层一层初始化完之后，才会一层一层自上而下地调用各个类的+initialize方法\n        callInitialize(cls);\n    } else {// 如果发现这个类的父类被初始化过了\n        // 则直接初始化自己\n        initializeNonMetaClass(cls);\n        // 并调用自己的+initialize方法，\n        // 如果自己没有实现，则会去找父类的+initialize方法调用。（因为+initialize方法是通过消息发送机制调用的嘛）\n        callInitialize(cls);\n    }\n}\n\nvoid callInitialize(Class cls)\n{\n    // +initialize方法确实是通过消息发送机制调用的\n    ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);\n}\n```\n\n可见**系统在调用一个类的`+initialize`方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的`+initialize`方法，然后再初始化自己并调用自己的`+initialize`方法；如果它的父类初始化了，则直接初始化自己并调用自己的`+initialize`方法，如果自己没有实现，则会去找父类的`+initialize`方法调用。**\n\n- 调用顺序\n\n这里就直接给出结论了。\n\n**系统在调用一个类的`+initialize`方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的`+initialize`方法，然后再初始化自己并调用自己的`+initialize`方法；如果它的父类初始化了，则直接初始化自己并调用自己的`+initialize`方法，如果自己没有实现，则会去找父类的`+initialize`方法调用。**\n\n**如果分类里也实现了`+initialize`方法，会优先调用分类的。**\n\n### temp、行文至此，我们举个例子串一下上面的内容\n\n定义一个`INEPerson`类，并为它创建一个分类`INEDrink`，然后创建两个`person`对象。\n\n```objectivec\n-----------INEPerson.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface INEPerson : NSObject <NSCopying>\n\n@property (nonatomic, copy) NSString *name;\n@property (nonatomic, copy) NSString *sex;\n@property (nonatomic, assign) NSInteger age;\n\n- (void)eat;\n+ (void)sleep;\n\n@end\n\n\n-----------INEPerson.m-----------\n\n#import \"INEPerson.h\"\n\n@implementation INEPerson\n\n- (void)eat {\n    NSLog(@\"对象方法：吃\");\n}\n\n+ (void)sleep {\n    NSLog(@\"类方法：睡\");\n}\n\n- (id)copyWithZone:(nullable NSZone *)zone {\n    // 浅拷贝一下\n    return self;\n}\n\n@end\n```\n\n\n\n```objectivec\n-----------INEPerson+INEDrink.h-----------\n\n#import \"INEPerson.h\"\n\n@interface INEPerson (INEDrink)\n\n- (void)ine_drinkWater;\n+ (void)ine_drinkTea;\n\n@end\n\n\n-----------INEPerson+INEDrink.m-----------\n\n#import \"INEPerson+INEDrink.h\"\n\n@implementation INEPerson (INEDrink)\n\n- (void)ine_drinkWater {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n+ (void)ine_drinkTea {\n    \n    NSLog(@\"%s\", __func__);\n}\n\n@end\n```\n\n\n\n```objectivec\n-----------ViewController.m-----------\n\n#import \"ViewController.h\"\n#import \"INEPerson.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    INEPerson *person1 = [[INEPerson alloc] init];\n    person1.name = @\"张三\";\n    person1.sex = @\"男\";\n    person1.age = 19;\n    [person1 eat];\n    \n    INEPerson *person2 = [[INEPerson alloc] init];\n    person2.name = @\"李四\";\n    person2.sex = @\"女\";\n    person2.age = 18;\n    \n    [INEPerson sleep];\n}\n\n@end\n```\n\n当我们启动App时，系统就会把`INEPerson`类、`INEPerson`类的元类还有`INEPerson`类的分类加载到内存中，然后把分类的数据合并到类和元类里，并且这些类会被存储到静态全局区，因为类只要一份就够了嘛 + 类还得能在项目的任何地方都能访问到，直到杀死App，这些类的内存才会被释放。那么`INEPerson`类在静态全局区的那块内存里存储着什么呢？`isa`指针存储着一个地址，指向`INEPerson`类的元类，这个地址就是`INEPerson`类的元类在静态全局区的内存地址；`superClass`指针存储着一个地址，指向`NSObject`类，这个地址就是`NSObject`类在静态全局区的内存地址；`methods`成员变量存储着`ine_drinkWater`和`eat`这两个实例方法的信息，`properties`成员变量存储着`name`、`sex`、`age`这些属性的信息，`protocols`成员变量存储着`NSCopying`协议的信息，`ivars`成员变量存储着`_name`、`_sex`、`_age`这些成员变量的信息，`cache`缓存着`eat`方法的信息。`INEPerson`类的元类在静态全局区的那块内存里存储着什么呢？`isa`指针存储着一个地址，指向基类`NSObject`类的元类，这个地址就是基类`NSObject`类的元类在静态全局区的内存地址；`superClass`指针存储着一个地址，同样指向基类`NSObject`类的元类，这个地址就是基类`NSObject`类的元类在静态全局区的内存地址；`methods`成员变量存储着`ine_drinkTea`和`sleep`这个类方法的信息，`cache`缓存着`sleep`方法的信息。\n\n当我们`alloc init`一个`person`对象时，就会在堆区分配一块内存，直到没有强引用引用这个对象了，这块内存才会被释放。那么`person`对象在堆区的那块内存里存储着什么呢？`isa`指针存储着一个地址，指向`INEPerson`类，这个地址就是`INEPerson`类在静态全局区的内存地址；`person1`对象接下来会存储`_name`成员变量的值\"张三\"，当然它存储的也是一个常量区的地址，指向\"张三\"这个字符串常量，还有`_sex`成员变量的值\"男\"，当然它存储的也是一个常量区的地址，指向\"男\"这个字符串常量，还有`_age`成员变量的值“19”，当然“19”就是直接存储了，因为它是个立即数；`person2`对象接下来则会存储`_name`成员变量的值\"李四\"，`_sex`成员变量的值\"女\"，`_age`成员变量的值“18”，注意对象的内存里存储的是成员变量的值，而类的内存里存储的是成员变量的信息——比如`INEPerson`类有一个成员变量是“_name”，它的类型是`NSString`这样。","slug":"对象、类、元类、分类的本质","published":1,"updated":"2022-07-17T03:04:42.884Z","_id":"cl5jj18oy00002w2rgwswgs14","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713093308752.png\" alt=\"img\"></p>\n<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p>弄明白对象、类、元类内存里存储的是什么东西就行</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>一、对象的本质</p>\n<p>二、类的本质</p>\n<p>三、元类的本质</p>\n<p>四、分类的本质</p>\n</blockquote>\n<blockquote>\n<p>2006年苹果发布了OC2.0，其中对Runtime的很多API做了改进，并把OC1.0中Runtime的很多API标记为“将来会被废弃”。 但是两套API的核心实现思路还是一样的，而旧API比较简单，所以我们会分析旧API，然后看看新API作了哪些变化，这里有<a href=\"https://links.jianshu.com/go?to=https://opensource.apple.com/tarballs/objc4/\">最新的Runtime源码</a>。</p>\n</blockquote>\n<h3 id=\"一、对象的本质\"><a href=\"#一、对象的本质\" class=\"headerlink\" title=\"一、对象的本质\"></a>一、对象的本质</h3><h4 id=\"1、OC1-0\"><a href=\"#1、OC1-0\" class=\"headerlink\" title=\"1、OC1.0\"></a>1、OC1.0</h4><p>通过查看RunTIme的源码（<code>objc.h</code>文件），我们得到对象的定义如下（伪代码）：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 固定的成员变量</span></span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 我们自定义的成员变量</span></span><br><span class=\"line\">    <span class=\"built_in\">NSSring</span> *_name;</span><br><span class=\"line\">    <span class=\"built_in\">NSSring</span> *_sex;</span><br><span class=\"line\">    <span class=\"type\">int</span> _age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object *<span class=\"type\">id</span>; <span class=\"comment\">// id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象</span></span><br></pre></td></tr></table></figure>\n\n<p>可见对象的本质就是一个<code>objc_object</code>类型的结构体。该结构体内部只有一个固定的成员变量<code>isa</code>，它是一个<code>Class</code>类型的结构体指针，存储着一个地址，指向该对象所属的类。当然结构体内部还可能有很多我们自定义的成员变量，存储着该对象这些成员变量具体的值。</p>\n<h4 id=\"2、OC2-0\"><a href=\"#2、OC2-0\" class=\"headerlink\" title=\"2、OC2.0\"></a>2、OC2.0</h4><p>通过查看Runtime的源码（<code>objc-private.h</code>文件），我们得到对象的定义如下（伪代码）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">objc_object</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 固定的成员变量</span></span><br><span class=\"line\">    <span class=\"type\">isa_t</span> isa;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义的成员变量</span></span><br><span class=\"line\">    NSSring *_name;</span><br><span class=\"line\">    NSSring *_sex;</span><br><span class=\"line\">    <span class=\"type\">int</span> _age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 共用体isa_t</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 共用体也是C语言的一种数据类型，和结构体差不多，</span></span><br><span class=\"line\"><span class=\"comment\">// 都可以定义很多的成员变量，但两者的主要区别就在于内存的使用。</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 一个结构体占用的内存等于它所有成员变量占用内存之和，而且要遵守内存对齐规则，而一个共用体占用的内存等于它最宽成员变量占用的内存。</span></span><br><span class=\"line\"><span class=\"comment\">// 结构体里所有的成员变量各自有各自的内存，而共用体里所有的成员变量共用这一块内存。</span></span><br><span class=\"line\"><span class=\"comment\">// 所以共用体可以更加节省内存，但是我们要把数据处理好，否则很容易出现数据覆盖。</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">isa_t</span> &#123;</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> bits; <span class=\"comment\">// 8个字节，64位</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">// 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着什么数据</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">if</span> __arm64__</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"keyword\">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> nonpointer        : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_assoc         : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_cxx_dtor      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> shiftcls          : <span class=\"number\">33</span>; <span class=\"comment\">// 当前对象所属类的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> magic             : <span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> weakly_referenced : <span class=\"number\">1</span>; <span class=\"comment\">// 当前对象是否有弱引用</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> deallocating      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_sidetable_rc  : <span class=\"number\">1</span>; <span class=\"comment\">// 引用计数表里是否有当前对象的引用计数</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> extra_rc          : <span class=\"number\">19</span>; <span class=\"comment\">// 对象的引用计数 - 1，存不下了就会放到引用计数表里</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_object</span> *id; <span class=\"comment\">// id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象</span></span><br></pre></td></tr></table></figure>\n\n<p>可见对象的本质还是一个<code>objc_object</code>类型结构体。该结构体内部也还只有一个固定成员变量<code>isa</code>，只不过64位操作系统以后，对<code>isa</code>做了内存优化，它不再直接是一个指针，而是一个<code>isa_t</code>类型的共用体，它同样占用8个字节64位，但其中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1）、存储不下就放到引用计数表里，还有一位用来存储对象是否有弱引用，其他位上则存储这各种各样的标记信息。</p>\n<ul>\n<li><code>nonpointer</code>：占1位，标记<code>isa</code>是否经过内存优化。如果值为0，代表<code>isa</code>没经过内存优化，它就是一个普通的<code>isa</code>指针，64位全都用来存储该对象所属类的地址；如果值为1，代表<code>isa</code>经过了内存优化，只有33位用来存储对象所属类的地址信息，其它位则另有用途，了解一下即可；</li>\n<li><code>has_assoc</code>：占1位，标记当前对象是否有关联对象，如果没有，对象销毁时会更快，了解一下即可；</li>\n<li><code>has_cxx_dtor</code>：占1位，标记当前对象是否有C++析构函数，如果没有，对象销毁时会更快，了解一下即可；</li>\n<li><strong><code>shiftcls</code>：占33位，存储着当前对象所属类的地址信息；</strong></li>\n<li><code>magic</code>：占1位，用来标记在调试时当前对象是否未完成初始化，了解一下即可；</li>\n<li><strong><code>weakly_referenced</code>：占1位，标记弱引用表里是否有当前对象的弱指针数组——即当前对象是否被弱指针指向着、当前对象是否有弱引用；</strong></li>\n<li><code>deallocating</code>：占1位，标记当前对象是否正在释放，了解一下即可；</li>\n<li><strong><code>has_sidetable_rc</code>：占1位，标记引用计数表里是否有当前对象的引用计数；</strong></li>\n<li><strong><code>extra_rc</code>：占19位，存储着（对象的引用计数 - 1），存不下了就会放到引用计数表里，存值范围为0~255。</strong></li>\n</ul>\n<h3 id=\"二、类的本质\"><a href=\"#二、类的本质\" class=\"headerlink\" title=\"二、类的本质\"></a>二、类的本质</h3><h4 id=\"1、OC1-0-1\"><a href=\"#1、OC1-0-1\" class=\"headerlink\" title=\"1、OC1.0\"></a>1、OC1.0</h4><p>通过查看Runtime的源码（<code>runtime.h</code>文件），我们得到类的定义如下（伪代码）：<br>可见类的本质就是一个<code>objc_class</code>类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">objc_class</span> &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class super_class;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">method_array_t</span> methods;</span><br><span class=\"line\">    <span class=\"type\">property_array_t</span> properties;</span><br><span class=\"line\">    <span class=\"type\">protocol_array_t</span> protocols;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">ivar_list_t</span> *ivars;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">cache_t</span> cache;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">    <span class=\"type\">long</span> instance_size;</span><br><span class=\"line\">    <span class=\"type\">long</span> version;</span><br><span class=\"line\">    <span class=\"type\">long</span> info;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_class</span> *Class; <span class=\"comment\">// Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong><code>isa指针</code>：存储着一个地址，指向该类所属的类——即元类；</strong></li>\n<li><strong><code>superclass指针</code>：存储着一个地址，指向该类的父类；</strong></li>\n<li><strong><code>methods</code>：数组指针，存储着该类所有的实例方法信息；</strong></li>\n<li><strong><code>properties</code>：数组指针，存储着该类所有的属性信息；</strong></li>\n<li><strong><code>protocols</code>：数组指针，存储着该类所有遵守的协议信息；</strong></li>\n<li><strong><code>ivars</code>：数组指针，存储着该类所有的成员变量信息；</strong></li>\n<li><strong><code>cache</code>：结构体，存储着该类所有的方法缓存信息。</strong></li>\n</ul>\n<h4 id=\"2、OC2-0-1\"><a href=\"#2、OC2-0-1\" class=\"headerlink\" title=\"2、OC2.0\"></a>2、OC2.0</h4><p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到类的定义如下（伪代码）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class : objc_object &#123;</span><br><span class=\"line\">//    isa_t isa; // objc_class继承自objc_object，所以不考虑内存对齐的前提下，可以直接把isa成员变量搬过来</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    </span><br><span class=\"line\">    class_data_bits_t bits; // 存储着该类的具体信息，按位与掩码FAST_DATA_MASK便可得到class_rw_t</span><br><span class=\"line\">    </span><br><span class=\"line\">    cache_t cache;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// class_rw_t结构体就是该类的可读可写信息（rw即readwrite）</span><br><span class=\"line\">struct class_rw_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t version;</span><br><span class=\"line\"></span><br><span class=\"line\">    const class_ro_t *ro; // 该类的只读信息</span><br><span class=\"line\"></span><br><span class=\"line\">    method_array_t methods; // 存储着该类所有的实例方法信息，包括分类的</span><br><span class=\"line\">    property_array_t properties; // 存储着该类所有的属性信息，包括分类的</span><br><span class=\"line\">    protocol_array_t protocols; // 存储着该类所有遵守的协议信息，包括分类的</span><br><span class=\"line\"></span><br><span class=\"line\">    Class firstSubclass;</span><br><span class=\"line\">    Class nextSiblingClass;</span><br><span class=\"line\"></span><br><span class=\"line\">    char *demangledName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// class_ro_t结构体就是该类的只读信息（ro即readonly）</span><br><span class=\"line\">struct class_ro_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t instanceStart;</span><br><span class=\"line\">    uint32_t instanceSize;</span><br><span class=\"line\">#ifdef __LP64__</span><br><span class=\"line\">    uint32_t reserved;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    const uint8_t * ivarLayout;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const char * name;</span><br><span class=\"line\">    method_list_t * baseMethodList; // 存储着该类本身的实例方法信息</span><br><span class=\"line\">    protocol_list_t * baseProtocols; // 存储着该类本身遵守的协议信息</span><br><span class=\"line\">    const ivar_list_t * ivars; // 存储着该类本身的成员变量信息</span><br><span class=\"line\"></span><br><span class=\"line\">    const uint8_t * weakIvarLayout;</span><br><span class=\"line\">    property_list_t *baseProperties; // 存储着该类本身的属性信息</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_class *Class; // Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类</span><br></pre></td></tr></table></figure>\n\n<p>可见类的本质还是一个<code>objc_class</code>类型的结构体，我们重点关注的那几个成员变量还是可以顺利找到的，只不过它内部结构套了两层<code>rw</code>和<code>ro</code>，我们先说一下<code>ro</code>，<code>ro</code>内部存储着经过编译后一个类本身定义的所有实例方法、属性、协议、成员变量，它是只读的，然后运行时才会生成<code>rw</code>，把<code>ro</code>里类本身定义的所有实例方法、属性、协议搞到<code>rw</code>里，并把这个类所有分类的实例方法、属性、协议合并到<code>rw</code>里，<code>rw</code>是可读写的，这在解释“分类为什么不能给类扩展成员变量”提供了一个很好的证据。</p>\n<h3 id=\"三、元类的本质\"><a href=\"#三、元类的本质\" class=\"headerlink\" title=\"三、元类的本质\"></a>三、元类的本质</h3><p>所谓元类，是指一个类所属的类，我们每创建一个类，系统就会自动帮我们创建好该类所属的类——即元类。如果你觉得不太好理解，这里就多说两句：我们常说“在面向对象编程里，万事万物皆对象”，因此在OC里对象其实分为实例对象、类对象、元类对象三类，我们开发中经常说的“对象”其实是指狭义的对象——实例对象，知道了这一点就好理解了，实例对象有它所属的类——即一个类对象，类对象也有它所属的类——即一个元类对象，元类对象也有它所属的类——即基类的元类对象。</p>\n<p><strong>其实元类和类的本质都是<code>objc_class</code>结构体，只不过它们的用途不一样，类的<code>methods</code>成员变量里存储着该类所有的实例方法信息，而元类的<code>methods</code>成员变量里存储着该类所有的类方法信息。</strong></p>\n<h3 id=\"四、分类的本质\"><a href=\"#四、分类的本质\" class=\"headerlink\" title=\"四、分类的本质\"></a>四、分类的本质</h3><h4 id=\"1、分类是什么，我们一般用分类做什么\"><a href=\"#1、分类是什么，我们一般用分类做什么\" class=\"headerlink\" title=\"1、分类是什么，我们一般用分类做什么\"></a>1、分类是什么，我们一般用分类做什么</h4><p><strong>分类是OC的一个高级特性，我们一般用它来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现。</strong></p>\n<p>举个简单例子：</p>\n<p>比如我们给<code>NSObject</code>类扩展一个<code>test</code>方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------<span class=\"built_in\">NSObject</span>+INETest.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">INETest</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------<span class=\"built_in\">NSObject</span>+INETest.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;NSObject+INETest.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">INETest</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_test &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>比如我们有一个<code>INEPerson</code>类，保持它的主体，然后把它“吃”、“喝”的功能分散到不同的模块里去实现。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson+INEEat.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_eat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEEat.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEEat.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_eat &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson+INEDrink.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_drink;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEDrink.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_drink &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------ViewController.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"keyword\">import</span> <span class=\"string\">&quot;INEPerson.h&quot;</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> <span class=\"string\">&quot;INEPerson+INEEat.h&quot;</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> <span class=\"string\">&quot;INEPerson+INEDrink.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    INEPerson *person = [[INEPerson alloc] init];</span><br><span class=\"line\">    [person ine_eat];<span class=\"comment\">// INEPerson (INEEat) eat</span></span><br><span class=\"line\">    [person ine_drink];<span class=\"comment\">// INEPerson (INEDrink) drink</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>分类和延展的区别：</p>\n<ul>\n<li><strong>分类一般用来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现；而延展一般用来给我们自定义的类添加私有属性。</strong></li>\n<li><strong>分类的数据不是在编译时就合并到类里面的，而是在运行时；而延展的数据是在编译时就合并到类里面的。</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"2、分类的本质\"><a href=\"#2、分类的本质\" class=\"headerlink\" title=\"2、分类的本质\"></a>2、分类的本质</h4><p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到分类的定义如下：（伪代码）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct category_t &#123;</span><br><span class=\"line\">    const char *name; // 该分类所属的类的名字</span><br><span class=\"line\">    struct classref *cls; // 指向该分类所属的类</span><br><span class=\"line\">    struct method_list_t *instanceMethods;</span><br><span class=\"line\">    struct method_list_t *classMethods;</span><br><span class=\"line\">    struct protocol_list_t *protocols;</span><br><span class=\"line\">    struct property_list_t *instanceProperties;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct category_t *Category;</span><br></pre></td></tr></table></figure>\n\n<p>可见分类的本质是一个<code>category_t</code>类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：</p>\n<ul>\n<li><strong><code>classMethods</code>：该分类为类扩展的类方法列表；</strong></li>\n<li><strong><code>instanceMethods</code>：该分类为类扩展的实例方法列表；</strong></li>\n<li><strong><code>instanceProperties</code>：该分类为类扩展的属性列表；</strong></li>\n<li><strong><code>protocols</code>：该分类为类扩展的协议列表。</strong></li>\n</ul>\n<p>注意分类的本质里没有“该分类为类扩展的成员变量列表”喔，这在解释“为什么分类不能给类扩展成员变量”时又是一个很好的证据。</p>\n<h4 id=\"3、分类的实现原理\"><a href=\"#3、分类的实现原理\" class=\"headerlink\" title=\"3、分类的实现原理\"></a>3、分类的实现原理</h4><p>我们知道一个类所有的实例方法都存储在类里面，所有的类方法都存储在元类里面，而对象调用方法的流程就是根据<code>isa</code>指针先找到相应的类或元类，然后在类或元类里再找到相应的方法来调用，那<code>person</code>对象是怎么找到分类里的<code>ine_eat</code>和<code>ine_drink</code>方法来调用的呢？</p>\n<p>现在我们可以大胆猜测，因为对象内部只有一个<code>isa</code>指针，指向它所属的类，所以不可能再有一套类似的方法查找机制让它专门去分类里面查找方法，难道系统会把分类里的方法合并到类里面去？如果会合并的话，那是编译时合并的，还是运行时合并的？很简单，我们只需要看看编译后类里面是否已经包含了分类的方法就行。</p>\n<blockquote>\n<p>先给出结论：<strong>系统不是在编译时让编译器把分类的数据合并到类、元类里面的，而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的，而且分类的数据还放在类本身数据的前面，越晚编译的分类越在前面，所以如果分类里面有和类里面同名的方法，会优先调用分类里面的方法，如果多个分类里面有同名的方法，会优先调用后编译分类里面的方法，我们可以去Compile Sources里控制分类编译的顺序。</strong></p>\n</blockquote>\n<ul>\n<li>系统不是在编译时让编译器把分类的数据合并到类、元类里面的</li>\n</ul>\n<p>接着上面<code>INEPerson</code>类的例子，我们用<code>clang</code>编译器把<code>INEPerson.m</code>文件转换成C/C++代码，以便窥探编译后<code>INEPerson</code>类里面是否已经包含了分类的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class OBJC_CLASS_$_INEPerson = &#123;</span><br><span class=\"line\">    0, // &amp;OBJC_METACLASS_$_INEPerson,</span><br><span class=\"line\">    0, // &amp;OBJC_CLASS_$_NSObject,</span><br><span class=\"line\">    0, // (void *)&amp;_objc_empty_cache,</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 可读可写的</span><br><span class=\"line\">    [&quot;age&quot;, &quot;setAge:&quot;], // 所有的实例方法</span><br><span class=\"line\">    [&quot;age&quot;], // 所有的属性</span><br><span class=\"line\">    [], // 所有遵循的协议</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 只读的</span><br><span class=\"line\">    &quot;INEPerson&quot;, // 类名</span><br><span class=\"line\">    [&quot;_age&quot;], // 所有的成员变量</span><br><span class=\"line\">    16, // 实例对象的实际大小</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可见经过编译后，<code>INEPerson</code>类里面的数据还是它本身拥有的那些数据，并没有分类的方法，这就表明系统不是在编译时让编译器把分类的数据合并到类、元类里面的。</p>\n<ul>\n<li>而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的</li>\n</ul>\n<p>既然系统不是在编译时就把分类的数据合并到类里面的，那就只能是在运行时了，接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看系统到底是怎么把分类合并到类里面的：</p>\n<p>运行时，系统读取镜像阶段，会读取所有的类，并且如果发现有分类，也会读取所有的分类，然后遍历所有的分类，根据分类的<code>cls指针</code>找到它所属的类，重新组织一下这个类的内部结构——即合并分类的数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 系统读取镜像</span><br><span class=\"line\">void _read_images()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 读取所有的类</span><br><span class=\"line\">    // ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // 发现有分类</span><br><span class=\"line\">    // 读取所有的分类</span><br><span class=\"line\">    category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class=\"line\">    // 遍历所有的分类</span><br><span class=\"line\">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">        // 读取某一个分类</span><br><span class=\"line\">        category_t *cat = catlist[I];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 根据分类的cls指针找到它所属的类</span><br><span class=\"line\">        Class cls = cat-&gt;cls;</span><br><span class=\"line\">        // 重新组织一下这个类的内部结构——即合并分类的数据</span><br><span class=\"line\">        remethodizeClass(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那具体怎么个合并法呢？<strong>系统会去获取这个类所有的分类，然后倒序遍历这所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里</strong>（因为是倒序遍历分类的，所以越晚编译的分类的实例方法列表反而越会放在二维数组的前面），<strong>然后再把这个二维数组内所有一维数组的首地址复制进<code>methods</code>成员变量指向的那块内存里（注意这个存储过程会把类本身的实例方法列表挪到最后——即高内存地址上，而把分类的实例方法列表存在前面）。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 重新组织一下这个类的内部结构——即合并分类的数据</span><br><span class=\"line\">static void remethodizeClass(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 系统会去获取这个类所有的分类（没有合并过的）</span><br><span class=\"line\">    category_list *cats = unattachedCategoriesForClass(cls);</span><br><span class=\"line\">    // 把所有分类的数据合并到类里面</span><br><span class=\"line\">    attachCategories(cls, cats);</span><br><span class=\"line\">    free(cats);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 把所有分类的数据合并到类里面</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param cls 当前类</span><br><span class=\"line\"> * @param cats 当前类所有的分类</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void attachCategories(Class cls, category_list *cats)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">#pragma mark - 倒序遍历所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     创建一个二维数组，用来存放每个分类里的实例方法列表，最终结果类似下面这样：</span><br><span class=\"line\">     [</span><br><span class=\"line\">        [instanceMethod1, instanceMethod2, ...] --&gt; 分类1所有实例方法</span><br><span class=\"line\">        [instanceMethod1, instanceMethod2, ...] --&gt; 分类2所有实例方法</span><br><span class=\"line\">        ...</span><br><span class=\"line\">     ]</span><br><span class=\"line\">     */</span><br><span class=\"line\">    method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 属性</span><br><span class=\"line\">    property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 协议</span><br><span class=\"line\">    protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class=\"line\">    </span><br><span class=\"line\">    int mcount = 0;</span><br><span class=\"line\">    int propcount = 0;</span><br><span class=\"line\">    int protocount = 0;</span><br><span class=\"line\">    int i = cats-&gt;count;</span><br><span class=\"line\">    // 注意：这里是倒序遍历所有的分类</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">        // 获取一个分类</span><br><span class=\"line\">        auto cat = cats[I];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 获取分类的实例方法列表，存进二维数组</span><br><span class=\"line\">        method_list_t *mlist = cat-&gt;methods;</span><br><span class=\"line\">        mlists[mcount++] = mlist;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 属性</span><br><span class=\"line\">        protocol_list_t *protolist = cat-&gt;protocols;</span><br><span class=\"line\">        protolists[protocount++] = protolist;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 协议</span><br><span class=\"line\">        property_list_t *proplist = cat-&gt;properties;</span><br><span class=\"line\">        proplists[propcount++] = proplist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">#pragma mark - 把这个二维数组内所有一维数组的首地址存进methods成员变量所指向的那块内存空间里</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取当前类的数据（包括实例方法列表、属性列表、协议列表等）</span><br><span class=\"line\">    auto classData = cls-&gt;data();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 给当前类的实例方法列表附加所有分类的实例方法列表</span><br><span class=\"line\">    classData-&gt;methods.attachLists(mlists, mcount);</span><br><span class=\"line\">    free(mlists);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 属性</span><br><span class=\"line\">    classData-&gt;properties.attachLists(proplists, propcount);</span><br><span class=\"line\">    free(proplists);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 协议</span><br><span class=\"line\">    classData-&gt;protocols.attachLists(protolists, protocount);</span><br><span class=\"line\">    free(protolists);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 给当前类的实例方法列表附加所有分类的实例方法列表</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param addedLists 所有分类的实例方法列表（就是那个二维数组，但其实是那个二维数组的首地址）</span><br><span class=\"line\"> * @param addedCount 分类的个数</span><br><span class=\"line\"> */</span><br><span class=\"line\">void attachLists(List* const * addedLists, unsigned int addedCount) &#123;</span><br><span class=\"line\">#pragma mark - 重新为类的methods成员变量分配内存</span><br><span class=\"line\">    // 获取类原来methods成员变量的元素个数（注意：一个类的methods成员变量是一个数组，存储着若干个指针，指向相应的方法列表，而不是直接就是个方法列表存储方法）</span><br><span class=\"line\">    unsigned int oldCount = array()-&gt;count;</span><br><span class=\"line\">    // 加上分类的个数，得到新的methods成员变量该有多少个元素</span><br><span class=\"line\">    unsigned int newCount = oldCount + addedCount;</span><br><span class=\"line\">    // 重新为methods成员变量所指向的数组分配内存，一个指针占8个字节</span><br><span class=\"line\">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class=\"line\">    array()-&gt;count = newCount;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">#pragma mark - 为类的methods成员变量重新分配完内存后，对其内存数据进行移动和复制操作</span><br><span class=\"line\">    //</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     内存复制：</span><br><span class=\"line\">     memmove(dst, src, len)，从src所指向的内存空间复制len个字节的数据到dst所指向的内存空间，内部处理了内存覆盖。</span><br><span class=\"line\">     memcpy(dst, src, n)，从src所指向的内存空间复制n个字节的数据到dst所指向的内存空间，内部没处理内存覆盖。</span><br><span class=\"line\">     */</span><br><span class=\"line\">    // 把类原来的实例方法列表复制到最后面（但其实是把类原来的实例方法列表，在methods成员变量里对应的那个指针————原来的实例方法列表的首地址————复制到最后面了）</span><br><span class=\"line\">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class=\"line\">            oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class=\"line\">    // 把所有分类的实例方法列表放在前面（同理，其实是把所有分类的的实例方法列表的首地址复制到前面了，因为methods成员变量里存放的是指针————即实例方法列表的地址，不过这里二维数组的内存拷贝会拷贝它里面所有一维数组的首地址，而不仅仅这个二维数组的首地址）</span><br><span class=\"line\">    memcpy(array()-&gt;lists, addedLists,</span><br><span class=\"line\">           addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就把所有分类的实例方法列表全都合并到类里面去了，最终类的方法列表结构如下：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713113333032.png\" alt=\"img\"></p>\n<p>以上我们只是说明了分类为类扩展实例方法的底层实现，至于分类为类扩展类方法、属性、协议是同理的。</p>\n<h4 id=\"4、分类的-load方法和-initialize方法\"><a href=\"#4、分类的-load方法和-initialize方法\" class=\"headerlink\" title=\"4、分类的+load方法和+initialize方法\"></a>4、分类的<code>+load</code>方法和<code>+initialize</code>方法</h4><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">调用时机</th>\n<th align=\"center\">调用方式</th>\n<th align=\"center\">调用顺序</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>+load</code>方法</td>\n<td align=\"center\"><code>+load</code>方法是系统把类和分类载入内存时调用的</td>\n<td align=\"center\"><code>+load</code>方法是通过内存地址直接调用的，所以分类的<code>+load</code>方法不会覆盖类的<code>+load</code>方法，也就是说如果类和分类里面都实现了<code>+load</code>方法，那么它们都会被调用</td>\n<td align=\"center\">会先调用所有类的<code>+load</code>方法，然后再调用所有分类的<code>+load</code>方法</td>\n</tr>\n<tr>\n<td align=\"center\"><code>+initialize</code>方法</td>\n<td align=\"center\"><code>+initialize</code>方法是类初始化的时候调用的</td>\n<td align=\"center\"><code>+initialize</code>方法是通过消息发送机制调用的，所以分类的<code>+initialize</code>方法会覆盖类的<code>+initialize</code>方法，也就是说如果类和分类里面都实现了<code>+initialize</code>方法，那么只有分类里面的会被调用</td>\n<td align=\"center\">会优先调用分类的<code>+initialize</code>方法</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>苹果提供类、分类的<code>+load</code>方法和<code>+initialize</code>方法，其实就是给我们开发者暴露两个接口，让我们根据这俩方法的特点来合理使用。比如我们想在某个类被载入内存时做一些事情，就可以在<code>+load</code>方法里做操作，想在某个类初始化时做一些事情，就可以在<code>+initialize</code>方法里做操作。</p>\n</blockquote>\n<h6 id=\"4-1-load方法\"><a href=\"#4-1-load方法\" class=\"headerlink\" title=\"4.1 +load方法\"></a>4.1 <code>+load</code>方法</h6><ul>\n<li>调用时机</li>\n</ul>\n<p>假设有一个<code>INEPerson</code>类，并且为它创建了两个分类<code>INEEat</code>和<code>INEDrink</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEPerson +load&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEEat.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEEat.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEPerson (INEEat) +load&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEDrink.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEPerson (INEDrink) +load&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>我们什么都不做，不使用<code>Person</code>类，甚至连它的头文件也不导入。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------<span class=\"attr\">--ViewController</span><span class=\"selector-class\">.m-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#import</span> &quot;ViewController<span class=\"selector-class\">.h</span>&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@implementation</span> ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[super viewDidLoad]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>直接运行程序，发现控制台打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INEPerson +load</span><br><span class=\"line\">INEPerson (INEEat) +load</span><br><span class=\"line\">INEPerson (INEDrink) +load</span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以得出结论：**<code>+load</code>方法是系统把类和分类载入内存时调用的，<strong>它和我们代码里使用不使用这个类和分类无关。并且因为<code>+load</code>方法只会在类和分类被载入内存时调用，所以</strong>每个类和分类的<code>+load</code>方法在程序的整个生命周期中肯定会被调用且只调用一次。**</p>\n<ul>\n<li>调用方式</li>\n</ul>\n<p>这里先回想一下，上面第三部分我们说过<strong>分类的方法列表会合并到类本身的方法列表里，并且分类的方法列表还会在类本身方法列表的前面，</strong>因此分类的方法会覆盖掉类里同名的方法。</p>\n<p>但不知道你注意没有，上面第1小节的例子，控制台打印了三个东西，也就是说分类的<code>+load</code>方法和类的<code>+load</code>方法都走了，这很奇怪啊，按理说应该只走其中某一个分类的<code>+load</code>方法才对啊，怎么会三个都走呢？也就是说为什么分类的<code>+load</code>方法没有覆盖掉类的<code>+load</code>方法？</p>\n<p>接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看能不能得到答案：（伪代码）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 系统加载镜像</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">load_images</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">call_load_methods</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用+load方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">call_load_methods</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1、首先调用所有类的+load方法</span></span><br><span class=\"line\">    <span class=\"built_in\">call_class_loads</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2、然后调用所有分类的+load方法</span></span><br><span class=\"line\">    <span class=\"built_in\">call_category_loads</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用所有类的+load方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">call_class_loads</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到所有的类</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">loadable_class</span> *classes = loadable_classes;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; loadable_classes_used; i++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取到某个类</span></span><br><span class=\"line\">        Class cls = classes[i].cls;</span><br><span class=\"line\">        <span class=\"comment\">// 获取到某个类+load方法的地址</span></span><br><span class=\"line\">        <span class=\"type\">load_method_t</span> load_method = (<span class=\"type\">load_method_t</span>)classes[i].method;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 直接调用该类的+load方法</span></span><br><span class=\"line\">        (*load_method)(cls, SEL_load);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用所有分类的+load方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">call_category_loads</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到所有的分类</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">loadable_category</span> *cats = loadable_categories;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取到某个分类</span></span><br><span class=\"line\">        Category cat = cats[i].cat;</span><br><span class=\"line\">        <span class=\"comment\">// 获取到某个分类+load方法的地址</span></span><br><span class=\"line\">        <span class=\"type\">load_method_t</span> load_method = (<span class=\"type\">load_method_t</span>)cats[i].method;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 直接调用该分类的+load方法</span></span><br><span class=\"line\">        (*load_method)(cls, SEL_load);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见**<code>+load</code>方法是通过内存地址直接调用的，<strong>而不像普通方法那样走消息发送机制。因此就解释了我们留下的疑惑，虽然说分类的方法列表在类本身方法列表的前面，但是对<code>+load</code>方法根本不起作用，人家不走你那一套，</strong>所以分类的<code>+load</code>方法不会覆盖类的<code>+load</code>方法。**</p>\n<ul>\n<li>调用顺序</li>\n</ul>\n<p>这里就直接给出结论了，感兴趣的话，可以像第2小节那样去看源码（核心代码就集中在上面那几个方法里）并敲代码验证验证。</p>\n<p><strong>会先调用所有类的<code>+load</code>方法，先编译的类先调用；如果存在继承关系，那么在调用子类的<code>+load</code>方法之前会先去调用父类的<code>+load</code>方法。</strong></p>\n<p><strong>然后再调用所有分类的<code>+load</code>方法，先编译的分类先调用。</strong></p>\n<h6 id=\"4-2-initialize方法\"><a href=\"#4-2-initialize方法\" class=\"headerlink\" title=\"4.2 +initialize方法\"></a>4.2 <code>+initialize</code>方法</h6><ul>\n<li>调用时机</li>\n</ul>\n<p>假设有一个<code>INEPerson</code>类和一个继承自<code>INEPerson</code>类的<code>INEStudent</code>类，并且为<code>INEStudent</code>类创建了两个分类<code>INEEat</code>和<code>INEDrink</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)initialize &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEPerson +initialize&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEStudent.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEStudent.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEStudent</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)initialize &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEStudent +initialize&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEStudent+INEEat.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEStudent+INEEat.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEStudent</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)initialize &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEStudent (INEEat) +initialize&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEStudent+INEDrink.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEStudent+INEDrink.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEStudent</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)initialize &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEStudent (INEDrink) +initialize&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>我们什么都不做，直接运行程序，发现控制台什么都没打印。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------<span class=\"attr\">--ViewController</span><span class=\"selector-class\">.m-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#import</span> &quot;ViewController<span class=\"selector-class\">.h</span>&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@implementation</span> ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[super viewDidLoad]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>此时我们调用一下<code>Student</code>类的<code>+alloc</code>方法。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------<span class=\"attr\">--ViewController</span><span class=\"selector-class\">.m-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#import</span> &quot;ViewController<span class=\"selector-class\">.h</span>&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@implementation</span> ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[super viewDidLoad]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-attr\">[INEStudent alloc]</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行程序，发现控制台打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INEPerson +initialize</span><br><span class=\"line\">INEStudent (INEDrink) +initialize</span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以得出结论：**<code>+initialize</code>方法是类初始化的时候调用的，<strong>所以严格地来讲，我们不能说“<code>+initialize</code>方法是第一次使用类的时候调用的”，你看上面例子中我们根本没使用<code>INEPerson</code>类嘛，但它的<code>+initialize</code>方法照样被调用了。</strong>如果我们压根儿不使用这个类，它的<code>+initialize</code>方法被调用0次，但是我们不能说一个类的<code>+initialize</code>方法最多被调用1次，因为<code>+initialize</code>方法是通过消息发送机制来调用的，如果好几个子类都继承自某一个类，而这些子类都没有实现自己的<code>+initialize</code>方法，那就都会去调用这个父类的<code>+initialize</code>方法，这不就是调用N次了嘛。**</p>\n<ul>\n<li>调用方式</li>\n</ul>\n<p>上面第1小节的例子，控制台打印了一个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INEStudent (INEDrink) +initialize</span><br></pre></td></tr></table></figure>\n\n<p>这就明显表明：**<code>+initialize</code>方法的调用方式不同于<code>+load</code>方法，它是通过消息发送机制调用的，所以才会只走分类里面的 <code>+initialize</code>方法，也就是说分类的<code>+initialize</code>方法会覆盖类的<code>+initialize</code>方法。**</p>\n<p>但有一点很奇怪，因为控制台还打印了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INEPerson +initialize</span><br></pre></td></tr></table></figure>\n\n<p>这是父类的<code>+initialize</code>方法呀！既然<code>+initialize</code>方法是通过消息发送机制调用的，那它在自己类的内部找到某个方法后，就不应该再调用父类里面的方法了呀，怎么回事？</p>\n<p>接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看能不能得到答案：（伪代码）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找方法的实现：类接收到消息后，会去查找这个消息的实现并调用，那我们就从查找这个消息的实现下手吧，前面的源码没有相关信息</span></span><br><span class=\"line\"><span class=\"function\">IMP <span class=\"title\">lookUpImpOrForward</span><span class=\"params\">(Class cls, SEL sel)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在查找方法的过程中，如果发现这个类没被初始化过</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls-&gt;<span class=\"built_in\">isInitialized</span>()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 则初始化这个类</span></span><br><span class=\"line\">        <span class=\"built_in\">initializeNonMetaClass</span>(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initializeNonMetaClass</span><span class=\"params\">(Class cls)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在初始化一个类的过程中</span></span><br><span class=\"line\">    Class supercls = cls-&gt;superclass;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (supercls  &amp;&amp;  !supercls-&gt;<span class=\"built_in\">isInitialized</span>()) &#123;<span class=\"comment\">// 如果发现这个类的父类没被初始化过</span></span><br><span class=\"line\">        <span class=\"comment\">// 则递归，一层一层地先初始化父类，直到NSObject，直到nil</span></span><br><span class=\"line\">        <span class=\"built_in\">initializeNonMetaClass</span>(supercls);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 一层一层初始化完之后，才会一层一层自上而下地调用各个类的+initialize方法</span></span><br><span class=\"line\">        <span class=\"built_in\">callInitialize</span>(cls);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 如果发现这个类的父类被初始化过了</span></span><br><span class=\"line\">        <span class=\"comment\">// 则直接初始化自己</span></span><br><span class=\"line\">        <span class=\"built_in\">initializeNonMetaClass</span>(cls);</span><br><span class=\"line\">        <span class=\"comment\">// 并调用自己的+initialize方法，</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果自己没有实现，则会去找父类的+initialize方法调用。（因为+initialize方法是通过消息发送机制调用的嘛）</span></span><br><span class=\"line\">        <span class=\"built_in\">callInitialize</span>(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">callInitialize</span><span class=\"params\">(Class cls)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// +initialize方法确实是通过消息发送机制调用的</span></span><br><span class=\"line\">    ((<span class=\"built_in\">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见<strong>系统在调用一个类的<code>+initialize</code>方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的<code>+initialize</code>方法，然后再初始化自己并调用自己的<code>+initialize</code>方法；如果它的父类初始化了，则直接初始化自己并调用自己的<code>+initialize</code>方法，如果自己没有实现，则会去找父类的<code>+initialize</code>方法调用。</strong></p>\n<ul>\n<li>调用顺序</li>\n</ul>\n<p>这里就直接给出结论了。</p>\n<p><strong>系统在调用一个类的<code>+initialize</code>方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的<code>+initialize</code>方法，然后再初始化自己并调用自己的<code>+initialize</code>方法；如果它的父类初始化了，则直接初始化自己并调用自己的<code>+initialize</code>方法，如果自己没有实现，则会去找父类的<code>+initialize</code>方法调用。</strong></p>\n<p><strong>如果分类里也实现了<code>+initialize</code>方法，会优先调用分类的。</strong></p>\n<h3 id=\"temp、行文至此，我们举个例子串一下上面的内容\"><a href=\"#temp、行文至此，我们举个例子串一下上面的内容\" class=\"headerlink\" title=\"temp、行文至此，我们举个例子串一下上面的内容\"></a>temp、行文至此，我们举个例子串一下上面的内容</h3><p>定义一个<code>INEPerson</code>类，并为它创建一个分类<code>INEDrink</code>，然后创建两个<code>person</code>对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSCopying</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *sex;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)eat;</span><br><span class=\"line\">+ (<span class=\"type\">void</span>)sleep;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)eat &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;对象方法：吃&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)sleep &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;类方法：睡&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">id</span>)copyWithZone:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSZone</span> *)zone &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 浅拷贝一下</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson+INEDrink.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_drinkWater;</span><br><span class=\"line\">+ (<span class=\"type\">void</span>)ine_drinkTea;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEDrink.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_drinkWater &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)ine_drinkTea &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------ViewController.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    INEPerson *person1 = [[INEPerson alloc] init];</span><br><span class=\"line\">    person1.name = <span class=\"string\">@&quot;张三&quot;</span>;</span><br><span class=\"line\">    person1.sex = <span class=\"string\">@&quot;男&quot;</span>;</span><br><span class=\"line\">    person1.age = <span class=\"number\">19</span>;</span><br><span class=\"line\">    [person1 eat];</span><br><span class=\"line\">    </span><br><span class=\"line\">    INEPerson *person2 = [[INEPerson alloc] init];</span><br><span class=\"line\">    person2.name = <span class=\"string\">@&quot;李四&quot;</span>;</span><br><span class=\"line\">    person2.sex = <span class=\"string\">@&quot;女&quot;</span>;</span><br><span class=\"line\">    person2.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [INEPerson sleep];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们启动App时，系统就会把<code>INEPerson</code>类、<code>INEPerson</code>类的元类还有<code>INEPerson</code>类的分类加载到内存中，然后把分类的数据合并到类和元类里，并且这些类会被存储到静态全局区，因为类只要一份就够了嘛 + 类还得能在项目的任何地方都能访问到，直到杀死App，这些类的内存才会被释放。那么<code>INEPerson</code>类在静态全局区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向<code>INEPerson</code>类的元类，这个地址就是<code>INEPerson</code>类的元类在静态全局区的内存地址；<code>superClass</code>指针存储着一个地址，指向<code>NSObject</code>类，这个地址就是<code>NSObject</code>类在静态全局区的内存地址；<code>methods</code>成员变量存储着<code>ine_drinkWater</code>和<code>eat</code>这两个实例方法的信息，<code>properties</code>成员变量存储着<code>name</code>、<code>sex</code>、<code>age</code>这些属性的信息，<code>protocols</code>成员变量存储着<code>NSCopying</code>协议的信息，<code>ivars</code>成员变量存储着<code>_name</code>、<code>_sex</code>、<code>_age</code>这些成员变量的信息，<code>cache</code>缓存着<code>eat</code>方法的信息。<code>INEPerson</code>类的元类在静态全局区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向基类<code>NSObject</code>类的元类，这个地址就是基类<code>NSObject</code>类的元类在静态全局区的内存地址；<code>superClass</code>指针存储着一个地址，同样指向基类<code>NSObject</code>类的元类，这个地址就是基类<code>NSObject</code>类的元类在静态全局区的内存地址；<code>methods</code>成员变量存储着<code>ine_drinkTea</code>和<code>sleep</code>这个类方法的信息，<code>cache</code>缓存着<code>sleep</code>方法的信息。</p>\n<p>当我们<code>alloc init</code>一个<code>person</code>对象时，就会在堆区分配一块内存，直到没有强引用引用这个对象了，这块内存才会被释放。那么<code>person</code>对象在堆区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向<code>INEPerson</code>类，这个地址就是<code>INEPerson</code>类在静态全局区的内存地址；<code>person1</code>对象接下来会存储<code>_name</code>成员变量的值”张三”，当然它存储的也是一个常量区的地址，指向”张三”这个字符串常量，还有<code>_sex</code>成员变量的值”男”，当然它存储的也是一个常量区的地址，指向”男”这个字符串常量，还有<code>_age</code>成员变量的值“19”，当然“19”就是直接存储了，因为它是个立即数；<code>person2</code>对象接下来则会存储<code>_name</code>成员变量的值”李四”，<code>_sex</code>成员变量的值”女”，<code>_age</code>成员变量的值“18”，注意对象的内存里存储的是成员变量的值，而类的内存里存储的是成员变量的信息——比如<code>INEPerson</code>类有一个成员变量是“_name”，它的类型是<code>NSString</code>这样。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713093308752.png\" alt=\"img\"></p>\n<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p>弄明白对象、类、元类内存里存储的是什么东西就行</p>","more":"<blockquote>\n<p>一、对象的本质</p>\n<p>二、类的本质</p>\n<p>三、元类的本质</p>\n<p>四、分类的本质</p>\n</blockquote>\n<blockquote>\n<p>2006年苹果发布了OC2.0，其中对Runtime的很多API做了改进，并把OC1.0中Runtime的很多API标记为“将来会被废弃”。 但是两套API的核心实现思路还是一样的，而旧API比较简单，所以我们会分析旧API，然后看看新API作了哪些变化，这里有<a href=\"https://links.jianshu.com/go?to=https://opensource.apple.com/tarballs/objc4/\">最新的Runtime源码</a>。</p>\n</blockquote>\n<h3 id=\"一、对象的本质\"><a href=\"#一、对象的本质\" class=\"headerlink\" title=\"一、对象的本质\"></a>一、对象的本质</h3><h4 id=\"1、OC1-0\"><a href=\"#1、OC1-0\" class=\"headerlink\" title=\"1、OC1.0\"></a>1、OC1.0</h4><p>通过查看RunTIme的源码（<code>objc.h</code>文件），我们得到对象的定义如下（伪代码）：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> objc_object &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 固定的成员变量</span></span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 我们自定义的成员变量</span></span><br><span class=\"line\">    <span class=\"built_in\">NSSring</span> *_name;</span><br><span class=\"line\">    <span class=\"built_in\">NSSring</span> *_sex;</span><br><span class=\"line\">    <span class=\"type\">int</span> _age;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> objc_object *<span class=\"type\">id</span>; <span class=\"comment\">// id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象</span></span><br></pre></td></tr></table></figure>\n\n<p>可见对象的本质就是一个<code>objc_object</code>类型的结构体。该结构体内部只有一个固定的成员变量<code>isa</code>，它是一个<code>Class</code>类型的结构体指针，存储着一个地址，指向该对象所属的类。当然结构体内部还可能有很多我们自定义的成员变量，存储着该对象这些成员变量具体的值。</p>\n<h4 id=\"2、OC2-0\"><a href=\"#2、OC2-0\" class=\"headerlink\" title=\"2、OC2.0\"></a>2、OC2.0</h4><p>通过查看Runtime的源码（<code>objc-private.h</code>文件），我们得到对象的定义如下（伪代码）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">objc_object</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 固定的成员变量</span></span><br><span class=\"line\">    <span class=\"type\">isa_t</span> isa;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义的成员变量</span></span><br><span class=\"line\">    NSSring *_name;</span><br><span class=\"line\">    NSSring *_sex;</span><br><span class=\"line\">    <span class=\"type\">int</span> _age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 共用体isa_t</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 共用体也是C语言的一种数据类型，和结构体差不多，</span></span><br><span class=\"line\"><span class=\"comment\">// 都可以定义很多的成员变量，但两者的主要区别就在于内存的使用。</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 一个结构体占用的内存等于它所有成员变量占用内存之和，而且要遵守内存对齐规则，而一个共用体占用的内存等于它最宽成员变量占用的内存。</span></span><br><span class=\"line\"><span class=\"comment\">// 结构体里所有的成员变量各自有各自的内存，而共用体里所有的成员变量共用这一块内存。</span></span><br><span class=\"line\"><span class=\"comment\">// 所以共用体可以更加节省内存，但是我们要把数据处理好，否则很容易出现数据覆盖。</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">isa_t</span> &#123;</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> bits; <span class=\"comment\">// 8个字节，64位</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">// 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着什么数据</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">if</span> __arm64__</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"keyword\">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> nonpointer        : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_assoc         : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_cxx_dtor      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> shiftcls          : <span class=\"number\">33</span>; <span class=\"comment\">// 当前对象所属类的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> magic             : <span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> weakly_referenced : <span class=\"number\">1</span>; <span class=\"comment\">// 当前对象是否有弱引用</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> deallocating      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_sidetable_rc  : <span class=\"number\">1</span>; <span class=\"comment\">// 引用计数表里是否有当前对象的引用计数</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> extra_rc          : <span class=\"number\">19</span>; <span class=\"comment\">// 对象的引用计数 - 1，存不下了就会放到引用计数表里</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_object</span> *id; <span class=\"comment\">// id类型的本质就是一个objc_object类型的结构体指针，所以它可以指向任意一个OC对象</span></span><br></pre></td></tr></table></figure>\n\n<p>可见对象的本质还是一个<code>objc_object</code>类型结构体。该结构体内部也还只有一个固定成员变量<code>isa</code>，只不过64位操作系统以后，对<code>isa</code>做了内存优化，它不再直接是一个指针，而是一个<code>isa_t</code>类型的共用体，它同样占用8个字节64位，但其中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1）、存储不下就放到引用计数表里，还有一位用来存储对象是否有弱引用，其他位上则存储这各种各样的标记信息。</p>\n<ul>\n<li><code>nonpointer</code>：占1位，标记<code>isa</code>是否经过内存优化。如果值为0，代表<code>isa</code>没经过内存优化，它就是一个普通的<code>isa</code>指针，64位全都用来存储该对象所属类的地址；如果值为1，代表<code>isa</code>经过了内存优化，只有33位用来存储对象所属类的地址信息，其它位则另有用途，了解一下即可；</li>\n<li><code>has_assoc</code>：占1位，标记当前对象是否有关联对象，如果没有，对象销毁时会更快，了解一下即可；</li>\n<li><code>has_cxx_dtor</code>：占1位，标记当前对象是否有C++析构函数，如果没有，对象销毁时会更快，了解一下即可；</li>\n<li><strong><code>shiftcls</code>：占33位，存储着当前对象所属类的地址信息；</strong></li>\n<li><code>magic</code>：占1位，用来标记在调试时当前对象是否未完成初始化，了解一下即可；</li>\n<li><strong><code>weakly_referenced</code>：占1位，标记弱引用表里是否有当前对象的弱指针数组——即当前对象是否被弱指针指向着、当前对象是否有弱引用；</strong></li>\n<li><code>deallocating</code>：占1位，标记当前对象是否正在释放，了解一下即可；</li>\n<li><strong><code>has_sidetable_rc</code>：占1位，标记引用计数表里是否有当前对象的引用计数；</strong></li>\n<li><strong><code>extra_rc</code>：占19位，存储着（对象的引用计数 - 1），存不下了就会放到引用计数表里，存值范围为0~255。</strong></li>\n</ul>\n<h3 id=\"二、类的本质\"><a href=\"#二、类的本质\" class=\"headerlink\" title=\"二、类的本质\"></a>二、类的本质</h3><h4 id=\"1、OC1-0-1\"><a href=\"#1、OC1-0-1\" class=\"headerlink\" title=\"1、OC1.0\"></a>1、OC1.0</h4><p>通过查看Runtime的源码（<code>runtime.h</code>文件），我们得到类的定义如下（伪代码）：<br>可见类的本质就是一个<code>objc_class</code>类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">objc_class</span> &#123;</span><br><span class=\"line\">    Class isa;</span><br><span class=\"line\">    Class super_class;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">method_array_t</span> methods;</span><br><span class=\"line\">    <span class=\"type\">property_array_t</span> properties;</span><br><span class=\"line\">    <span class=\"type\">protocol_array_t</span> protocols;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">ivar_list_t</span> *ivars;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">cache_t</span> cache;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *name;</span><br><span class=\"line\">    <span class=\"type\">long</span> instance_size;</span><br><span class=\"line\">    <span class=\"type\">long</span> version;</span><br><span class=\"line\">    <span class=\"type\">long</span> info;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">objc_class</span> *Class; <span class=\"comment\">// Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong><code>isa指针</code>：存储着一个地址，指向该类所属的类——即元类；</strong></li>\n<li><strong><code>superclass指针</code>：存储着一个地址，指向该类的父类；</strong></li>\n<li><strong><code>methods</code>：数组指针，存储着该类所有的实例方法信息；</strong></li>\n<li><strong><code>properties</code>：数组指针，存储着该类所有的属性信息；</strong></li>\n<li><strong><code>protocols</code>：数组指针，存储着该类所有遵守的协议信息；</strong></li>\n<li><strong><code>ivars</code>：数组指针，存储着该类所有的成员变量信息；</strong></li>\n<li><strong><code>cache</code>：结构体，存储着该类所有的方法缓存信息。</strong></li>\n</ul>\n<h4 id=\"2、OC2-0-1\"><a href=\"#2、OC2-0-1\" class=\"headerlink\" title=\"2、OC2.0\"></a>2、OC2.0</h4><p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到类的定义如下（伪代码）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class : objc_object &#123;</span><br><span class=\"line\">//    isa_t isa; // objc_class继承自objc_object，所以不考虑内存对齐的前提下，可以直接把isa成员变量搬过来</span><br><span class=\"line\">    Class superclass;</span><br><span class=\"line\">    </span><br><span class=\"line\">    class_data_bits_t bits; // 存储着该类的具体信息，按位与掩码FAST_DATA_MASK便可得到class_rw_t</span><br><span class=\"line\">    </span><br><span class=\"line\">    cache_t cache;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// class_rw_t结构体就是该类的可读可写信息（rw即readwrite）</span><br><span class=\"line\">struct class_rw_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t version;</span><br><span class=\"line\"></span><br><span class=\"line\">    const class_ro_t *ro; // 该类的只读信息</span><br><span class=\"line\"></span><br><span class=\"line\">    method_array_t methods; // 存储着该类所有的实例方法信息，包括分类的</span><br><span class=\"line\">    property_array_t properties; // 存储着该类所有的属性信息，包括分类的</span><br><span class=\"line\">    protocol_array_t protocols; // 存储着该类所有遵守的协议信息，包括分类的</span><br><span class=\"line\"></span><br><span class=\"line\">    Class firstSubclass;</span><br><span class=\"line\">    Class nextSiblingClass;</span><br><span class=\"line\"></span><br><span class=\"line\">    char *demangledName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// class_ro_t结构体就是该类的只读信息（ro即readonly）</span><br><span class=\"line\">struct class_ro_t &#123;</span><br><span class=\"line\">    uint32_t flags;</span><br><span class=\"line\">    uint32_t instanceStart;</span><br><span class=\"line\">    uint32_t instanceSize;</span><br><span class=\"line\">#ifdef __LP64__</span><br><span class=\"line\">    uint32_t reserved;</span><br><span class=\"line\">#endif</span><br><span class=\"line\"></span><br><span class=\"line\">    const uint8_t * ivarLayout;</span><br><span class=\"line\">    </span><br><span class=\"line\">    const char * name;</span><br><span class=\"line\">    method_list_t * baseMethodList; // 存储着该类本身的实例方法信息</span><br><span class=\"line\">    protocol_list_t * baseProtocols; // 存储着该类本身遵守的协议信息</span><br><span class=\"line\">    const ivar_list_t * ivars; // 存储着该类本身的成员变量信息</span><br><span class=\"line\"></span><br><span class=\"line\">    const uint8_t * weakIvarLayout;</span><br><span class=\"line\">    property_list_t *baseProperties; // 存储着该类本身的属性信息</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct objc_class *Class; // Class类型的本质就是一个objc_class类型的结构体指针，所以它可以指向任意一个OC类</span><br></pre></td></tr></table></figure>\n\n<p>可见类的本质还是一个<code>objc_class</code>类型的结构体，我们重点关注的那几个成员变量还是可以顺利找到的，只不过它内部结构套了两层<code>rw</code>和<code>ro</code>，我们先说一下<code>ro</code>，<code>ro</code>内部存储着经过编译后一个类本身定义的所有实例方法、属性、协议、成员变量，它是只读的，然后运行时才会生成<code>rw</code>，把<code>ro</code>里类本身定义的所有实例方法、属性、协议搞到<code>rw</code>里，并把这个类所有分类的实例方法、属性、协议合并到<code>rw</code>里，<code>rw</code>是可读写的，这在解释“分类为什么不能给类扩展成员变量”提供了一个很好的证据。</p>\n<h3 id=\"三、元类的本质\"><a href=\"#三、元类的本质\" class=\"headerlink\" title=\"三、元类的本质\"></a>三、元类的本质</h3><p>所谓元类，是指一个类所属的类，我们每创建一个类，系统就会自动帮我们创建好该类所属的类——即元类。如果你觉得不太好理解，这里就多说两句：我们常说“在面向对象编程里，万事万物皆对象”，因此在OC里对象其实分为实例对象、类对象、元类对象三类，我们开发中经常说的“对象”其实是指狭义的对象——实例对象，知道了这一点就好理解了，实例对象有它所属的类——即一个类对象，类对象也有它所属的类——即一个元类对象，元类对象也有它所属的类——即基类的元类对象。</p>\n<p><strong>其实元类和类的本质都是<code>objc_class</code>结构体，只不过它们的用途不一样，类的<code>methods</code>成员变量里存储着该类所有的实例方法信息，而元类的<code>methods</code>成员变量里存储着该类所有的类方法信息。</strong></p>\n<h3 id=\"四、分类的本质\"><a href=\"#四、分类的本质\" class=\"headerlink\" title=\"四、分类的本质\"></a>四、分类的本质</h3><h4 id=\"1、分类是什么，我们一般用分类做什么\"><a href=\"#1、分类是什么，我们一般用分类做什么\" class=\"headerlink\" title=\"1、分类是什么，我们一般用分类做什么\"></a>1、分类是什么，我们一般用分类做什么</h4><p><strong>分类是OC的一个高级特性，我们一般用它来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现。</strong></p>\n<p>举个简单例子：</p>\n<p>比如我们给<code>NSObject</code>类扩展一个<code>test</code>方法。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------<span class=\"built_in\">NSObject</span>+INETest.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSObject</span> (<span class=\"title\">INETest</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------<span class=\"built_in\">NSObject</span>+INETest.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;NSObject+INETest.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSObject</span> (<span class=\"title\">INETest</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_test &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>比如我们有一个<code>INEPerson</code>类，保持它的主体，然后把它“吃”、“喝”的功能分散到不同的模块里去实现。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> : <span class=\"title\">NSObject</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson+INEEat.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_eat;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEEat.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEEat.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_eat &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson+INEDrink.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_drink;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEDrink.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_drink &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------ViewController.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"keyword\">import</span> <span class=\"string\">&quot;INEPerson.h&quot;</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> <span class=\"string\">&quot;INEPerson+INEEat.h&quot;</span></span><br><span class=\"line\">#<span class=\"keyword\">import</span> <span class=\"string\">&quot;INEPerson+INEDrink.h&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"keyword\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    INEPerson *person = [[INEPerson alloc] init];</span><br><span class=\"line\">    [person ine_eat];<span class=\"comment\">// INEPerson (INEEat) eat</span></span><br><span class=\"line\">    [person ine_drink];<span class=\"comment\">// INEPerson (INEDrink) drink</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>分类和延展的区别：</p>\n<ul>\n<li><strong>分类一般用来给系统的类或三方库的类扩展方法、属性和协议，或者把一个类不同的功能分散到不同的模块里去实现；而延展一般用来给我们自定义的类添加私有属性。</strong></li>\n<li><strong>分类的数据不是在编译时就合并到类里面的，而是在运行时；而延展的数据是在编译时就合并到类里面的。</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"2、分类的本质\"><a href=\"#2、分类的本质\" class=\"headerlink\" title=\"2、分类的本质\"></a>2、分类的本质</h4><p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到分类的定义如下：（伪代码）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct category_t &#123;</span><br><span class=\"line\">    const char *name; // 该分类所属的类的名字</span><br><span class=\"line\">    struct classref *cls; // 指向该分类所属的类</span><br><span class=\"line\">    struct method_list_t *instanceMethods;</span><br><span class=\"line\">    struct method_list_t *classMethods;</span><br><span class=\"line\">    struct protocol_list_t *protocols;</span><br><span class=\"line\">    struct property_list_t *instanceProperties;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef struct category_t *Category;</span><br></pre></td></tr></table></figure>\n\n<p>可见分类的本质是一个<code>category_t</code>类型的结构体，该结构体内部有若干个成员变量，其中有几个是我们重点关注的：</p>\n<ul>\n<li><strong><code>classMethods</code>：该分类为类扩展的类方法列表；</strong></li>\n<li><strong><code>instanceMethods</code>：该分类为类扩展的实例方法列表；</strong></li>\n<li><strong><code>instanceProperties</code>：该分类为类扩展的属性列表；</strong></li>\n<li><strong><code>protocols</code>：该分类为类扩展的协议列表。</strong></li>\n</ul>\n<p>注意分类的本质里没有“该分类为类扩展的成员变量列表”喔，这在解释“为什么分类不能给类扩展成员变量”时又是一个很好的证据。</p>\n<h4 id=\"3、分类的实现原理\"><a href=\"#3、分类的实现原理\" class=\"headerlink\" title=\"3、分类的实现原理\"></a>3、分类的实现原理</h4><p>我们知道一个类所有的实例方法都存储在类里面，所有的类方法都存储在元类里面，而对象调用方法的流程就是根据<code>isa</code>指针先找到相应的类或元类，然后在类或元类里再找到相应的方法来调用，那<code>person</code>对象是怎么找到分类里的<code>ine_eat</code>和<code>ine_drink</code>方法来调用的呢？</p>\n<p>现在我们可以大胆猜测，因为对象内部只有一个<code>isa</code>指针，指向它所属的类，所以不可能再有一套类似的方法查找机制让它专门去分类里面查找方法，难道系统会把分类里的方法合并到类里面去？如果会合并的话，那是编译时合并的，还是运行时合并的？很简单，我们只需要看看编译后类里面是否已经包含了分类的方法就行。</p>\n<blockquote>\n<p>先给出结论：<strong>系统不是在编译时让编译器把分类的数据合并到类、元类里面的，而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的，而且分类的数据还放在类本身数据的前面，越晚编译的分类越在前面，所以如果分类里面有和类里面同名的方法，会优先调用分类里面的方法，如果多个分类里面有同名的方法，会优先调用后编译分类里面的方法，我们可以去Compile Sources里控制分类编译的顺序。</strong></p>\n</blockquote>\n<ul>\n<li>系统不是在编译时让编译器把分类的数据合并到类、元类里面的</li>\n</ul>\n<p>接着上面<code>INEPerson</code>类的例子，我们用<code>clang</code>编译器把<code>INEPerson.m</code>文件转换成C/C++代码，以便窥探编译后<code>INEPerson</code>类里面是否已经包含了分类的方法。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct objc_class OBJC_CLASS_$_INEPerson = &#123;</span><br><span class=\"line\">    0, // &amp;OBJC_METACLASS_$_INEPerson,</span><br><span class=\"line\">    0, // &amp;OBJC_CLASS_$_NSObject,</span><br><span class=\"line\">    0, // (void *)&amp;_objc_empty_cache,</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 可读可写的</span><br><span class=\"line\">    [&quot;age&quot;, &quot;setAge:&quot;], // 所有的实例方法</span><br><span class=\"line\">    [&quot;age&quot;], // 所有的属性</span><br><span class=\"line\">    [], // 所有遵循的协议</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 只读的</span><br><span class=\"line\">    &quot;INEPerson&quot;, // 类名</span><br><span class=\"line\">    [&quot;_age&quot;], // 所有的成员变量</span><br><span class=\"line\">    16, // 实例对象的实际大小</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可见经过编译后，<code>INEPerson</code>类里面的数据还是它本身拥有的那些数据，并没有分类的方法，这就表明系统不是在编译时让编译器把分类的数据合并到类、元类里面的。</p>\n<ul>\n<li>而是在运行时利用Runtime动态把分类的数据合并到类、元类里面的</li>\n</ul>\n<p>既然系统不是在编译时就把分类的数据合并到类里面的，那就只能是在运行时了，接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看系统到底是怎么把分类合并到类里面的：</p>\n<p>运行时，系统读取镜像阶段，会读取所有的类，并且如果发现有分类，也会读取所有的分类，然后遍历所有的分类，根据分类的<code>cls指针</code>找到它所属的类，重新组织一下这个类的内部结构——即合并分类的数据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 系统读取镜像</span><br><span class=\"line\">void _read_images()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 读取所有的类</span><br><span class=\"line\">    // ...</span><br><span class=\"line\"></span><br><span class=\"line\">    // 发现有分类</span><br><span class=\"line\">    // 读取所有的分类</span><br><span class=\"line\">    category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class=\"line\">    // 遍历所有的分类</span><br><span class=\"line\">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class=\"line\">        // 读取某一个分类</span><br><span class=\"line\">        category_t *cat = catlist[I];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 根据分类的cls指针找到它所属的类</span><br><span class=\"line\">        Class cls = cat-&gt;cls;</span><br><span class=\"line\">        // 重新组织一下这个类的内部结构——即合并分类的数据</span><br><span class=\"line\">        remethodizeClass(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那具体怎么个合并法呢？<strong>系统会去获取这个类所有的分类，然后倒序遍历这所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里</strong>（因为是倒序遍历分类的，所以越晚编译的分类的实例方法列表反而越会放在二维数组的前面），<strong>然后再把这个二维数组内所有一维数组的首地址复制进<code>methods</code>成员变量指向的那块内存里（注意这个存储过程会把类本身的实例方法列表挪到最后——即高内存地址上，而把分类的实例方法列表存在前面）。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 重新组织一下这个类的内部结构——即合并分类的数据</span><br><span class=\"line\">static void remethodizeClass(Class cls)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    // 系统会去获取这个类所有的分类（没有合并过的）</span><br><span class=\"line\">    category_list *cats = unattachedCategoriesForClass(cls);</span><br><span class=\"line\">    // 把所有分类的数据合并到类里面</span><br><span class=\"line\">    attachCategories(cls, cats);</span><br><span class=\"line\">    free(cats);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 把所有分类的数据合并到类里面</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param cls 当前类</span><br><span class=\"line\"> * @param cats 当前类所有的分类</span><br><span class=\"line\"> */</span><br><span class=\"line\">static void attachCategories(Class cls, category_list *cats)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">#pragma mark - 倒序遍历所有的分类，把每个分类里面的实例方法列表拿出来，存进一个二维数组里</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     创建一个二维数组，用来存放每个分类里的实例方法列表，最终结果类似下面这样：</span><br><span class=\"line\">     [</span><br><span class=\"line\">        [instanceMethod1, instanceMethod2, ...] --&gt; 分类1所有实例方法</span><br><span class=\"line\">        [instanceMethod1, instanceMethod2, ...] --&gt; 分类2所有实例方法</span><br><span class=\"line\">        ...</span><br><span class=\"line\">     ]</span><br><span class=\"line\">     */</span><br><span class=\"line\">    method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists));</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 属性</span><br><span class=\"line\">    property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists));</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 协议</span><br><span class=\"line\">    protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists));</span><br><span class=\"line\">    </span><br><span class=\"line\">    int mcount = 0;</span><br><span class=\"line\">    int propcount = 0;</span><br><span class=\"line\">    int protocount = 0;</span><br><span class=\"line\">    int i = cats-&gt;count;</span><br><span class=\"line\">    // 注意：这里是倒序遍历所有的分类</span><br><span class=\"line\">    while (i--) &#123;</span><br><span class=\"line\">        // 获取一个分类</span><br><span class=\"line\">        auto cat = cats[I];</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 获取分类的实例方法列表，存进二维数组</span><br><span class=\"line\">        method_list_t *mlist = cat-&gt;methods;</span><br><span class=\"line\">        mlists[mcount++] = mlist;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 属性</span><br><span class=\"line\">        protocol_list_t *protolist = cat-&gt;protocols;</span><br><span class=\"line\">        protolists[protocount++] = protolist;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 协议</span><br><span class=\"line\">        property_list_t *proplist = cat-&gt;properties;</span><br><span class=\"line\">        proplists[propcount++] = proplist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">#pragma mark - 把这个二维数组内所有一维数组的首地址存进methods成员变量所指向的那块内存空间里</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 获取当前类的数据（包括实例方法列表、属性列表、协议列表等）</span><br><span class=\"line\">    auto classData = cls-&gt;data();</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 给当前类的实例方法列表附加所有分类的实例方法列表</span><br><span class=\"line\">    classData-&gt;methods.attachLists(mlists, mcount);</span><br><span class=\"line\">    free(mlists);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 属性</span><br><span class=\"line\">    classData-&gt;properties.attachLists(proplists, propcount);</span><br><span class=\"line\">    free(proplists);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 协议</span><br><span class=\"line\">    classData-&gt;protocols.attachLists(protolists, protocount);</span><br><span class=\"line\">    free(protolists);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 给当前类的实例方法列表附加所有分类的实例方法列表</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param addedLists 所有分类的实例方法列表（就是那个二维数组，但其实是那个二维数组的首地址）</span><br><span class=\"line\"> * @param addedCount 分类的个数</span><br><span class=\"line\"> */</span><br><span class=\"line\">void attachLists(List* const * addedLists, unsigned int addedCount) &#123;</span><br><span class=\"line\">#pragma mark - 重新为类的methods成员变量分配内存</span><br><span class=\"line\">    // 获取类原来methods成员变量的元素个数（注意：一个类的methods成员变量是一个数组，存储着若干个指针，指向相应的方法列表，而不是直接就是个方法列表存储方法）</span><br><span class=\"line\">    unsigned int oldCount = array()-&gt;count;</span><br><span class=\"line\">    // 加上分类的个数，得到新的methods成员变量该有多少个元素</span><br><span class=\"line\">    unsigned int newCount = oldCount + addedCount;</span><br><span class=\"line\">    // 重新为methods成员变量所指向的数组分配内存，一个指针占8个字节</span><br><span class=\"line\">    setArray((array_t *)realloc(array(), array_t::byteSize(newCount)));</span><br><span class=\"line\">    array()-&gt;count = newCount;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">#pragma mark - 为类的methods成员变量重新分配完内存后，对其内存数据进行移动和复制操作</span><br><span class=\"line\">    //</span><br><span class=\"line\">    /*</span><br><span class=\"line\">     内存复制：</span><br><span class=\"line\">     memmove(dst, src, len)，从src所指向的内存空间复制len个字节的数据到dst所指向的内存空间，内部处理了内存覆盖。</span><br><span class=\"line\">     memcpy(dst, src, n)，从src所指向的内存空间复制n个字节的数据到dst所指向的内存空间，内部没处理内存覆盖。</span><br><span class=\"line\">     */</span><br><span class=\"line\">    // 把类原来的实例方法列表复制到最后面（但其实是把类原来的实例方法列表，在methods成员变量里对应的那个指针————原来的实例方法列表的首地址————复制到最后面了）</span><br><span class=\"line\">    memmove(array()-&gt;lists + addedCount, array()-&gt;lists,</span><br><span class=\"line\">            oldCount * sizeof(array()-&gt;lists[0]));</span><br><span class=\"line\">    // 把所有分类的实例方法列表放在前面（同理，其实是把所有分类的的实例方法列表的首地址复制到前面了，因为methods成员变量里存放的是指针————即实例方法列表的地址，不过这里二维数组的内存拷贝会拷贝它里面所有一维数组的首地址，而不仅仅这个二维数组的首地址）</span><br><span class=\"line\">    memcpy(array()-&gt;lists, addedLists,</span><br><span class=\"line\">           addedCount * sizeof(array()-&gt;lists[0]));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就把所有分类的实例方法列表全都合并到类里面去了，最终类的方法列表结构如下：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713113333032.png\" alt=\"img\"></p>\n<p>以上我们只是说明了分类为类扩展实例方法的底层实现，至于分类为类扩展类方法、属性、协议是同理的。</p>\n<h4 id=\"4、分类的-load方法和-initialize方法\"><a href=\"#4、分类的-load方法和-initialize方法\" class=\"headerlink\" title=\"4、分类的+load方法和+initialize方法\"></a>4、分类的<code>+load</code>方法和<code>+initialize</code>方法</h4><table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">调用时机</th>\n<th align=\"center\">调用方式</th>\n<th align=\"center\">调用顺序</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>+load</code>方法</td>\n<td align=\"center\"><code>+load</code>方法是系统把类和分类载入内存时调用的</td>\n<td align=\"center\"><code>+load</code>方法是通过内存地址直接调用的，所以分类的<code>+load</code>方法不会覆盖类的<code>+load</code>方法，也就是说如果类和分类里面都实现了<code>+load</code>方法，那么它们都会被调用</td>\n<td align=\"center\">会先调用所有类的<code>+load</code>方法，然后再调用所有分类的<code>+load</code>方法</td>\n</tr>\n<tr>\n<td align=\"center\"><code>+initialize</code>方法</td>\n<td align=\"center\"><code>+initialize</code>方法是类初始化的时候调用的</td>\n<td align=\"center\"><code>+initialize</code>方法是通过消息发送机制调用的，所以分类的<code>+initialize</code>方法会覆盖类的<code>+initialize</code>方法，也就是说如果类和分类里面都实现了<code>+initialize</code>方法，那么只有分类里面的会被调用</td>\n<td align=\"center\">会优先调用分类的<code>+initialize</code>方法</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>苹果提供类、分类的<code>+load</code>方法和<code>+initialize</code>方法，其实就是给我们开发者暴露两个接口，让我们根据这俩方法的特点来合理使用。比如我们想在某个类被载入内存时做一些事情，就可以在<code>+load</code>方法里做操作，想在某个类初始化时做一些事情，就可以在<code>+initialize</code>方法里做操作。</p>\n</blockquote>\n<h6 id=\"4-1-load方法\"><a href=\"#4-1-load方法\" class=\"headerlink\" title=\"4.1 +load方法\"></a>4.1 <code>+load</code>方法</h6><ul>\n<li>调用时机</li>\n</ul>\n<p>假设有一个<code>INEPerson</code>类，并且为它创建了两个分类<code>INEEat</code>和<code>INEDrink</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEPerson +load&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEEat.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEEat.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEPerson (INEEat) +load&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEDrink.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEPerson (INEDrink) +load&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>我们什么都不做，不使用<code>Person</code>类，甚至连它的头文件也不导入。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------<span class=\"attr\">--ViewController</span><span class=\"selector-class\">.m-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#import</span> &quot;ViewController<span class=\"selector-class\">.h</span>&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@implementation</span> ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[super viewDidLoad]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>直接运行程序，发现控制台打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INEPerson +load</span><br><span class=\"line\">INEPerson (INEEat) +load</span><br><span class=\"line\">INEPerson (INEDrink) +load</span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以得出结论：**<code>+load</code>方法是系统把类和分类载入内存时调用的，<strong>它和我们代码里使用不使用这个类和分类无关。并且因为<code>+load</code>方法只会在类和分类被载入内存时调用，所以</strong>每个类和分类的<code>+load</code>方法在程序的整个生命周期中肯定会被调用且只调用一次。**</p>\n<ul>\n<li>调用方式</li>\n</ul>\n<p>这里先回想一下，上面第三部分我们说过<strong>分类的方法列表会合并到类本身的方法列表里，并且分类的方法列表还会在类本身方法列表的前面，</strong>因此分类的方法会覆盖掉类里同名的方法。</p>\n<p>但不知道你注意没有，上面第1小节的例子，控制台打印了三个东西，也就是说分类的<code>+load</code>方法和类的<code>+load</code>方法都走了，这很奇怪啊，按理说应该只走其中某一个分类的<code>+load</code>方法才对啊，怎么会三个都走呢？也就是说为什么分类的<code>+load</code>方法没有覆盖掉类的<code>+load</code>方法？</p>\n<p>接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看能不能得到答案：（伪代码）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 系统加载镜像</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">load_images</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">call_load_methods</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用+load方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">call_load_methods</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1、首先调用所有类的+load方法</span></span><br><span class=\"line\">    <span class=\"built_in\">call_class_loads</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2、然后调用所有分类的+load方法</span></span><br><span class=\"line\">    <span class=\"built_in\">call_category_loads</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用所有类的+load方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">call_class_loads</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到所有的类</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">loadable_class</span> *classes = loadable_classes;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; loadable_classes_used; i++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取到某个类</span></span><br><span class=\"line\">        Class cls = classes[i].cls;</span><br><span class=\"line\">        <span class=\"comment\">// 获取到某个类+load方法的地址</span></span><br><span class=\"line\">        <span class=\"type\">load_method_t</span> load_method = (<span class=\"type\">load_method_t</span>)classes[i].method;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"comment\">// 直接调用该类的+load方法</span></span><br><span class=\"line\">        (*load_method)(cls, SEL_load);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用所有分类的+load方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">call_category_loads</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到所有的分类</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">loadable_category</span> *cats = loadable_categories;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取到某个分类</span></span><br><span class=\"line\">        Category cat = cats[i].cat;</span><br><span class=\"line\">        <span class=\"comment\">// 获取到某个分类+load方法的地址</span></span><br><span class=\"line\">        <span class=\"type\">load_method_t</span> load_method = (<span class=\"type\">load_method_t</span>)cats[i].method;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 直接调用该分类的+load方法</span></span><br><span class=\"line\">        (*load_method)(cls, SEL_load);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见**<code>+load</code>方法是通过内存地址直接调用的，<strong>而不像普通方法那样走消息发送机制。因此就解释了我们留下的疑惑，虽然说分类的方法列表在类本身方法列表的前面，但是对<code>+load</code>方法根本不起作用，人家不走你那一套，</strong>所以分类的<code>+load</code>方法不会覆盖类的<code>+load</code>方法。**</p>\n<ul>\n<li>调用顺序</li>\n</ul>\n<p>这里就直接给出结论了，感兴趣的话，可以像第2小节那样去看源码（核心代码就集中在上面那几个方法里）并敲代码验证验证。</p>\n<p><strong>会先调用所有类的<code>+load</code>方法，先编译的类先调用；如果存在继承关系，那么在调用子类的<code>+load</code>方法之前会先去调用父类的<code>+load</code>方法。</strong></p>\n<p><strong>然后再调用所有分类的<code>+load</code>方法，先编译的分类先调用。</strong></p>\n<h6 id=\"4-2-initialize方法\"><a href=\"#4-2-initialize方法\" class=\"headerlink\" title=\"4.2 +initialize方法\"></a>4.2 <code>+initialize</code>方法</h6><ul>\n<li>调用时机</li>\n</ul>\n<p>假设有一个<code>INEPerson</code>类和一个继承自<code>INEPerson</code>类的<code>INEStudent</code>类，并且为<code>INEStudent</code>类创建了两个分类<code>INEEat</code>和<code>INEDrink</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)initialize &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEPerson +initialize&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEStudent.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEStudent.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEStudent</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)initialize &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEStudent +initialize&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEStudent+INEEat.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEStudent+INEEat.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEStudent</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)initialize &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEStudent (INEEat) +initialize&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEStudent+INEDrink.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEStudent+INEDrink.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEStudent</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)initialize &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;INEStudent (INEDrink) +initialize&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>我们什么都不做，直接运行程序，发现控制台什么都没打印。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------<span class=\"attr\">--ViewController</span><span class=\"selector-class\">.m-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#import</span> &quot;ViewController<span class=\"selector-class\">.h</span>&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@implementation</span> ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[super viewDidLoad]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>此时我们调用一下<code>Student</code>类的<code>+alloc</code>方法。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">---------<span class=\"attr\">--ViewController</span><span class=\"selector-class\">.m-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#import</span> &quot;ViewController<span class=\"selector-class\">.h</span>&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@implementation</span> ViewController</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)viewDidLoad &#123;</span><br><span class=\"line\">    <span class=\"selector-attr\">[super viewDidLoad]</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"selector-attr\">[INEStudent alloc]</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行程序，发现控制台打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INEPerson +initialize</span><br><span class=\"line\">INEStudent (INEDrink) +initialize</span><br></pre></td></tr></table></figure>\n\n<p>于是我们就可以得出结论：**<code>+initialize</code>方法是类初始化的时候调用的，<strong>所以严格地来讲，我们不能说“<code>+initialize</code>方法是第一次使用类的时候调用的”，你看上面例子中我们根本没使用<code>INEPerson</code>类嘛，但它的<code>+initialize</code>方法照样被调用了。</strong>如果我们压根儿不使用这个类，它的<code>+initialize</code>方法被调用0次，但是我们不能说一个类的<code>+initialize</code>方法最多被调用1次，因为<code>+initialize</code>方法是通过消息发送机制来调用的，如果好几个子类都继承自某一个类，而这些子类都没有实现自己的<code>+initialize</code>方法，那就都会去调用这个父类的<code>+initialize</code>方法，这不就是调用N次了嘛。**</p>\n<ul>\n<li>调用方式</li>\n</ul>\n<p>上面第1小节的例子，控制台打印了一个：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INEStudent (INEDrink) +initialize</span><br></pre></td></tr></table></figure>\n\n<p>这就明显表明：**<code>+initialize</code>方法的调用方式不同于<code>+load</code>方法，它是通过消息发送机制调用的，所以才会只走分类里面的 <code>+initialize</code>方法，也就是说分类的<code>+initialize</code>方法会覆盖类的<code>+initialize</code>方法。**</p>\n<p>但有一点很奇怪，因为控制台还打印了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INEPerson +initialize</span><br></pre></td></tr></table></figure>\n\n<p>这是父类的<code>+initialize</code>方法呀！既然<code>+initialize</code>方法是通过消息发送机制调用的，那它在自己类的内部找到某个方法后，就不应该再调用父类里面的方法了呀，怎么回事？</p>\n<p>接下来我们就找找运行时（Runtime）的相关源码（<code>objc-runtime-new.mm</code>文件），看看能不能得到答案：（伪代码）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找方法的实现：类接收到消息后，会去查找这个消息的实现并调用，那我们就从查找这个消息的实现下手吧，前面的源码没有相关信息</span></span><br><span class=\"line\"><span class=\"function\">IMP <span class=\"title\">lookUpImpOrForward</span><span class=\"params\">(Class cls, SEL sel)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在查找方法的过程中，如果发现这个类没被初始化过</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cls-&gt;<span class=\"built_in\">isInitialized</span>()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 则初始化这个类</span></span><br><span class=\"line\">        <span class=\"built_in\">initializeNonMetaClass</span>(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 初始化一个类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initializeNonMetaClass</span><span class=\"params\">(Class cls)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在初始化一个类的过程中</span></span><br><span class=\"line\">    Class supercls = cls-&gt;superclass;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (supercls  &amp;&amp;  !supercls-&gt;<span class=\"built_in\">isInitialized</span>()) &#123;<span class=\"comment\">// 如果发现这个类的父类没被初始化过</span></span><br><span class=\"line\">        <span class=\"comment\">// 则递归，一层一层地先初始化父类，直到NSObject，直到nil</span></span><br><span class=\"line\">        <span class=\"built_in\">initializeNonMetaClass</span>(supercls);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 一层一层初始化完之后，才会一层一层自上而下地调用各个类的+initialize方法</span></span><br><span class=\"line\">        <span class=\"built_in\">callInitialize</span>(cls);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 如果发现这个类的父类被初始化过了</span></span><br><span class=\"line\">        <span class=\"comment\">// 则直接初始化自己</span></span><br><span class=\"line\">        <span class=\"built_in\">initializeNonMetaClass</span>(cls);</span><br><span class=\"line\">        <span class=\"comment\">// 并调用自己的+initialize方法，</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果自己没有实现，则会去找父类的+initialize方法调用。（因为+initialize方法是通过消息发送机制调用的嘛）</span></span><br><span class=\"line\">        <span class=\"built_in\">callInitialize</span>(cls);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">callInitialize</span><span class=\"params\">(Class cls)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// +initialize方法确实是通过消息发送机制调用的</span></span><br><span class=\"line\">    ((<span class=\"built_in\">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见<strong>系统在调用一个类的<code>+initialize</code>方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的<code>+initialize</code>方法，然后再初始化自己并调用自己的<code>+initialize</code>方法；如果它的父类初始化了，则直接初始化自己并调用自己的<code>+initialize</code>方法，如果自己没有实现，则会去找父类的<code>+initialize</code>方法调用。</strong></p>\n<ul>\n<li>调用顺序</li>\n</ul>\n<p>这里就直接给出结论了。</p>\n<p><strong>系统在调用一个类的<code>+initialize</code>方法之前，首先会看看它的父类初始化了没有，如果没有初始化，则初始化它的父类并调用它父类的<code>+initialize</code>方法，然后再初始化自己并调用自己的<code>+initialize</code>方法；如果它的父类初始化了，则直接初始化自己并调用自己的<code>+initialize</code>方法，如果自己没有实现，则会去找父类的<code>+initialize</code>方法调用。</strong></p>\n<p><strong>如果分类里也实现了<code>+initialize</code>方法，会优先调用分类的。</strong></p>\n<h3 id=\"temp、行文至此，我们举个例子串一下上面的内容\"><a href=\"#temp、行文至此，我们举个例子串一下上面的内容\" class=\"headerlink\" title=\"temp、行文至此，我们举个例子串一下上面的内容\"></a>temp、行文至此，我们举个例子串一下上面的内容</h3><p>定义一个<code>INEPerson</code>类，并为它创建一个分类<code>INEDrink</code>，然后创建两个<code>person</code>对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> : <span class=\"title\">NSObject</span> &lt;<span class=\"title\">NSCopying</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *name;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *sex;</span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSInteger</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)eat;</span><br><span class=\"line\">+ (<span class=\"type\">void</span>)sleep;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)eat &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;对象方法：吃&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)sleep &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;类方法：睡&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">id</span>)copyWithZone:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">NSZone</span> *)zone &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 浅拷贝一下</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson+INEDrink.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_drinkWater;</span><br><span class=\"line\">+ (<span class=\"type\">void</span>)ine_drinkTea;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------INEPerson+INEDrink.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEDrink.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEDrink</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_drinkWater &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)ine_drinkTea &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------ViewController.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    INEPerson *person1 = [[INEPerson alloc] init];</span><br><span class=\"line\">    person1.name = <span class=\"string\">@&quot;张三&quot;</span>;</span><br><span class=\"line\">    person1.sex = <span class=\"string\">@&quot;男&quot;</span>;</span><br><span class=\"line\">    person1.age = <span class=\"number\">19</span>;</span><br><span class=\"line\">    [person1 eat];</span><br><span class=\"line\">    </span><br><span class=\"line\">    INEPerson *person2 = [[INEPerson alloc] init];</span><br><span class=\"line\">    person2.name = <span class=\"string\">@&quot;李四&quot;</span>;</span><br><span class=\"line\">    person2.sex = <span class=\"string\">@&quot;女&quot;</span>;</span><br><span class=\"line\">    person2.age = <span class=\"number\">18</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    [INEPerson sleep];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们启动App时，系统就会把<code>INEPerson</code>类、<code>INEPerson</code>类的元类还有<code>INEPerson</code>类的分类加载到内存中，然后把分类的数据合并到类和元类里，并且这些类会被存储到静态全局区，因为类只要一份就够了嘛 + 类还得能在项目的任何地方都能访问到，直到杀死App，这些类的内存才会被释放。那么<code>INEPerson</code>类在静态全局区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向<code>INEPerson</code>类的元类，这个地址就是<code>INEPerson</code>类的元类在静态全局区的内存地址；<code>superClass</code>指针存储着一个地址，指向<code>NSObject</code>类，这个地址就是<code>NSObject</code>类在静态全局区的内存地址；<code>methods</code>成员变量存储着<code>ine_drinkWater</code>和<code>eat</code>这两个实例方法的信息，<code>properties</code>成员变量存储着<code>name</code>、<code>sex</code>、<code>age</code>这些属性的信息，<code>protocols</code>成员变量存储着<code>NSCopying</code>协议的信息，<code>ivars</code>成员变量存储着<code>_name</code>、<code>_sex</code>、<code>_age</code>这些成员变量的信息，<code>cache</code>缓存着<code>eat</code>方法的信息。<code>INEPerson</code>类的元类在静态全局区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向基类<code>NSObject</code>类的元类，这个地址就是基类<code>NSObject</code>类的元类在静态全局区的内存地址；<code>superClass</code>指针存储着一个地址，同样指向基类<code>NSObject</code>类的元类，这个地址就是基类<code>NSObject</code>类的元类在静态全局区的内存地址；<code>methods</code>成员变量存储着<code>ine_drinkTea</code>和<code>sleep</code>这个类方法的信息，<code>cache</code>缓存着<code>sleep</code>方法的信息。</p>\n<p>当我们<code>alloc init</code>一个<code>person</code>对象时，就会在堆区分配一块内存，直到没有强引用引用这个对象了，这块内存才会被释放。那么<code>person</code>对象在堆区的那块内存里存储着什么呢？<code>isa</code>指针存储着一个地址，指向<code>INEPerson</code>类，这个地址就是<code>INEPerson</code>类在静态全局区的内存地址；<code>person1</code>对象接下来会存储<code>_name</code>成员变量的值”张三”，当然它存储的也是一个常量区的地址，指向”张三”这个字符串常量，还有<code>_sex</code>成员变量的值”男”，当然它存储的也是一个常量区的地址，指向”男”这个字符串常量，还有<code>_age</code>成员变量的值“19”，当然“19”就是直接存储了，因为它是个立即数；<code>person2</code>对象接下来则会存储<code>_name</code>成员变量的值”李四”，<code>_sex</code>成员变量的值”女”，<code>_age</code>成员变量的值“18”，注意对象的内存里存储的是成员变量的值，而类的内存里存储的是成员变量的信息——比如<code>INEPerson</code>类有一个成员变量是“_name”，它的类型是<code>NSString</code>这样。</p>"},{"title":"【Runtime】isa指针和superClass指针的指向，methods、cache成员变量详解","date":"2021-07-12T12:12:53.000Z","_content":"\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713203040874.png)\n\n> 一、对象、类、元类的`isa`指针和`superClass`指针指向讲解\n>\n> 二、类、元类的`methods`成员变量详解\n>\n> 三、类、元类的`cache`成员变量详解\n\n<!--more-->\n\n### 一、对象、类、元类的`isa`指针和`superClass`指针指向讲解\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/937.png)\n\n`isa`指针和`superclass`指针是两个非常重要的指针，弄清它俩的指向有助于我们理解很多东西。\n\n概括地说：**`isa`指针指向它所属的类，`superclass`指针指向它的父类。**\n\n具体地说：\n\n- **实例对象的`isa`指针指向它所属的类，类的`isa`指针指向它的元类，元类的`isa`指针指向基类的元类，基类的元类的`isa`指针指向它自己。**（`isa`指针体系中基类的元类是终结）\n- **子类的`superclass`指针指向它的父类，这样一层一层往上直到基类，基类的`superclass`指针为`nil`；子元类的`superclass`指针指向父元类，这样一层一层往上直到基类的元类，基类的元类的`superclass`指针指向基类。**（`superclass`指针体系中`nil`是终结）\n\n### 二、类、元类的`methonds`成员变量详解\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220714114122326.png)\n\n我们知道了类的`methods`成员变量存储着该类所有的实例方法信息，那它到底是怎么存储的？类的`methods`成员变量其实是一个数组指针，也就是说`methods`成员变量里存储着一个地址，只占了8个字节，指向一个数组。而这个数组又是一个指针数组，这个数组的大小要看这个类有几个分类，假设有N个分类，那么它就占了(N + 1) * 8个字节，也就是说这个数组里存储着一堆地址，分别指向真正的实例方法列表，这些实例方法列表包括分类2的实例方法列表、分类1的实例方法列表、类本身的实例方法列表等等，方法列表里才存放着一个一个的实例方法`method_t`，一个`method_t`结构体里有3个指针，所以它占用了24个字节，这些内存都是在静态全局区的，它们的大小其实占不了多少，一个App真正占用内存的是我们用这些类`alloc init`出来的一个个对象，还有图片资源。元类的`methods`成员变量也是一样的存储方式，只不过里面存储的是该类所有的类方法信息。\n\n通过查看Runtime的源码（`objc-runtime-new.h`文件），我们得到方法的定义如下（伪代码）：\n\n```cpp\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n};\n\ntypedef struct method_t *Method; // Method类型的本质就是一个method_t类型的结构体指针，所以它可以指向任意一个OC方法\n```\n\n可见方法的本质就是一个`method_t`类型的结构体，该结构体内部有三个成员变量：\n\n- `SEL`：**方法选择器，跟方法名一一对应，是一个方法的唯一标识，我们直接把它当作方法名来看待就行**，可以通过`@selector(方法名)`、`NSSelectorFromString(@\"方法名的OC字符串\")`、`sel_registerName(\"方法名的C字符串\")`来获取方法选择器；\n\n- `types`：**类型编码字符串，包含了方法的参数和返回值信息**，这里是[类型编码对照表](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FCocoa%2FConceptual%2FObjCRuntimeGuide%2FArticles%2FocrtTypeEncodings.html)，类型编码中第一个字母代表该方法的返回值类型，后面的字母依次代表该方法的各个参数类型；第一个数字代表该方法所有参数占用内存的总大小，后面的数字依次代表该方法各个参数的内存地址距离内存首地址的偏移量；\n\n- `IMP`：**函数指针，存储着一个地址，只想该方法在代码区的具体实现。**\n\n### 三、类、元类的`cache`成员变量详解\n\n我们知道一个对象接收到消息，会根据它的`isa`指针找到他所属的类，然后根据类的`methods`成员变量找到所有的方法列表，然后依次**遍历**这些方法列表来查找要执行的方法。但实际情况中，一个对象只有一部分方法是常用的，其他的方法很少用到或根本用不到，那如果对象每接收一个消息就要遍历一次所有的方法列表，性能肯定会很差。**类的`cache`成员变量就是用来解决问题的，对象每调用一个方法，系统就会把这个方法存储到`cache`中，下次对象调用方法时就会优先去`cache`中查找，如果找到方法则直接调用，如果找不到才去`methods`哪里找，这就大大提高了查找效率。而且`cache`还不是简单地存取方法，它用了散列表，这就使得方法查找的效率更高。**\n\n通过查看Runtime的源码（`objc-runtime-new.h`文件），我们得到`cache`的定义如下（伪代码）：\n\n\n\n```cpp\nstruct cache_t {\n    struct bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\n}\n\nstruct bucket_t {\n    SEL _sel;\n    IMP _imp;\n}\n```\n\n可见`cache`的本质就是一个`cache_t`类型的结构体，该结构体内部有三个成员变量：\n\n- **`_buckets`：方法缓存散列表；**\n- **`_mask`：散列表的长度 - 1；**\n- **`_occupied`：已缓存方法的数量。**\n\n散列表中的元素也不直接是方法——`method_t`，而是一个叫`bucket_t`的东西，它是用方法的`SEL`和`IMP`组成的结构体。（为方便叙述，下文中“方法”即指`bucket_t`）\n\n> 关键词：散列表、表中元素、表中元素唯一标识、散列算法和散列函数、`index`\n>\n> 散列表（Hash Table，也叫哈希表），就是**把表中元素的唯一标识通过某种算法得到一个`index`，然后通过这个`index`直接访问表中元素的一种数据结构，**这样就不用遍历了，因此**可以大大提高数据查找的效率。**实现这个算法的函数叫作散列函数，存储数据的数组叫作散列表（但这个数组不是普通的数组，它的元素可以不连续存储，因此散列表就有可能造成内存的空闲，它是一个**典型的“以空间换时间”**的例子）。**散列表的核心就在于散列算法。**\n\n接下来我们就看看苹果是如何实现`cache`散列表的。\n\n- `cache`散列表的散列算法：\n\n\n\n```cpp\nunsigned int cache_hash(SEL sel, mask_t mask)\n{\n    return (unsigned int)(unsigned long)sel & mask;\n}\n```\n\n可见苹果关于`cache`散列表的散列算法其实很简单，就是：**用方法的`SEL` & （散列表的长度 - 1）**，这样就能得到一个`index`了，我们知道方法的`SEL`确实是表中元素的唯一标识。\n\n- `cache`散列表处理冲突\n\n散列表都会存在的一个问题是：**不同的唯一标识经过散列算法后可能得到相同的`index`，**那这样数据存取就可能出现冲突，怎么处理呢？\n\n\n\n```cpp\n// 这里只是读取方法的源码，存储方法也是一样的道理\n\nbucket_t * cache_t::find()\n{\n    // 先通过散列算法得到某个元素的index\n    mask_t begin = cache_hash(sel, _mask);\n\n    mask_t i = begin;\n    do {\n        if (_buckets[i].sel() == sel) { // 然后去读取该index处的元素，如果发现该元素的唯一标识SEL和我们想要读取元素的SEL一样，就表明读对了，直接返回该元素\n            return &_buckets[I];\n        }\n    } while ((i = cache_next(i, _mask)) != begin);\n}\n\nmask_t cache_next(mask_t i, mask_t mask) {\n    // 否则（index-1），遍历散列表，直到读取到想要的元素\n    return i ? i-1 : mask;\n}\n```\n\n可见`cache`散列表处理冲突的方式为：**index-1，然后遍历散列表，**直到找到空闲的内存来存储方法，或者直到找到我们真正想读取的方法。\n\n- `cache`散列表存取数据\n\n通过散列算法得到`index`之后，系统就会把这个方法直接存储到散列表相应的`index`处，因此这就可能造成内存的空闲。\n\n而读取方法的时候也是先通过散列算法得到`index`，直接从相应的`index`处拿出方法，因此就不用遍历了，大大提高了方法查找的效率。\n\n- `cache`散列表扩容\n\n\n\n```cpp\nvoid cache_t::expand()\n{\n    uint32_t oldCapacity = capacity();\n    uint32_t newCapacity = oldCapacity * 2; // 两倍扩容\n    // 开辟新的散列表\n    bucket_t *newBuckets = allocateBuckets(newCapacity);\n    \n    // 释放旧的散列表，清空所有的方法缓存\n    bucket_t *oldBuckets = buckets();\n    cache_collect_free(oldBuckets);\n}\n```\n\n随着散列表缓存的方法越来越多，它的内存可能就不够用了，此时系统会对散列表进行两倍扩容，创建一个新的散列表，释放旧的散列表并清空所有的方法缓存。\n\n","source":"_posts/Runtime：isa指针和superClass指针的指向，methods、cache成员变量详解.md","raw":"---\ntitle: 【Runtime】isa指针和superClass指针的指向，methods、cache成员变量详解\ndate: 2021-07-12 20:12:53\ntags: Runtime系列\n---\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713203040874.png)\n\n> 一、对象、类、元类的`isa`指针和`superClass`指针指向讲解\n>\n> 二、类、元类的`methods`成员变量详解\n>\n> 三、类、元类的`cache`成员变量详解\n\n<!--more-->\n\n### 一、对象、类、元类的`isa`指针和`superClass`指针指向讲解\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/937.png)\n\n`isa`指针和`superclass`指针是两个非常重要的指针，弄清它俩的指向有助于我们理解很多东西。\n\n概括地说：**`isa`指针指向它所属的类，`superclass`指针指向它的父类。**\n\n具体地说：\n\n- **实例对象的`isa`指针指向它所属的类，类的`isa`指针指向它的元类，元类的`isa`指针指向基类的元类，基类的元类的`isa`指针指向它自己。**（`isa`指针体系中基类的元类是终结）\n- **子类的`superclass`指针指向它的父类，这样一层一层往上直到基类，基类的`superclass`指针为`nil`；子元类的`superclass`指针指向父元类，这样一层一层往上直到基类的元类，基类的元类的`superclass`指针指向基类。**（`superclass`指针体系中`nil`是终结）\n\n### 二、类、元类的`methonds`成员变量详解\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220714114122326.png)\n\n我们知道了类的`methods`成员变量存储着该类所有的实例方法信息，那它到底是怎么存储的？类的`methods`成员变量其实是一个数组指针，也就是说`methods`成员变量里存储着一个地址，只占了8个字节，指向一个数组。而这个数组又是一个指针数组，这个数组的大小要看这个类有几个分类，假设有N个分类，那么它就占了(N + 1) * 8个字节，也就是说这个数组里存储着一堆地址，分别指向真正的实例方法列表，这些实例方法列表包括分类2的实例方法列表、分类1的实例方法列表、类本身的实例方法列表等等，方法列表里才存放着一个一个的实例方法`method_t`，一个`method_t`结构体里有3个指针，所以它占用了24个字节，这些内存都是在静态全局区的，它们的大小其实占不了多少，一个App真正占用内存的是我们用这些类`alloc init`出来的一个个对象，还有图片资源。元类的`methods`成员变量也是一样的存储方式，只不过里面存储的是该类所有的类方法信息。\n\n通过查看Runtime的源码（`objc-runtime-new.h`文件），我们得到方法的定义如下（伪代码）：\n\n```cpp\nstruct method_t {\n    SEL name;\n    const char *types;\n    IMP imp;\n};\n\ntypedef struct method_t *Method; // Method类型的本质就是一个method_t类型的结构体指针，所以它可以指向任意一个OC方法\n```\n\n可见方法的本质就是一个`method_t`类型的结构体，该结构体内部有三个成员变量：\n\n- `SEL`：**方法选择器，跟方法名一一对应，是一个方法的唯一标识，我们直接把它当作方法名来看待就行**，可以通过`@selector(方法名)`、`NSSelectorFromString(@\"方法名的OC字符串\")`、`sel_registerName(\"方法名的C字符串\")`来获取方法选择器；\n\n- `types`：**类型编码字符串，包含了方法的参数和返回值信息**，这里是[类型编码对照表](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FCocoa%2FConceptual%2FObjCRuntimeGuide%2FArticles%2FocrtTypeEncodings.html)，类型编码中第一个字母代表该方法的返回值类型，后面的字母依次代表该方法的各个参数类型；第一个数字代表该方法所有参数占用内存的总大小，后面的数字依次代表该方法各个参数的内存地址距离内存首地址的偏移量；\n\n- `IMP`：**函数指针，存储着一个地址，只想该方法在代码区的具体实现。**\n\n### 三、类、元类的`cache`成员变量详解\n\n我们知道一个对象接收到消息，会根据它的`isa`指针找到他所属的类，然后根据类的`methods`成员变量找到所有的方法列表，然后依次**遍历**这些方法列表来查找要执行的方法。但实际情况中，一个对象只有一部分方法是常用的，其他的方法很少用到或根本用不到，那如果对象每接收一个消息就要遍历一次所有的方法列表，性能肯定会很差。**类的`cache`成员变量就是用来解决问题的，对象每调用一个方法，系统就会把这个方法存储到`cache`中，下次对象调用方法时就会优先去`cache`中查找，如果找到方法则直接调用，如果找不到才去`methods`哪里找，这就大大提高了查找效率。而且`cache`还不是简单地存取方法，它用了散列表，这就使得方法查找的效率更高。**\n\n通过查看Runtime的源码（`objc-runtime-new.h`文件），我们得到`cache`的定义如下（伪代码）：\n\n\n\n```cpp\nstruct cache_t {\n    struct bucket_t *_buckets;\n    mask_t _mask;\n    mask_t _occupied;\n}\n\nstruct bucket_t {\n    SEL _sel;\n    IMP _imp;\n}\n```\n\n可见`cache`的本质就是一个`cache_t`类型的结构体，该结构体内部有三个成员变量：\n\n- **`_buckets`：方法缓存散列表；**\n- **`_mask`：散列表的长度 - 1；**\n- **`_occupied`：已缓存方法的数量。**\n\n散列表中的元素也不直接是方法——`method_t`，而是一个叫`bucket_t`的东西，它是用方法的`SEL`和`IMP`组成的结构体。（为方便叙述，下文中“方法”即指`bucket_t`）\n\n> 关键词：散列表、表中元素、表中元素唯一标识、散列算法和散列函数、`index`\n>\n> 散列表（Hash Table，也叫哈希表），就是**把表中元素的唯一标识通过某种算法得到一个`index`，然后通过这个`index`直接访问表中元素的一种数据结构，**这样就不用遍历了，因此**可以大大提高数据查找的效率。**实现这个算法的函数叫作散列函数，存储数据的数组叫作散列表（但这个数组不是普通的数组，它的元素可以不连续存储，因此散列表就有可能造成内存的空闲，它是一个**典型的“以空间换时间”**的例子）。**散列表的核心就在于散列算法。**\n\n接下来我们就看看苹果是如何实现`cache`散列表的。\n\n- `cache`散列表的散列算法：\n\n\n\n```cpp\nunsigned int cache_hash(SEL sel, mask_t mask)\n{\n    return (unsigned int)(unsigned long)sel & mask;\n}\n```\n\n可见苹果关于`cache`散列表的散列算法其实很简单，就是：**用方法的`SEL` & （散列表的长度 - 1）**，这样就能得到一个`index`了，我们知道方法的`SEL`确实是表中元素的唯一标识。\n\n- `cache`散列表处理冲突\n\n散列表都会存在的一个问题是：**不同的唯一标识经过散列算法后可能得到相同的`index`，**那这样数据存取就可能出现冲突，怎么处理呢？\n\n\n\n```cpp\n// 这里只是读取方法的源码，存储方法也是一样的道理\n\nbucket_t * cache_t::find()\n{\n    // 先通过散列算法得到某个元素的index\n    mask_t begin = cache_hash(sel, _mask);\n\n    mask_t i = begin;\n    do {\n        if (_buckets[i].sel() == sel) { // 然后去读取该index处的元素，如果发现该元素的唯一标识SEL和我们想要读取元素的SEL一样，就表明读对了，直接返回该元素\n            return &_buckets[I];\n        }\n    } while ((i = cache_next(i, _mask)) != begin);\n}\n\nmask_t cache_next(mask_t i, mask_t mask) {\n    // 否则（index-1），遍历散列表，直到读取到想要的元素\n    return i ? i-1 : mask;\n}\n```\n\n可见`cache`散列表处理冲突的方式为：**index-1，然后遍历散列表，**直到找到空闲的内存来存储方法，或者直到找到我们真正想读取的方法。\n\n- `cache`散列表存取数据\n\n通过散列算法得到`index`之后，系统就会把这个方法直接存储到散列表相应的`index`处，因此这就可能造成内存的空闲。\n\n而读取方法的时候也是先通过散列算法得到`index`，直接从相应的`index`处拿出方法，因此就不用遍历了，大大提高了方法查找的效率。\n\n- `cache`散列表扩容\n\n\n\n```cpp\nvoid cache_t::expand()\n{\n    uint32_t oldCapacity = capacity();\n    uint32_t newCapacity = oldCapacity * 2; // 两倍扩容\n    // 开辟新的散列表\n    bucket_t *newBuckets = allocateBuckets(newCapacity);\n    \n    // 释放旧的散列表，清空所有的方法缓存\n    bucket_t *oldBuckets = buckets();\n    cache_collect_free(oldBuckets);\n}\n```\n\n随着散列表缓存的方法越来越多，它的内存可能就不够用了，此时系统会对散列表进行两倍扩容，创建一个新的散列表，释放旧的散列表并清空所有的方法缓存。\n\n","slug":"Runtime：isa指针和superClass指针的指向，methods、cache成员变量详解","published":1,"updated":"2022-07-18T03:27:03.833Z","_id":"cl5kjln5c0000hz2r6yd191ta","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713203040874.png\" alt=\"img\"></p>\n<blockquote>\n<p>一、对象、类、元类的<code>isa</code>指针和<code>superClass</code>指针指向讲解</p>\n<p>二、类、元类的<code>methods</code>成员变量详解</p>\n<p>三、类、元类的<code>cache</code>成员变量详解</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3 id=\"一、对象、类、元类的isa指针和superClass指针指向讲解\"><a href=\"#一、对象、类、元类的isa指针和superClass指针指向讲解\" class=\"headerlink\" title=\"一、对象、类、元类的isa指针和superClass指针指向讲解\"></a>一、对象、类、元类的<code>isa</code>指针和<code>superClass</code>指针指向讲解</h3><p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/937.png\" alt=\"img\"></p>\n<p><code>isa</code>指针和<code>superclass</code>指针是两个非常重要的指针，弄清它俩的指向有助于我们理解很多东西。</p>\n<p>概括地说：**<code>isa</code>指针指向它所属的类，<code>superclass</code>指针指向它的父类。**</p>\n<p>具体地说：</p>\n<ul>\n<li><strong>实例对象的<code>isa</code>指针指向它所属的类，类的<code>isa</code>指针指向它的元类，元类的<code>isa</code>指针指向基类的元类，基类的元类的<code>isa</code>指针指向它自己。</strong>（<code>isa</code>指针体系中基类的元类是终结）</li>\n<li><strong>子类的<code>superclass</code>指针指向它的父类，这样一层一层往上直到基类，基类的<code>superclass</code>指针为<code>nil</code>；子元类的<code>superclass</code>指针指向父元类，这样一层一层往上直到基类的元类，基类的元类的<code>superclass</code>指针指向基类。</strong>（<code>superclass</code>指针体系中<code>nil</code>是终结）</li>\n</ul>\n<h3 id=\"二、类、元类的methonds成员变量详解\"><a href=\"#二、类、元类的methonds成员变量详解\" class=\"headerlink\" title=\"二、类、元类的methonds成员变量详解\"></a>二、类、元类的<code>methonds</code>成员变量详解</h3><p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220714114122326.png\" alt=\"img\"></p>\n<p>我们知道了类的<code>methods</code>成员变量存储着该类所有的实例方法信息，那它到底是怎么存储的？类的<code>methods</code>成员变量其实是一个数组指针，也就是说<code>methods</code>成员变量里存储着一个地址，只占了8个字节，指向一个数组。而这个数组又是一个指针数组，这个数组的大小要看这个类有几个分类，假设有N个分类，那么它就占了(N + 1) * 8个字节，也就是说这个数组里存储着一堆地址，分别指向真正的实例方法列表，这些实例方法列表包括分类2的实例方法列表、分类1的实例方法列表、类本身的实例方法列表等等，方法列表里才存放着一个一个的实例方法<code>method_t</code>，一个<code>method_t</code>结构体里有3个指针，所以它占用了24个字节，这些内存都是在静态全局区的，它们的大小其实占不了多少，一个App真正占用内存的是我们用这些类<code>alloc init</code>出来的一个个对象，还有图片资源。元类的<code>methods</code>成员变量也是一样的存储方式，只不过里面存储的是该类所有的类方法信息。</p>\n<p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到方法的定义如下（伪代码）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">method_t</span> &#123;</span><br><span class=\"line\">    SEL name;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *types;</span><br><span class=\"line\">    IMP imp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">method_t</span> *Method; <span class=\"comment\">// Method类型的本质就是一个method_t类型的结构体指针，所以它可以指向任意一个OC方法</span></span><br></pre></td></tr></table></figure>\n\n<p>可见方法的本质就是一个<code>method_t</code>类型的结构体，该结构体内部有三个成员变量：</p>\n<ul>\n<li><p><code>SEL</code>：<strong>方法选择器，跟方法名一一对应，是一个方法的唯一标识，我们直接把它当作方法名来看待就行</strong>，可以通过<code>@selector(方法名)</code>、<code>NSSelectorFromString(@&quot;方法名的OC字符串&quot;)</code>、<code>sel_registerName(&quot;方法名的C字符串&quot;)</code>来获取方法选择器；</p>\n</li>\n<li><p><code>types</code>：<strong>类型编码字符串，包含了方法的参数和返回值信息</strong>，这里是<a href=\"https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\">类型编码对照表</a>，类型编码中第一个字母代表该方法的返回值类型，后面的字母依次代表该方法的各个参数类型；第一个数字代表该方法所有参数占用内存的总大小，后面的数字依次代表该方法各个参数的内存地址距离内存首地址的偏移量；</p>\n</li>\n<li><p><code>IMP</code>：<strong>函数指针，存储着一个地址，只想该方法在代码区的具体实现。</strong></p>\n</li>\n</ul>\n<h3 id=\"三、类、元类的cache成员变量详解\"><a href=\"#三、类、元类的cache成员变量详解\" class=\"headerlink\" title=\"三、类、元类的cache成员变量详解\"></a>三、类、元类的<code>cache</code>成员变量详解</h3><p>我们知道一个对象接收到消息，会根据它的<code>isa</code>指针找到他所属的类，然后根据类的<code>methods</code>成员变量找到所有的方法列表，然后依次<strong>遍历</strong>这些方法列表来查找要执行的方法。但实际情况中，一个对象只有一部分方法是常用的，其他的方法很少用到或根本用不到，那如果对象每接收一个消息就要遍历一次所有的方法列表，性能肯定会很差。<strong>类的<code>cache</code>成员变量就是用来解决问题的，对象每调用一个方法，系统就会把这个方法存储到<code>cache</code>中，下次对象调用方法时就会优先去<code>cache</code>中查找，如果找到方法则直接调用，如果找不到才去<code>methods</code>哪里找，这就大大提高了查找效率。而且<code>cache</code>还不是简单地存取方法，它用了散列表，这就使得方法查找的效率更高。</strong></p>\n<p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到<code>cache</code>的定义如下（伪代码）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cache_t</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">bucket_t</span> *_buckets;</span><br><span class=\"line\">    <span class=\"type\">mask_t</span> _mask;</span><br><span class=\"line\">    <span class=\"type\">mask_t</span> _occupied;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">bucket_t</span> &#123;</span><br><span class=\"line\">    SEL _sel;</span><br><span class=\"line\">    IMP _imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见<code>cache</code>的本质就是一个<code>cache_t</code>类型的结构体，该结构体内部有三个成员变量：</p>\n<ul>\n<li><strong><code>_buckets</code>：方法缓存散列表；</strong></li>\n<li><strong><code>_mask</code>：散列表的长度 - 1；</strong></li>\n<li><strong><code>_occupied</code>：已缓存方法的数量。</strong></li>\n</ul>\n<p>散列表中的元素也不直接是方法——<code>method_t</code>，而是一个叫<code>bucket_t</code>的东西，它是用方法的<code>SEL</code>和<code>IMP</code>组成的结构体。（为方便叙述，下文中“方法”即指<code>bucket_t</code>）</p>\n<blockquote>\n<p>关键词：散列表、表中元素、表中元素唯一标识、散列算法和散列函数、<code>index</code></p>\n<p>散列表（Hash Table，也叫哈希表），就是<strong>把表中元素的唯一标识通过某种算法得到一个<code>index</code>，然后通过这个<code>index</code>直接访问表中元素的一种数据结构，</strong>这样就不用遍历了，因此<strong>可以大大提高数据查找的效率。</strong>实现这个算法的函数叫作散列函数，存储数据的数组叫作散列表（但这个数组不是普通的数组，它的元素可以不连续存储，因此散列表就有可能造成内存的空闲，它是一个<strong>典型的“以空间换时间”</strong>的例子）。<strong>散列表的核心就在于散列算法。</strong></p>\n</blockquote>\n<p>接下来我们就看看苹果是如何实现<code>cache</code>散列表的。</p>\n<ul>\n<li><code>cache</code>散列表的散列算法：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title\">cache_hash</span><span class=\"params\">(SEL sel, <span class=\"type\">mask_t</span> mask)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)(<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)sel &amp; mask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见苹果关于<code>cache</code>散列表的散列算法其实很简单，就是：<strong>用方法的<code>SEL</code> &amp; （散列表的长度 - 1）</strong>，这样就能得到一个<code>index</code>了，我们知道方法的<code>SEL</code>确实是表中元素的唯一标识。</p>\n<ul>\n<li><code>cache</code>散列表处理冲突</li>\n</ul>\n<p>散列表都会存在的一个问题是：<strong>不同的唯一标识经过散列算法后可能得到相同的<code>index</code>，</strong>那这样数据存取就可能出现冲突，怎么处理呢？</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里只是读取方法的源码，存储方法也是一样的道理</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bucket_t</span> * <span class=\"title\">cache_t::find</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先通过散列算法得到某个元素的index</span></span><br><span class=\"line\">    <span class=\"type\">mask_t</span> begin = <span class=\"built_in\">cache_hash</span>(sel, _mask);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">mask_t</span> i = begin;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_buckets[i].<span class=\"built_in\">sel</span>() == sel) &#123; <span class=\"comment\">// 然后去读取该index处的元素，如果发现该元素的唯一标识SEL和我们想要读取元素的SEL一样，就表明读对了，直接返回该元素</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &amp;_buckets[I];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((i = <span class=\"built_in\">cache_next</span>(i, _mask)) != begin);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">mask_t</span> <span class=\"title\">cache_next</span><span class=\"params\">(<span class=\"type\">mask_t</span> i, <span class=\"type\">mask_t</span> mask)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 否则（index-1），遍历散列表，直到读取到想要的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i ? i<span class=\"number\">-1</span> : mask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见<code>cache</code>散列表处理冲突的方式为：<strong>index-1，然后遍历散列表，</strong>直到找到空闲的内存来存储方法，或者直到找到我们真正想读取的方法。</p>\n<ul>\n<li><code>cache</code>散列表存取数据</li>\n</ul>\n<p>通过散列算法得到<code>index</code>之后，系统就会把这个方法直接存储到散列表相应的<code>index</code>处，因此这就可能造成内存的空闲。</p>\n<p>而读取方法的时候也是先通过散列算法得到<code>index</code>，直接从相应的<code>index</code>处拿出方法，因此就不用遍历了，大大提高了方法查找的效率。</p>\n<ul>\n<li><code>cache</code>散列表扩容</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cache_t::expand</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> oldCapacity = <span class=\"built_in\">capacity</span>();</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> newCapacity = oldCapacity * <span class=\"number\">2</span>; <span class=\"comment\">// 两倍扩容</span></span><br><span class=\"line\">    <span class=\"comment\">// 开辟新的散列表</span></span><br><span class=\"line\">    <span class=\"type\">bucket_t</span> *newBuckets = <span class=\"built_in\">allocateBuckets</span>(newCapacity);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 释放旧的散列表，清空所有的方法缓存</span></span><br><span class=\"line\">    <span class=\"type\">bucket_t</span> *oldBuckets = <span class=\"built_in\">buckets</span>();</span><br><span class=\"line\">    <span class=\"built_in\">cache_collect_free</span>(oldBuckets);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>随着散列表缓存的方法越来越多，它的内存可能就不够用了，此时系统会对散列表进行两倍扩容，创建一个新的散列表，释放旧的散列表并清空所有的方法缓存。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220713203040874.png\" alt=\"img\"></p>\n<blockquote>\n<p>一、对象、类、元类的<code>isa</code>指针和<code>superClass</code>指针指向讲解</p>\n<p>二、类、元类的<code>methods</code>成员变量详解</p>\n<p>三、类、元类的<code>cache</code>成员变量详解</p>\n</blockquote>","more":"<h3 id=\"一、对象、类、元类的isa指针和superClass指针指向讲解\"><a href=\"#一、对象、类、元类的isa指针和superClass指针指向讲解\" class=\"headerlink\" title=\"一、对象、类、元类的isa指针和superClass指针指向讲解\"></a>一、对象、类、元类的<code>isa</code>指针和<code>superClass</code>指针指向讲解</h3><p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/937.png\" alt=\"img\"></p>\n<p><code>isa</code>指针和<code>superclass</code>指针是两个非常重要的指针，弄清它俩的指向有助于我们理解很多东西。</p>\n<p>概括地说：**<code>isa</code>指针指向它所属的类，<code>superclass</code>指针指向它的父类。**</p>\n<p>具体地说：</p>\n<ul>\n<li><strong>实例对象的<code>isa</code>指针指向它所属的类，类的<code>isa</code>指针指向它的元类，元类的<code>isa</code>指针指向基类的元类，基类的元类的<code>isa</code>指针指向它自己。</strong>（<code>isa</code>指针体系中基类的元类是终结）</li>\n<li><strong>子类的<code>superclass</code>指针指向它的父类，这样一层一层往上直到基类，基类的<code>superclass</code>指针为<code>nil</code>；子元类的<code>superclass</code>指针指向父元类，这样一层一层往上直到基类的元类，基类的元类的<code>superclass</code>指针指向基类。</strong>（<code>superclass</code>指针体系中<code>nil</code>是终结）</li>\n</ul>\n<h3 id=\"二、类、元类的methonds成员变量详解\"><a href=\"#二、类、元类的methonds成员变量详解\" class=\"headerlink\" title=\"二、类、元类的methonds成员变量详解\"></a>二、类、元类的<code>methonds</code>成员变量详解</h3><p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220714114122326.png\" alt=\"img\"></p>\n<p>我们知道了类的<code>methods</code>成员变量存储着该类所有的实例方法信息，那它到底是怎么存储的？类的<code>methods</code>成员变量其实是一个数组指针，也就是说<code>methods</code>成员变量里存储着一个地址，只占了8个字节，指向一个数组。而这个数组又是一个指针数组，这个数组的大小要看这个类有几个分类，假设有N个分类，那么它就占了(N + 1) * 8个字节，也就是说这个数组里存储着一堆地址，分别指向真正的实例方法列表，这些实例方法列表包括分类2的实例方法列表、分类1的实例方法列表、类本身的实例方法列表等等，方法列表里才存放着一个一个的实例方法<code>method_t</code>，一个<code>method_t</code>结构体里有3个指针，所以它占用了24个字节，这些内存都是在静态全局区的，它们的大小其实占不了多少，一个App真正占用内存的是我们用这些类<code>alloc init</code>出来的一个个对象，还有图片资源。元类的<code>methods</code>成员变量也是一样的存储方式，只不过里面存储的是该类所有的类方法信息。</p>\n<p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到方法的定义如下（伪代码）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">method_t</span> &#123;</span><br><span class=\"line\">    SEL name;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span> *types;</span><br><span class=\"line\">    IMP imp;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> <span class=\"title class_\">method_t</span> *Method; <span class=\"comment\">// Method类型的本质就是一个method_t类型的结构体指针，所以它可以指向任意一个OC方法</span></span><br></pre></td></tr></table></figure>\n\n<p>可见方法的本质就是一个<code>method_t</code>类型的结构体，该结构体内部有三个成员变量：</p>\n<ul>\n<li><p><code>SEL</code>：<strong>方法选择器，跟方法名一一对应，是一个方法的唯一标识，我们直接把它当作方法名来看待就行</strong>，可以通过<code>@selector(方法名)</code>、<code>NSSelectorFromString(@&quot;方法名的OC字符串&quot;)</code>、<code>sel_registerName(&quot;方法名的C字符串&quot;)</code>来获取方法选择器；</p>\n</li>\n<li><p><code>types</code>：<strong>类型编码字符串，包含了方法的参数和返回值信息</strong>，这里是<a href=\"https://links.jianshu.com/go?to=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html\">类型编码对照表</a>，类型编码中第一个字母代表该方法的返回值类型，后面的字母依次代表该方法的各个参数类型；第一个数字代表该方法所有参数占用内存的总大小，后面的数字依次代表该方法各个参数的内存地址距离内存首地址的偏移量；</p>\n</li>\n<li><p><code>IMP</code>：<strong>函数指针，存储着一个地址，只想该方法在代码区的具体实现。</strong></p>\n</li>\n</ul>\n<h3 id=\"三、类、元类的cache成员变量详解\"><a href=\"#三、类、元类的cache成员变量详解\" class=\"headerlink\" title=\"三、类、元类的cache成员变量详解\"></a>三、类、元类的<code>cache</code>成员变量详解</h3><p>我们知道一个对象接收到消息，会根据它的<code>isa</code>指针找到他所属的类，然后根据类的<code>methods</code>成员变量找到所有的方法列表，然后依次<strong>遍历</strong>这些方法列表来查找要执行的方法。但实际情况中，一个对象只有一部分方法是常用的，其他的方法很少用到或根本用不到，那如果对象每接收一个消息就要遍历一次所有的方法列表，性能肯定会很差。<strong>类的<code>cache</code>成员变量就是用来解决问题的，对象每调用一个方法，系统就会把这个方法存储到<code>cache</code>中，下次对象调用方法时就会优先去<code>cache</code>中查找，如果找到方法则直接调用，如果找不到才去<code>methods</code>哪里找，这就大大提高了查找效率。而且<code>cache</code>还不是简单地存取方法，它用了散列表，这就使得方法查找的效率更高。</strong></p>\n<p>通过查看Runtime的源码（<code>objc-runtime-new.h</code>文件），我们得到<code>cache</code>的定义如下（伪代码）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">cache_t</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">bucket_t</span> *_buckets;</span><br><span class=\"line\">    <span class=\"type\">mask_t</span> _mask;</span><br><span class=\"line\">    <span class=\"type\">mask_t</span> _occupied;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">bucket_t</span> &#123;</span><br><span class=\"line\">    SEL _sel;</span><br><span class=\"line\">    IMP _imp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见<code>cache</code>的本质就是一个<code>cache_t</code>类型的结构体，该结构体内部有三个成员变量：</p>\n<ul>\n<li><strong><code>_buckets</code>：方法缓存散列表；</strong></li>\n<li><strong><code>_mask</code>：散列表的长度 - 1；</strong></li>\n<li><strong><code>_occupied</code>：已缓存方法的数量。</strong></li>\n</ul>\n<p>散列表中的元素也不直接是方法——<code>method_t</code>，而是一个叫<code>bucket_t</code>的东西，它是用方法的<code>SEL</code>和<code>IMP</code>组成的结构体。（为方便叙述，下文中“方法”即指<code>bucket_t</code>）</p>\n<blockquote>\n<p>关键词：散列表、表中元素、表中元素唯一标识、散列算法和散列函数、<code>index</code></p>\n<p>散列表（Hash Table，也叫哈希表），就是<strong>把表中元素的唯一标识通过某种算法得到一个<code>index</code>，然后通过这个<code>index</code>直接访问表中元素的一种数据结构，</strong>这样就不用遍历了，因此<strong>可以大大提高数据查找的效率。</strong>实现这个算法的函数叫作散列函数，存储数据的数组叫作散列表（但这个数组不是普通的数组，它的元素可以不连续存储，因此散列表就有可能造成内存的空闲，它是一个<strong>典型的“以空间换时间”</strong>的例子）。<strong>散列表的核心就在于散列算法。</strong></p>\n</blockquote>\n<p>接下来我们就看看苹果是如何实现<code>cache</code>散列表的。</p>\n<ul>\n<li><code>cache</code>散列表的散列算法：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> <span class=\"title\">cache_hash</span><span class=\"params\">(SEL sel, <span class=\"type\">mask_t</span> mask)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)(<span class=\"type\">unsigned</span> <span class=\"type\">long</span>)sel &amp; mask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见苹果关于<code>cache</code>散列表的散列算法其实很简单，就是：<strong>用方法的<code>SEL</code> &amp; （散列表的长度 - 1）</strong>，这样就能得到一个<code>index</code>了，我们知道方法的<code>SEL</code>确实是表中元素的唯一标识。</p>\n<ul>\n<li><code>cache</code>散列表处理冲突</li>\n</ul>\n<p>散列表都会存在的一个问题是：<strong>不同的唯一标识经过散列算法后可能得到相同的<code>index</code>，</strong>那这样数据存取就可能出现冲突，怎么处理呢？</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里只是读取方法的源码，存储方法也是一样的道理</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bucket_t</span> * <span class=\"title\">cache_t::find</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 先通过散列算法得到某个元素的index</span></span><br><span class=\"line\">    <span class=\"type\">mask_t</span> begin = <span class=\"built_in\">cache_hash</span>(sel, _mask);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">mask_t</span> i = begin;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (_buckets[i].<span class=\"built_in\">sel</span>() == sel) &#123; <span class=\"comment\">// 然后去读取该index处的元素，如果发现该元素的唯一标识SEL和我们想要读取元素的SEL一样，就表明读对了，直接返回该元素</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> &amp;_buckets[I];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ((i = <span class=\"built_in\">cache_next</span>(i, _mask)) != begin);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">mask_t</span> <span class=\"title\">cache_next</span><span class=\"params\">(<span class=\"type\">mask_t</span> i, <span class=\"type\">mask_t</span> mask)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 否则（index-1），遍历散列表，直到读取到想要的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i ? i<span class=\"number\">-1</span> : mask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见<code>cache</code>散列表处理冲突的方式为：<strong>index-1，然后遍历散列表，</strong>直到找到空闲的内存来存储方法，或者直到找到我们真正想读取的方法。</p>\n<ul>\n<li><code>cache</code>散列表存取数据</li>\n</ul>\n<p>通过散列算法得到<code>index</code>之后，系统就会把这个方法直接存储到散列表相应的<code>index</code>处，因此这就可能造成内存的空闲。</p>\n<p>而读取方法的时候也是先通过散列算法得到<code>index</code>，直接从相应的<code>index</code>处拿出方法，因此就不用遍历了，大大提高了方法查找的效率。</p>\n<ul>\n<li><code>cache</code>散列表扩容</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">cache_t::expand</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> oldCapacity = <span class=\"built_in\">capacity</span>();</span><br><span class=\"line\">    <span class=\"type\">uint32_t</span> newCapacity = oldCapacity * <span class=\"number\">2</span>; <span class=\"comment\">// 两倍扩容</span></span><br><span class=\"line\">    <span class=\"comment\">// 开辟新的散列表</span></span><br><span class=\"line\">    <span class=\"type\">bucket_t</span> *newBuckets = <span class=\"built_in\">allocateBuckets</span>(newCapacity);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 释放旧的散列表，清空所有的方法缓存</span></span><br><span class=\"line\">    <span class=\"type\">bucket_t</span> *oldBuckets = <span class=\"built_in\">buckets</span>();</span><br><span class=\"line\">    <span class=\"built_in\">cache_collect_free</span>(oldBuckets);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>随着散列表缓存的方法越来越多，它的内存可能就不够用了，此时系统会对散列表进行两倍扩容，创建一个新的散列表，释放旧的散列表并清空所有的方法缓存。</p>"},{"title":"【Runtime】实际应用","date":"2021-07-17T02:31:53.000Z","_content":"\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200.png)\n\n<!--more-->\n\n> 一、利用关联对象给分类添加完整属性\n>\n> ​\t1、分类能添加属性，但不能添加成员变量\n>\n> ​\t2、虽然能添加属性，但添加的是不完整的属性\n>\n> ​\t3、利用关联对象给分类添加完整的属性\n>\n> ​\t4、关联对象的本质\n>\n> 二、获取一个类所有的成员变量。实现一键归档解裆\n>\n> 三、使用`Method Swizzling`\n>\n> ​\t1、防止button的暴力点击\n>\n> ​\t2、刷新`TableView`、`CollectionView`时，自动判断是否该显示暂无数据。\n\n### 一、利用关联对象给分类添加完整属性\n\n#### 1、分类里能添加属性，但不能添加成员变量\n\n举例来验证下：\n\n假设有一个`INEPerson`类，并且为它创建了一个分类`INEEat`。\n\n- 当我们在分类里添加属性时，编译器仅仅报警告说“`name`属性需要`name`方法和`setName:`方法的实现”，并建议我们“用`@dynamic`告诉编译器运行时才添加，或者直接在分类里添加这两个方法的实现”，编译能通过就证明：**分类里能添加属性。**\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103622988.png)\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103636300.png)\n\n- 而当我们在分类里添加成员变量时，编译器直接报错说“成员变量不应该放在分类里”，编译报错就证明：**分类里不能添加成员变量。**\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103750853.png)\n\n**那为什么分类里能添加属性，但不能添加成员变量呢？首先我们知道类的成员变量列表是只读的（类的本质、`class_ro_t`、`ivars`那儿还记得吧），所以它在编译后就不能被修改了。其次分类的内部有相应的成员变量来存储该分类为类扩展的方法、属性和协议，但没有特定的成员变量用来存储分类为类扩展的成员变量（分类的本质那儿还记得吧），因此分类能为类扩展属性，但不能为类扩展成员变量。**\n\n#### 2、虽然能添加属性，但添加的是不完整的属性\n\n我们都知道，给类添加一个属性，系统其实做了三件事：\n\n> - 生成对应的成员变量\n> - 生成对应`setter`、`getter`方法的声明\n> - 生成对应`setter`、`getter`方法的实现\n>\n> 我们称这为完整的属性\n\n举例来验证下：\n\n接着第1小节的例子，我们仅仅在`INEEat`分类里为`INEPerson`类添加了一个`name`属性，现在打印一下`INEPerson`类的实例方法列表、属性列表和成员变量列表。\n\n```objectivec\n-----------ViewController.m-----------\n\n#import <objc/runtime.h>\n#import \"INEPerson.h\"\n\n- (NSArray *)methodsOfClass:(Class)cls {\n    \n    NSMutableArray *methods = [@[] mutableCopy];\n    \n    unsigned int count;\n    Method *methodList = class_copyMethodList(cls, &count);\n    for (NSInteger i = 0; i < count; i ++) {\n        \n        Method method = methodList[I];\n        NSString *methodName = NSStringFromSelector(method_getName(method));\n        \n        [methods addObject:methodName];\n    }\n    free(methodList);\n    \n    return methods;\n}\n\n- (NSArray *)propsOfClass:(Class)cls {\n    \n    NSMutableArray *props = [@[] mutableCopy];\n    \n    unsigned int count;\n    objc_property_t *propList = class_copyPropertyList(cls, &count);\n    for (NSInteger i = 0; i < count; i ++) {\n        \n        objc_property_t property = propList[I];\n        NSString *propName = [NSString stringWithUTF8String:property_getName(property)];\n        \n        [props addObject:propName];\n    }\n    free(propList);\n    \n    return props;\n}\n\n- (NSArray *)ivarsOfClass:(Class)cls {\n    \n    NSMutableArray *ivars = [@[] mutableCopy];\n    \n    unsigned int count;\n    Ivar *ivarList = class_copyIvarList(cls, &count);\n    for (int i = 0; i < count; i ++) {\n        \n        Ivar ivar = ivarList[I];\n        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];\n        \n        [ivars addObject:ivarName];\n    }\n    free(ivarList);\n    \n    return ivars;\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"实例方法列表：%@\", [self methodsOfClass:[INEPerson class]]);\n    NSLog(@\"属性列表：%@\", [self propsOfClass:[INEPerson class]]);\n    NSLog(@\"成员变量列表：%@\", [self ivarsOfClass:[INEPerson class]]);\n}\n```\n\n控制台打印如下：\n\n```undefined\n实例方法列表：(\n)\n\n属性列表：(\n    name\n)\n\n成员变量列表：(\n)\n```\n\n可见给分类添加一个属性，确确实实没有生成对应的成员变量，也没有生成对应`setter`、`getter`方法的实现（方法只有被实现了，才会被放入类的`methods`成员变量中）。\n\n此时我们去`INEEat`分类里，尝试自己实现一下`name`属性的`setter`、`getter`方法，发现方法名敲一半它们会自动弹出来，这就证明`name`属性的`setter`、`getter`方法已经被声明了。\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718104234339.png)\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1008.png)\n\n**那为什么分类里能添加属性，但仅仅是生成了对应`setter`、`getter`方法的声明，而不生成它们的实现呢？这主要还是因为分类内部结构里不能存储成员变量，而导致没有生成属性对应的成员变量，进而导致没法生成`setter`、`getter`方法的实现，我们知道`setter`、`getter`方法的内部实现不就是给成员变量赋值、取值嘛。**\n\n#### 3、利用关联对象给分类添加完整的属性\n\n在开发中，我们肯定会遇到往分类里添加属性的需求，但既然系统不会为我们自动生成对应的成员变量和`setter`、`getter`方法的实现，那我们就自己搞成一个完整的属性吧。\n\n自己搞的话，添加一对儿`setter`、`getter`方法倒是很简单，难的地方在于它俩的内部实现应该怎么写，也就是说数据要存储在哪里、又从哪里读取，再进一步就是说我们得想办法找一个类似于成员变量那么个东西来存储数据、并从它里面读取数据，要不然`setter`、`getter`方法里面没法写啊！当然我们可以自己写一个全局的字典来模拟成员变量那样存取数据，不过要做很多额外的考虑（例如数据是否和对象一对一、数据何时应该销毁、多线程条件下数据写入是否安全等），所以就**直接用Runtime给我们提供的关联对象来代替成员变量存储数据吧！关联对象其实就是一个对象，和成员变量的功能差不多，用来帮助我们存储数据和读取数据。**\n\n有了代替成员变量的关联对象，我们就可以顺利地自己实现`setter`、`getter`方法了，用到的是Runtime的API。\n\n```objectivec\n-----------INEPerson+INEEat.m-----------\n\n#import \"INEPerson+INEEat.h\"\n#import <objc/runtime.h>\n\n@implementation INEPerson (INEEat)\n\n- (void)setName:(NSString *)name {\n    \n    // object：被关联对象\n    // key：存储关联对象时对应的key\n    // value：要存储的数据\n    // policy：存储数据的策略\n    objc_setAssociatedObject(self, @\"name\", name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n- (NSString *)name {\n    \n    // object：被关联对象\n    // key：存储关联对象时对应的key\n    return objc_getAssociatedObject(self, @\"name\");\n}\n\n@end\n```\n\n移除关联对象：\n\n```objectivec\n// 移除某个关联对象，把value设置为nil即可\nobjc_setAssociatedObject(self, @\"name\", nil, OBJC_ASSOCIATION_COPY_NONATOMIC);\n\n// 移除所有的关联对象\nobjc_removeAssociatedObjects(id object);\n```\n\n数据存储策略：\n\n|      objc_AssociationPolicy       |    对应修饰符     |\n| :-------------------------------: | :---------------: |\n|      OBJC_ASSOCIATION_ASSIGN      |      assign       |\n| OBJC_ASSOCIATION_RETAIN_NONATOMIC | strong、nonatomic |\n|  OBJC_ASSOCIATION_COPY_NONATOMIC  |  copy、nonatomic  |\n|      OBJC_ASSOCIATION_RETAIN      |  strong、atomic   |\n|       OBJC_ASSOCIATION_COPY       |   copy、atomic    |\n\n#### 4、关联对象的本质\n\n通过查看Runtime的源码（`objc-references.mm`文件），我们得到关联对象的定义如下：（伪代码）\n\n```cpp\n// objc_setAssociatedObject(..., ..., value, policy);\n\nclass ObjcAssociation {\n    uintptr_t _policy;\n    id _value;\n};\n```\n\n可见**关联对象的本质就是一个C++的`ObjcAssociation`对象，它内部存储着我们想要存储的数据和存储数据的策略，即`objc_setAssociatedObject(...)`函数的第三个、第四个参数。**\n\n然后关联对象会跟`objc_setAssociatedObject(...)`函数的第二个参数映射到一个叫`AssociationsMap`的小字典里，这个小字典维护着某个对象所有的关联对象。\n\n```cpp\n// objc_setAssociatedObject(..., key, ..., ...);\n\nAssociationsMap = @{\n                    key: ObjcAssociation,\n                    key: ObjcAssociation,\n                    ...\n                    }\n\n// 例如：\nAssociationsMap = @{\n                    \"name\": name属性对应的关联对象,\n                    \"age\": age属性对应的关联对象,\n                    ...\n                    }\n```\n\n然后`AssociationsMap`的小字典又会跟`objc_setAssociatedObject(...)`函数的第一个参数映射到一个叫`AssociationsHashMap`的大字典里，这个大字典是Runtime维护的一个全局的字典，它维护着整个项目中所有对象的所有关联对象。\n\n```cpp\n// objc_setAssociatedObject(object, ..., ..., ...);\n\nAssociationsHashMap = @{\n                        objcet: AssociationsMap,\n                        objcet: AssociationsMap,\n                        ...\n                        }\n\n// 例如：\nAssociationsHashMap = @{\n                        person1: person1的AssociationsMap,\n                        person2: person2的AssociationsMap,\n                        ...\n                        }\n```\n\n\n\n### 二、获取一个类所有的成员变量。实现一键归档解裆\n\n我们知道把一个复杂对象存储进`NSUserDefaults`的时候，必须先把复杂对象归档为`NSData`再存进去，读取的时候也必须先把`NSData`读出来然后再解裆为复杂对象。\n\n```objectivec\n-----------NSUserDefaults+INESaveComplexObject.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface NSUserDefaults (INESaveComplexObject)\n\n- (void)ine_setComplexObject:(id)value forKey:(NSString *)defaultName;\n- (id)ine_complexObjectForKey:(NSString *)defaultName;\n\n@end\n\n\n-----------NSUserDefaults+INESaveComplexObject.m-----------\n\n#import \"NSUserDefaults+INESaveComplexObject.h\"\n\n@implementation NSUserDefaults (INESaveComplexObject)\n\n- (void)ine_setComplexObject:(id)value forKey:(NSString *)defaultName {\n    \n    NSData *writeData = [NSKeyedArchiver archivedDataWithRootObject:value];\n    [[NSUserDefaults standardUserDefaults] setObject:writeData forKey:defaultName];\n}\n\n- (id)ine_complexObjectForKey:(NSString *)defaultName {\n    \n    NSData *readData = [[NSUserDefaults standardUserDefaults] objectForKey:defaultName];\n    return [NSKeyedUnarchiver unarchiveObjectWithData:readData];\n}\n\n@end\n```\n\n而对象在归档解裆时又必须遵循`NSCoding`协议，并实现协议里的`encodeWithCoder:`、`initWithCoder:`方法，我们总不能把项目里所有的对象的所有的成员变量都这么写一遍吧，那样工作量太大了，并且这种重复的工作似乎没太大意义，于是可以考虑使用Runtime来做。给`NSObject`添加一个分类，让它遵循`NSCoding`协议，并且实现协议里的`encodeWithCoder:`、`initWithCoder:`方法，我们调用Runtime得API遍历一个类所有的成员变量，实现一键归解档。\n\n\n\n### 三、使用`Method Swizzling`\n\n使用`Method Swizzling`需要注意以下几点：\n\n- **方法交互操作一定要写在`+load`方法里，而不能写在`+initialize`方法里。**因为`+load`方法是在类和分类加载到内存的时候调用的，不管代码里使用或者不使用这个类的分类都会被调用，而`+initialize`则是类被初始化的时候调用的，项目里没有用到这个类就不会被调用，所以要写在`+load`方法确保方法交换成功。\n- **方法交换操作一定要写在`dispatch_once`里。**算然说`+load`方法本身只会执行一次，但是并不能确保其他人不会再某些地方主动再调用一次`+load`方法，这就可能导致又把两个方法的实现给交换回去了。\n- **在我们自己写的方法里，要判断一下触发了该方法的类是不是当前类，以免把类簇里的子类方法也替换掉。**（例如下面的`UIButton`和`UITableView`就有类簇，OC中大量使用了类簇，我们常用的`NSString`、`NSArray`、`NSDictionary`等都采用类簇的形式实现）\n\n- **在我们自己写的方法里，记得要调用一些方法的原生实现**（除非你非常确定不需要调用方法的原生实现），因为不调用一下的话，就可能因为丢掉方法的原生实现而导致不可预知的bug。\n\n#### 1、防止button的暴力点击\n\n我们知道所有继承自`UIControl`的类，在处理事件时都会首先调用`sendAction:to:forEvent:`方法，我们可以交换它的实现来防止`Button`的暴力点击。\n\n```objectivec\n#import \"UIButton+INEPreventViolentClick.h\"\n#import <objc/runtime.h>\n\n#define kTimeInterval 0.5 // 被认定为暴力点击的时间间隔\n\n@interface UIButton ()\n\n@property (nonatomic, assign) NSTimeInterval ine_lastTimeClickTimestamp; // 上一次点击的时间戳\n\n@end\n\n@implementation UIButton (INEPreventViolentClick)\n\n+ (void)load {\n    \n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        \n        SEL originalSelector = @selector(sendAction:to:forEvent:);\n        SEL swizzledSelector = @selector(ine_sendAction:to:forEvent:);\n        \n        Method originalMethod = class_getInstanceMethod(self, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector);\n        \n        IMP originalIMP = method_getImplementation(originalMethod);\n        IMP swizzleIMP = method_getImplementation(swizzledMethod);\n        \n        const char *originalTypeEncoding = method_getTypeEncoding(originalMethod);\n        const char *swizzledTypeEncoding = method_getTypeEncoding(swizzledMethod);\n        \n        BOOL didAddMethod = class_addMethod(self, originalSelector, swizzleIMP, swizzledTypeEncoding);\n        \n        if (didAddMethod) {\n            \n            class_replaceMethod(self, swizzledSelector, originalIMP, originalTypeEncoding);\n        } else {\n            \n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)ine_sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event  {\n    \n    if ([[self class] isEqual:[UIButton class]]) { // 以免把UIButton类簇里子类的方法也交换掉\n        \n        // 获取此次点击的时间戳\n        NSTimeInterval currentTimeClickTimestamp = [[NSDate date] timeIntervalSince1970];\n        \n        if (currentTimeClickTimestamp - self.ine_lastTimeClickTimestamp < kTwoTimeClickTimeInterval) { // 如果此次点击和上一次点击的时间间隔小于我们设定的时间间隔，则判定此次点击为暴力点击，什么都不做\n            \n            return;\n        } else { // 否则我们判定此次点击为正常点击，button正常处理事件\n            \n            // 记录上次点击的时间戳\n            self.ine_lastTimeClickTimestamp = currentTimeClickTimestamp;\n            \n            [self ine_sendAction:action to:target forEvent:event];\n        }\n    } else {\n        \n        [self ine_sendAction:action to:target forEvent:event];\n    }\n}\n\n- (void)setine_lastTimeClickTimestamp:(NSTimeInterval)ine_lastTimeClickTimestamp {\n    \n    objc_setAssociatedObject(self, @\"ine_lastTimeClickTimestamp\", @(ine_lastTimeClickTimestamp), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (NSTimeInterval)ine_lastTimeClickTimestamp {\n    \n    return [objc_getAssociatedObject(self, @\"ine_lastTimeClickTimestamp\") doubleValue];\n}\n\n@end\n```\n\n#### 2、刷新`TableView`、`CollectionView`时，自动判断是否该显示暂无数据\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103053060.png)\n\n```objectivec\n// UITableView+PromptImage.h\n#import <UIKit/UIKit.h>\n\n@interface UITableView (INEPromptImage)\n\n/// 提示图的名字\n@property (nonatomic, copy) NSString *ine_promptImageName;\n/// 提示文本\n@property (nonatomic, copy) NSString *ine_promptText;\n\n/// 点击提示图的回调\n@property (nonatomic, copy) void(^ine_didTapPromptImage)(void);\n\n/// 不使用该分类里的这套判定规则\n@property (nonatomic, assign) BOOL ine_dontUseThisCategory;\n\n@end\n\n\n// UITableView+PromptImage.m\n#import \"UITableView+INEPromptImage.h\"\n#import <objc/runtime.h>\n\n@interface UITableView ()\n\n// 已经调用过reloadData方法了\n@property (nonatomic, assign) BOOL ine_hasInvokedReloadData;\n\n// 提示图\n@property (nonatomic, strong) UIButton *ine_promptImageView;\n\n@end\n\n@implementation UITableView (INEPromptImage)\n\n+ (void)load {\n    \n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        \n        [self methodSwizzlingWithOriginalSelector:@selector(reloadData) swizzledSelector:@selector(ine_reloadData)];\n    });\n}\n\n- (void)ine_reloadData {\n    \n    if ([[self class] isEqual:[UITableView class]] && !self.ine_dontUseThisCategory) {// 防止替换掉UITableView类簇里子类方法的实现\n        \n        [self ine_reloadData];\n        \n        if (self.ine_hasInvokedReloadData) {// 而是只在请求数据完成后，调用reloadData刷新界面时才处理提示图的显隐\n            \n            [self ine_handlePromptImage];\n        } else {// tableView第一次加载的时候会自动调用一下reloadData方法，这一次调用我们不处理提示图的显隐\n            \n            self.ine_hasInvokedReloadData = YES;\n        }\n    } else {\n        \n        [self ine_reloadData];\n    }\n}\n\n\n#pragma mark - private method\n\n// 提示图的显隐\n- (void)ine_handlePromptImage {\n    \n    if ([self ine_dataIsEmpty]) {\n        \n        [self ine_showPromptImage];\n    }else {\n        \n        [self ine_hidePromptImage];\n    }\n}\n\n// 判断请求到的数据是否为空\n- (BOOL)ine_dataIsEmpty {\n    \n    // 获取分区数\n    NSInteger sections = 0;\n    if ([self.dataSource respondsToSelector:@selector(numberOfSectionsInTableView:)]) {// 如果外界实现了该方法，则读取外界提供的分区数\n        \n        sections = [self numberOfSections];\n    } else {// 如果外界没实现该方法，系统不是会自动给我们返回一个分区嘛\n        \n        sections = 1;\n    }\n    \n    if (sections == 0) {// 分区数为0，说明数据为空\n        \n        return YES;\n    }\n    \n    \n    // 分区数不为0，则需要判断每个分区下的行数\n    for (int i = 0; i < sections; i ++) {\n        \n        // 获取各个分区的行数\n        NSInteger rows = [self numberOfRowsInSection:i];\n        \n        if (rows != 0) {// 但凡有一个分区下的行数不为0，说明数据不为空\n            \n            return NO;\n        }\n    }\n    \n    \n    // 如果所有分区下的行数都为0，才说明数据为空\n    return YES;\n}\n\n// 显示提示图\n- (void)ine_showPromptImage {\n    \n    if (self.ine_promptImageView == nil) {\n        \n        self.ine_promptImageView = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 60, 90)];\n        self.ine_promptImageView.backgroundColor = [UIColor clearColor];\n        self.ine_promptImageView.contentMode = UIViewContentModeCenter;\n        self.ine_promptImageView.userInteractionEnabled = YES;\n        self.ine_promptImageView.adjustsImageWhenHighlighted = NO;\n        \n        \n        [self.ine_promptImageView setTitleColor:Color_With_RGB(170, 170, 170, 1) forState:(UIControlStateNormal)];\n        self.ine_promptImageView.titleLabel.font = [UIFont systemFontOfSize:12];\n        \n        if (String_Is_Empty(self.ine_promptText)) {\n            \n            self.ine_promptText = @\"暂无数据\";\n        }\n        [self.ine_promptImageView setTitle:self.ine_promptText forState:(UIControlStateNormal)];\n        \n        if (self.ine_promptImageName.length == 0) {\n            \n            self.ine_promptImageName = @\"BaseProject_NoDataPromptImage\";\n        }\n        [self.ine_promptImageView setImage:[UIImage imageNamed:self.ine_promptImageName] forState:(UIControlStateNormal)];\n        [self.ine_promptImageView layoutImageAndTitle:(ImageAndTitleLayoutStyleImageOnLabel) imageTitleSpace:5];\n        \n        UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(ine_didTapPromptImage:)];\n        [self.ine_promptImageView addGestureRecognizer:tapGestureRecognizer];\n    }\n    \n    self.backgroundView = self.ine_promptImageView;\n}\n\n// 隐藏提示图\n- (void)ine_hidePromptImage {\n    \n    self.backgroundView = nil;\n}\n\n// 点击提示图的回调\n- (void)ine_didTapPromptImage:(UITapGestureRecognizer *)tapGestureRecognizer {\n    \n    if (self.ine_didTapPromptImage) {\n        \n        self.ine_didTapPromptImage();\n    }\n}\n\n\n#pragma mark - setter, getter\n\n- (void)setine_hasInvokedReloadData:(BOOL)ine_hasInvokedReloadData {\n    \n    objc_setAssociatedObject(self, @\"ine_hasInvokedReloadData\", @(ine_hasInvokedReloadData), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (BOOL)ine_hasInvokedReloadData {\n    \n    return [objc_getAssociatedObject(self, @\"ine_hasInvokedReloadData\") boolValue];\n}\n\n- (void)setine_promptImageView:(UIImageView *)ine_promptImageView {\n    \n    objc_setAssociatedObject(self, @\"ine_promptImageView\", ine_promptImageView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (UIImageView *)ine_promptImageView {\n    \n    return objc_getAssociatedObject(self, @\"ine_promptImageView\");\n}\n\n- (void)setine_promptText:(NSString *)ine_promptText {\n    \n    objc_setAssociatedObject(self, @\"ine_promptText\", ine_promptText, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (NSString *)ine_promptText {\n    \n    return objc_getAssociatedObject(self, @\"ine_promptText\");\n}\n\n- (void)setine_promptImageName:(NSString *)ine_promptImageName {\n    \n    objc_setAssociatedObject(self, @\"ine_promptImageName\", ine_promptImageName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (NSString *)ine_promptImageName {\n    \n    return objc_getAssociatedObject(self, @\"ine_promptImageName\");\n}\n\n- (void)setine_didTapPromptImage:(void (^)(void))ine_didTapPromptImage {\n    \n    objc_setAssociatedObject(self, @\"ine_didTapPromptImage\", ine_didTapPromptImage, OBJC_ASSOCIATION_COPY);\n}\n\n- (void (^)(void))ine_didTapPromptImage {\n    \n    return objc_getAssociatedObject(self, @\"ine_didTapPromptImage\");\n}\n\n- (void)setine_dontUseThisCategory:(BOOL)ine_dontUseThisCategory {\n    \n    objc_setAssociatedObject(self, @\"ine_dontUseThisCategory\", @(ine_dontUseThisCategory), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (BOOL)ine_dontUseThisCategory {\n    \n    return [objc_getAssociatedObject(self, @\"ine_dontUseThisCategory\") boolValue];\n}\n\n@end\n```\n\n","source":"_posts/Runtime实际应用.md","raw":"---\ntitle: 【Runtime】实际应用\ndate: 2021-07-17 10:31:53\ntags: Runtime系列\n---\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200.png)\n\n<!--more-->\n\n> 一、利用关联对象给分类添加完整属性\n>\n> ​\t1、分类能添加属性，但不能添加成员变量\n>\n> ​\t2、虽然能添加属性，但添加的是不完整的属性\n>\n> ​\t3、利用关联对象给分类添加完整的属性\n>\n> ​\t4、关联对象的本质\n>\n> 二、获取一个类所有的成员变量。实现一键归档解裆\n>\n> 三、使用`Method Swizzling`\n>\n> ​\t1、防止button的暴力点击\n>\n> ​\t2、刷新`TableView`、`CollectionView`时，自动判断是否该显示暂无数据。\n\n### 一、利用关联对象给分类添加完整属性\n\n#### 1、分类里能添加属性，但不能添加成员变量\n\n举例来验证下：\n\n假设有一个`INEPerson`类，并且为它创建了一个分类`INEEat`。\n\n- 当我们在分类里添加属性时，编译器仅仅报警告说“`name`属性需要`name`方法和`setName:`方法的实现”，并建议我们“用`@dynamic`告诉编译器运行时才添加，或者直接在分类里添加这两个方法的实现”，编译能通过就证明：**分类里能添加属性。**\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103622988.png)\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103636300.png)\n\n- 而当我们在分类里添加成员变量时，编译器直接报错说“成员变量不应该放在分类里”，编译报错就证明：**分类里不能添加成员变量。**\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103750853.png)\n\n**那为什么分类里能添加属性，但不能添加成员变量呢？首先我们知道类的成员变量列表是只读的（类的本质、`class_ro_t`、`ivars`那儿还记得吧），所以它在编译后就不能被修改了。其次分类的内部有相应的成员变量来存储该分类为类扩展的方法、属性和协议，但没有特定的成员变量用来存储分类为类扩展的成员变量（分类的本质那儿还记得吧），因此分类能为类扩展属性，但不能为类扩展成员变量。**\n\n#### 2、虽然能添加属性，但添加的是不完整的属性\n\n我们都知道，给类添加一个属性，系统其实做了三件事：\n\n> - 生成对应的成员变量\n> - 生成对应`setter`、`getter`方法的声明\n> - 生成对应`setter`、`getter`方法的实现\n>\n> 我们称这为完整的属性\n\n举例来验证下：\n\n接着第1小节的例子，我们仅仅在`INEEat`分类里为`INEPerson`类添加了一个`name`属性，现在打印一下`INEPerson`类的实例方法列表、属性列表和成员变量列表。\n\n```objectivec\n-----------ViewController.m-----------\n\n#import <objc/runtime.h>\n#import \"INEPerson.h\"\n\n- (NSArray *)methodsOfClass:(Class)cls {\n    \n    NSMutableArray *methods = [@[] mutableCopy];\n    \n    unsigned int count;\n    Method *methodList = class_copyMethodList(cls, &count);\n    for (NSInteger i = 0; i < count; i ++) {\n        \n        Method method = methodList[I];\n        NSString *methodName = NSStringFromSelector(method_getName(method));\n        \n        [methods addObject:methodName];\n    }\n    free(methodList);\n    \n    return methods;\n}\n\n- (NSArray *)propsOfClass:(Class)cls {\n    \n    NSMutableArray *props = [@[] mutableCopy];\n    \n    unsigned int count;\n    objc_property_t *propList = class_copyPropertyList(cls, &count);\n    for (NSInteger i = 0; i < count; i ++) {\n        \n        objc_property_t property = propList[I];\n        NSString *propName = [NSString stringWithUTF8String:property_getName(property)];\n        \n        [props addObject:propName];\n    }\n    free(propList);\n    \n    return props;\n}\n\n- (NSArray *)ivarsOfClass:(Class)cls {\n    \n    NSMutableArray *ivars = [@[] mutableCopy];\n    \n    unsigned int count;\n    Ivar *ivarList = class_copyIvarList(cls, &count);\n    for (int i = 0; i < count; i ++) {\n        \n        Ivar ivar = ivarList[I];\n        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];\n        \n        [ivars addObject:ivarName];\n    }\n    free(ivarList);\n    \n    return ivars;\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSLog(@\"实例方法列表：%@\", [self methodsOfClass:[INEPerson class]]);\n    NSLog(@\"属性列表：%@\", [self propsOfClass:[INEPerson class]]);\n    NSLog(@\"成员变量列表：%@\", [self ivarsOfClass:[INEPerson class]]);\n}\n```\n\n控制台打印如下：\n\n```undefined\n实例方法列表：(\n)\n\n属性列表：(\n    name\n)\n\n成员变量列表：(\n)\n```\n\n可见给分类添加一个属性，确确实实没有生成对应的成员变量，也没有生成对应`setter`、`getter`方法的实现（方法只有被实现了，才会被放入类的`methods`成员变量中）。\n\n此时我们去`INEEat`分类里，尝试自己实现一下`name`属性的`setter`、`getter`方法，发现方法名敲一半它们会自动弹出来，这就证明`name`属性的`setter`、`getter`方法已经被声明了。\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718104234339.png)\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1008.png)\n\n**那为什么分类里能添加属性，但仅仅是生成了对应`setter`、`getter`方法的声明，而不生成它们的实现呢？这主要还是因为分类内部结构里不能存储成员变量，而导致没有生成属性对应的成员变量，进而导致没法生成`setter`、`getter`方法的实现，我们知道`setter`、`getter`方法的内部实现不就是给成员变量赋值、取值嘛。**\n\n#### 3、利用关联对象给分类添加完整的属性\n\n在开发中，我们肯定会遇到往分类里添加属性的需求，但既然系统不会为我们自动生成对应的成员变量和`setter`、`getter`方法的实现，那我们就自己搞成一个完整的属性吧。\n\n自己搞的话，添加一对儿`setter`、`getter`方法倒是很简单，难的地方在于它俩的内部实现应该怎么写，也就是说数据要存储在哪里、又从哪里读取，再进一步就是说我们得想办法找一个类似于成员变量那么个东西来存储数据、并从它里面读取数据，要不然`setter`、`getter`方法里面没法写啊！当然我们可以自己写一个全局的字典来模拟成员变量那样存取数据，不过要做很多额外的考虑（例如数据是否和对象一对一、数据何时应该销毁、多线程条件下数据写入是否安全等），所以就**直接用Runtime给我们提供的关联对象来代替成员变量存储数据吧！关联对象其实就是一个对象，和成员变量的功能差不多，用来帮助我们存储数据和读取数据。**\n\n有了代替成员变量的关联对象，我们就可以顺利地自己实现`setter`、`getter`方法了，用到的是Runtime的API。\n\n```objectivec\n-----------INEPerson+INEEat.m-----------\n\n#import \"INEPerson+INEEat.h\"\n#import <objc/runtime.h>\n\n@implementation INEPerson (INEEat)\n\n- (void)setName:(NSString *)name {\n    \n    // object：被关联对象\n    // key：存储关联对象时对应的key\n    // value：要存储的数据\n    // policy：存储数据的策略\n    objc_setAssociatedObject(self, @\"name\", name, OBJC_ASSOCIATION_COPY_NONATOMIC);\n}\n\n- (NSString *)name {\n    \n    // object：被关联对象\n    // key：存储关联对象时对应的key\n    return objc_getAssociatedObject(self, @\"name\");\n}\n\n@end\n```\n\n移除关联对象：\n\n```objectivec\n// 移除某个关联对象，把value设置为nil即可\nobjc_setAssociatedObject(self, @\"name\", nil, OBJC_ASSOCIATION_COPY_NONATOMIC);\n\n// 移除所有的关联对象\nobjc_removeAssociatedObjects(id object);\n```\n\n数据存储策略：\n\n|      objc_AssociationPolicy       |    对应修饰符     |\n| :-------------------------------: | :---------------: |\n|      OBJC_ASSOCIATION_ASSIGN      |      assign       |\n| OBJC_ASSOCIATION_RETAIN_NONATOMIC | strong、nonatomic |\n|  OBJC_ASSOCIATION_COPY_NONATOMIC  |  copy、nonatomic  |\n|      OBJC_ASSOCIATION_RETAIN      |  strong、atomic   |\n|       OBJC_ASSOCIATION_COPY       |   copy、atomic    |\n\n#### 4、关联对象的本质\n\n通过查看Runtime的源码（`objc-references.mm`文件），我们得到关联对象的定义如下：（伪代码）\n\n```cpp\n// objc_setAssociatedObject(..., ..., value, policy);\n\nclass ObjcAssociation {\n    uintptr_t _policy;\n    id _value;\n};\n```\n\n可见**关联对象的本质就是一个C++的`ObjcAssociation`对象，它内部存储着我们想要存储的数据和存储数据的策略，即`objc_setAssociatedObject(...)`函数的第三个、第四个参数。**\n\n然后关联对象会跟`objc_setAssociatedObject(...)`函数的第二个参数映射到一个叫`AssociationsMap`的小字典里，这个小字典维护着某个对象所有的关联对象。\n\n```cpp\n// objc_setAssociatedObject(..., key, ..., ...);\n\nAssociationsMap = @{\n                    key: ObjcAssociation,\n                    key: ObjcAssociation,\n                    ...\n                    }\n\n// 例如：\nAssociationsMap = @{\n                    \"name\": name属性对应的关联对象,\n                    \"age\": age属性对应的关联对象,\n                    ...\n                    }\n```\n\n然后`AssociationsMap`的小字典又会跟`objc_setAssociatedObject(...)`函数的第一个参数映射到一个叫`AssociationsHashMap`的大字典里，这个大字典是Runtime维护的一个全局的字典，它维护着整个项目中所有对象的所有关联对象。\n\n```cpp\n// objc_setAssociatedObject(object, ..., ..., ...);\n\nAssociationsHashMap = @{\n                        objcet: AssociationsMap,\n                        objcet: AssociationsMap,\n                        ...\n                        }\n\n// 例如：\nAssociationsHashMap = @{\n                        person1: person1的AssociationsMap,\n                        person2: person2的AssociationsMap,\n                        ...\n                        }\n```\n\n\n\n### 二、获取一个类所有的成员变量。实现一键归档解裆\n\n我们知道把一个复杂对象存储进`NSUserDefaults`的时候，必须先把复杂对象归档为`NSData`再存进去，读取的时候也必须先把`NSData`读出来然后再解裆为复杂对象。\n\n```objectivec\n-----------NSUserDefaults+INESaveComplexObject.h-----------\n\n#import <Foundation/Foundation.h>\n\n@interface NSUserDefaults (INESaveComplexObject)\n\n- (void)ine_setComplexObject:(id)value forKey:(NSString *)defaultName;\n- (id)ine_complexObjectForKey:(NSString *)defaultName;\n\n@end\n\n\n-----------NSUserDefaults+INESaveComplexObject.m-----------\n\n#import \"NSUserDefaults+INESaveComplexObject.h\"\n\n@implementation NSUserDefaults (INESaveComplexObject)\n\n- (void)ine_setComplexObject:(id)value forKey:(NSString *)defaultName {\n    \n    NSData *writeData = [NSKeyedArchiver archivedDataWithRootObject:value];\n    [[NSUserDefaults standardUserDefaults] setObject:writeData forKey:defaultName];\n}\n\n- (id)ine_complexObjectForKey:(NSString *)defaultName {\n    \n    NSData *readData = [[NSUserDefaults standardUserDefaults] objectForKey:defaultName];\n    return [NSKeyedUnarchiver unarchiveObjectWithData:readData];\n}\n\n@end\n```\n\n而对象在归档解裆时又必须遵循`NSCoding`协议，并实现协议里的`encodeWithCoder:`、`initWithCoder:`方法，我们总不能把项目里所有的对象的所有的成员变量都这么写一遍吧，那样工作量太大了，并且这种重复的工作似乎没太大意义，于是可以考虑使用Runtime来做。给`NSObject`添加一个分类，让它遵循`NSCoding`协议，并且实现协议里的`encodeWithCoder:`、`initWithCoder:`方法，我们调用Runtime得API遍历一个类所有的成员变量，实现一键归解档。\n\n\n\n### 三、使用`Method Swizzling`\n\n使用`Method Swizzling`需要注意以下几点：\n\n- **方法交互操作一定要写在`+load`方法里，而不能写在`+initialize`方法里。**因为`+load`方法是在类和分类加载到内存的时候调用的，不管代码里使用或者不使用这个类的分类都会被调用，而`+initialize`则是类被初始化的时候调用的，项目里没有用到这个类就不会被调用，所以要写在`+load`方法确保方法交换成功。\n- **方法交换操作一定要写在`dispatch_once`里。**算然说`+load`方法本身只会执行一次，但是并不能确保其他人不会再某些地方主动再调用一次`+load`方法，这就可能导致又把两个方法的实现给交换回去了。\n- **在我们自己写的方法里，要判断一下触发了该方法的类是不是当前类，以免把类簇里的子类方法也替换掉。**（例如下面的`UIButton`和`UITableView`就有类簇，OC中大量使用了类簇，我们常用的`NSString`、`NSArray`、`NSDictionary`等都采用类簇的形式实现）\n\n- **在我们自己写的方法里，记得要调用一些方法的原生实现**（除非你非常确定不需要调用方法的原生实现），因为不调用一下的话，就可能因为丢掉方法的原生实现而导致不可预知的bug。\n\n#### 1、防止button的暴力点击\n\n我们知道所有继承自`UIControl`的类，在处理事件时都会首先调用`sendAction:to:forEvent:`方法，我们可以交换它的实现来防止`Button`的暴力点击。\n\n```objectivec\n#import \"UIButton+INEPreventViolentClick.h\"\n#import <objc/runtime.h>\n\n#define kTimeInterval 0.5 // 被认定为暴力点击的时间间隔\n\n@interface UIButton ()\n\n@property (nonatomic, assign) NSTimeInterval ine_lastTimeClickTimestamp; // 上一次点击的时间戳\n\n@end\n\n@implementation UIButton (INEPreventViolentClick)\n\n+ (void)load {\n    \n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        \n        SEL originalSelector = @selector(sendAction:to:forEvent:);\n        SEL swizzledSelector = @selector(ine_sendAction:to:forEvent:);\n        \n        Method originalMethod = class_getInstanceMethod(self, originalSelector);\n        Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector);\n        \n        IMP originalIMP = method_getImplementation(originalMethod);\n        IMP swizzleIMP = method_getImplementation(swizzledMethod);\n        \n        const char *originalTypeEncoding = method_getTypeEncoding(originalMethod);\n        const char *swizzledTypeEncoding = method_getTypeEncoding(swizzledMethod);\n        \n        BOOL didAddMethod = class_addMethod(self, originalSelector, swizzleIMP, swizzledTypeEncoding);\n        \n        if (didAddMethod) {\n            \n            class_replaceMethod(self, swizzledSelector, originalIMP, originalTypeEncoding);\n        } else {\n            \n            method_exchangeImplementations(originalMethod, swizzledMethod);\n        }\n    });\n}\n\n- (void)ine_sendAction:(SEL)action to:(nullable id)target forEvent:(nullable UIEvent *)event  {\n    \n    if ([[self class] isEqual:[UIButton class]]) { // 以免把UIButton类簇里子类的方法也交换掉\n        \n        // 获取此次点击的时间戳\n        NSTimeInterval currentTimeClickTimestamp = [[NSDate date] timeIntervalSince1970];\n        \n        if (currentTimeClickTimestamp - self.ine_lastTimeClickTimestamp < kTwoTimeClickTimeInterval) { // 如果此次点击和上一次点击的时间间隔小于我们设定的时间间隔，则判定此次点击为暴力点击，什么都不做\n            \n            return;\n        } else { // 否则我们判定此次点击为正常点击，button正常处理事件\n            \n            // 记录上次点击的时间戳\n            self.ine_lastTimeClickTimestamp = currentTimeClickTimestamp;\n            \n            [self ine_sendAction:action to:target forEvent:event];\n        }\n    } else {\n        \n        [self ine_sendAction:action to:target forEvent:event];\n    }\n}\n\n- (void)setine_lastTimeClickTimestamp:(NSTimeInterval)ine_lastTimeClickTimestamp {\n    \n    objc_setAssociatedObject(self, @\"ine_lastTimeClickTimestamp\", @(ine_lastTimeClickTimestamp), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (NSTimeInterval)ine_lastTimeClickTimestamp {\n    \n    return [objc_getAssociatedObject(self, @\"ine_lastTimeClickTimestamp\") doubleValue];\n}\n\n@end\n```\n\n#### 2、刷新`TableView`、`CollectionView`时，自动判断是否该显示暂无数据\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103053060.png)\n\n```objectivec\n// UITableView+PromptImage.h\n#import <UIKit/UIKit.h>\n\n@interface UITableView (INEPromptImage)\n\n/// 提示图的名字\n@property (nonatomic, copy) NSString *ine_promptImageName;\n/// 提示文本\n@property (nonatomic, copy) NSString *ine_promptText;\n\n/// 点击提示图的回调\n@property (nonatomic, copy) void(^ine_didTapPromptImage)(void);\n\n/// 不使用该分类里的这套判定规则\n@property (nonatomic, assign) BOOL ine_dontUseThisCategory;\n\n@end\n\n\n// UITableView+PromptImage.m\n#import \"UITableView+INEPromptImage.h\"\n#import <objc/runtime.h>\n\n@interface UITableView ()\n\n// 已经调用过reloadData方法了\n@property (nonatomic, assign) BOOL ine_hasInvokedReloadData;\n\n// 提示图\n@property (nonatomic, strong) UIButton *ine_promptImageView;\n\n@end\n\n@implementation UITableView (INEPromptImage)\n\n+ (void)load {\n    \n    static dispatch_once_t onceToken;\n    dispatch_once(&onceToken, ^{\n        \n        [self methodSwizzlingWithOriginalSelector:@selector(reloadData) swizzledSelector:@selector(ine_reloadData)];\n    });\n}\n\n- (void)ine_reloadData {\n    \n    if ([[self class] isEqual:[UITableView class]] && !self.ine_dontUseThisCategory) {// 防止替换掉UITableView类簇里子类方法的实现\n        \n        [self ine_reloadData];\n        \n        if (self.ine_hasInvokedReloadData) {// 而是只在请求数据完成后，调用reloadData刷新界面时才处理提示图的显隐\n            \n            [self ine_handlePromptImage];\n        } else {// tableView第一次加载的时候会自动调用一下reloadData方法，这一次调用我们不处理提示图的显隐\n            \n            self.ine_hasInvokedReloadData = YES;\n        }\n    } else {\n        \n        [self ine_reloadData];\n    }\n}\n\n\n#pragma mark - private method\n\n// 提示图的显隐\n- (void)ine_handlePromptImage {\n    \n    if ([self ine_dataIsEmpty]) {\n        \n        [self ine_showPromptImage];\n    }else {\n        \n        [self ine_hidePromptImage];\n    }\n}\n\n// 判断请求到的数据是否为空\n- (BOOL)ine_dataIsEmpty {\n    \n    // 获取分区数\n    NSInteger sections = 0;\n    if ([self.dataSource respondsToSelector:@selector(numberOfSectionsInTableView:)]) {// 如果外界实现了该方法，则读取外界提供的分区数\n        \n        sections = [self numberOfSections];\n    } else {// 如果外界没实现该方法，系统不是会自动给我们返回一个分区嘛\n        \n        sections = 1;\n    }\n    \n    if (sections == 0) {// 分区数为0，说明数据为空\n        \n        return YES;\n    }\n    \n    \n    // 分区数不为0，则需要判断每个分区下的行数\n    for (int i = 0; i < sections; i ++) {\n        \n        // 获取各个分区的行数\n        NSInteger rows = [self numberOfRowsInSection:i];\n        \n        if (rows != 0) {// 但凡有一个分区下的行数不为0，说明数据不为空\n            \n            return NO;\n        }\n    }\n    \n    \n    // 如果所有分区下的行数都为0，才说明数据为空\n    return YES;\n}\n\n// 显示提示图\n- (void)ine_showPromptImage {\n    \n    if (self.ine_promptImageView == nil) {\n        \n        self.ine_promptImageView = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 60, 90)];\n        self.ine_promptImageView.backgroundColor = [UIColor clearColor];\n        self.ine_promptImageView.contentMode = UIViewContentModeCenter;\n        self.ine_promptImageView.userInteractionEnabled = YES;\n        self.ine_promptImageView.adjustsImageWhenHighlighted = NO;\n        \n        \n        [self.ine_promptImageView setTitleColor:Color_With_RGB(170, 170, 170, 1) forState:(UIControlStateNormal)];\n        self.ine_promptImageView.titleLabel.font = [UIFont systemFontOfSize:12];\n        \n        if (String_Is_Empty(self.ine_promptText)) {\n            \n            self.ine_promptText = @\"暂无数据\";\n        }\n        [self.ine_promptImageView setTitle:self.ine_promptText forState:(UIControlStateNormal)];\n        \n        if (self.ine_promptImageName.length == 0) {\n            \n            self.ine_promptImageName = @\"BaseProject_NoDataPromptImage\";\n        }\n        [self.ine_promptImageView setImage:[UIImage imageNamed:self.ine_promptImageName] forState:(UIControlStateNormal)];\n        [self.ine_promptImageView layoutImageAndTitle:(ImageAndTitleLayoutStyleImageOnLabel) imageTitleSpace:5];\n        \n        UITapGestureRecognizer *tapGestureRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(ine_didTapPromptImage:)];\n        [self.ine_promptImageView addGestureRecognizer:tapGestureRecognizer];\n    }\n    \n    self.backgroundView = self.ine_promptImageView;\n}\n\n// 隐藏提示图\n- (void)ine_hidePromptImage {\n    \n    self.backgroundView = nil;\n}\n\n// 点击提示图的回调\n- (void)ine_didTapPromptImage:(UITapGestureRecognizer *)tapGestureRecognizer {\n    \n    if (self.ine_didTapPromptImage) {\n        \n        self.ine_didTapPromptImage();\n    }\n}\n\n\n#pragma mark - setter, getter\n\n- (void)setine_hasInvokedReloadData:(BOOL)ine_hasInvokedReloadData {\n    \n    objc_setAssociatedObject(self, @\"ine_hasInvokedReloadData\", @(ine_hasInvokedReloadData), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (BOOL)ine_hasInvokedReloadData {\n    \n    return [objc_getAssociatedObject(self, @\"ine_hasInvokedReloadData\") boolValue];\n}\n\n- (void)setine_promptImageView:(UIImageView *)ine_promptImageView {\n    \n    objc_setAssociatedObject(self, @\"ine_promptImageView\", ine_promptImageView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (UIImageView *)ine_promptImageView {\n    \n    return objc_getAssociatedObject(self, @\"ine_promptImageView\");\n}\n\n- (void)setine_promptText:(NSString *)ine_promptText {\n    \n    objc_setAssociatedObject(self, @\"ine_promptText\", ine_promptText, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (NSString *)ine_promptText {\n    \n    return objc_getAssociatedObject(self, @\"ine_promptText\");\n}\n\n- (void)setine_promptImageName:(NSString *)ine_promptImageName {\n    \n    objc_setAssociatedObject(self, @\"ine_promptImageName\", ine_promptImageName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (NSString *)ine_promptImageName {\n    \n    return objc_getAssociatedObject(self, @\"ine_promptImageName\");\n}\n\n- (void)setine_didTapPromptImage:(void (^)(void))ine_didTapPromptImage {\n    \n    objc_setAssociatedObject(self, @\"ine_didTapPromptImage\", ine_didTapPromptImage, OBJC_ASSOCIATION_COPY);\n}\n\n- (void (^)(void))ine_didTapPromptImage {\n    \n    return objc_getAssociatedObject(self, @\"ine_didTapPromptImage\");\n}\n\n- (void)setine_dontUseThisCategory:(BOOL)ine_dontUseThisCategory {\n    \n    objc_setAssociatedObject(self, @\"ine_dontUseThisCategory\", @(ine_dontUseThisCategory), OBJC_ASSOCIATION_RETAIN_NONATOMIC);\n}\n\n- (BOOL)ine_dontUseThisCategory {\n    \n    return [objc_getAssociatedObject(self, @\"ine_dontUseThisCategory\") boolValue];\n}\n\n@end\n```\n\n","slug":"Runtime实际应用","published":1,"updated":"2022-07-18T02:55:25.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5q61nbf00001rfybmnqbjku","content":"<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200.png\" alt=\"img\"></p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>一、利用关联对象给分类添加完整属性</p>\n<p>​    1、分类能添加属性，但不能添加成员变量</p>\n<p>​    2、虽然能添加属性，但添加的是不完整的属性</p>\n<p>​    3、利用关联对象给分类添加完整的属性</p>\n<p>​    4、关联对象的本质</p>\n<p>二、获取一个类所有的成员变量。实现一键归档解裆</p>\n<p>三、使用<code>Method Swizzling</code></p>\n<p>​    1、防止button的暴力点击</p>\n<p>​    2、刷新<code>TableView</code>、<code>CollectionView</code>时，自动判断是否该显示暂无数据。</p>\n</blockquote>\n<h3 id=\"一、利用关联对象给分类添加完整属性\"><a href=\"#一、利用关联对象给分类添加完整属性\" class=\"headerlink\" title=\"一、利用关联对象给分类添加完整属性\"></a>一、利用关联对象给分类添加完整属性</h3><h4 id=\"1、分类里能添加属性，但不能添加成员变量\"><a href=\"#1、分类里能添加属性，但不能添加成员变量\" class=\"headerlink\" title=\"1、分类里能添加属性，但不能添加成员变量\"></a>1、分类里能添加属性，但不能添加成员变量</h4><p>举例来验证下：</p>\n<p>假设有一个<code>INEPerson</code>类，并且为它创建了一个分类<code>INEEat</code>。</p>\n<ul>\n<li>当我们在分类里添加属性时，编译器仅仅报警告说“<code>name</code>属性需要<code>name</code>方法和<code>setName:</code>方法的实现”，并建议我们“用<code>@dynamic</code>告诉编译器运行时才添加，或者直接在分类里添加这两个方法的实现”，编译能通过就证明：<strong>分类里能添加属性。</strong></li>\n</ul>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103622988.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103636300.png\" alt=\"img\"></p>\n<ul>\n<li>而当我们在分类里添加成员变量时，编译器直接报错说“成员变量不应该放在分类里”，编译报错就证明：<strong>分类里不能添加成员变量。</strong></li>\n</ul>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103750853.png\" alt=\"img\"></p>\n<p><strong>那为什么分类里能添加属性，但不能添加成员变量呢？首先我们知道类的成员变量列表是只读的（类的本质、<code>class_ro_t</code>、<code>ivars</code>那儿还记得吧），所以它在编译后就不能被修改了。其次分类的内部有相应的成员变量来存储该分类为类扩展的方法、属性和协议，但没有特定的成员变量用来存储分类为类扩展的成员变量（分类的本质那儿还记得吧），因此分类能为类扩展属性，但不能为类扩展成员变量。</strong></p>\n<h4 id=\"2、虽然能添加属性，但添加的是不完整的属性\"><a href=\"#2、虽然能添加属性，但添加的是不完整的属性\" class=\"headerlink\" title=\"2、虽然能添加属性，但添加的是不完整的属性\"></a>2、虽然能添加属性，但添加的是不完整的属性</h4><p>我们都知道，给类添加一个属性，系统其实做了三件事：</p>\n<blockquote>\n<ul>\n<li>生成对应的成员变量</li>\n<li>生成对应<code>setter</code>、<code>getter</code>方法的声明</li>\n<li>生成对应<code>setter</code>、<code>getter</code>方法的实现</li>\n</ul>\n<p>我们称这为完整的属性</p>\n</blockquote>\n<p>举例来验证下：</p>\n<p>接着第1小节的例子，我们仅仅在<code>INEEat</code>分类里为<code>INEPerson</code>类添加了一个<code>name</code>属性，现在打印一下<code>INEPerson</code>类的实例方法列表、属性列表和成员变量列表。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------ViewController.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)methodsOfClass:(Class)cls &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *methods = [@[] mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; count; i ++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Method method = methodList[I];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *methodName = <span class=\"built_in\">NSStringFromSelector</span>(method_getName(method));</span><br><span class=\"line\">        </span><br><span class=\"line\">        [methods addObject:methodName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(methodList);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> methods;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)propsOfClass:(Class)cls &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *props = [@[] mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\">    objc_property_t *propList = class_copyPropertyList(cls, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; count; i ++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        objc_property_t property = propList[I];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *propName = [<span class=\"built_in\">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [props addObject:propName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(propList);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> props;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)ivarsOfClass:(Class)cls &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *ivars = [@[] mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\">    Ivar *ivarList = class_copyIvarList(cls, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i ++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Ivar ivar = ivarList[I];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *ivarName = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [ivars addObject:ivarName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(ivarList);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ivars;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;实例方法列表：%@&quot;</span>, [<span class=\"keyword\">self</span> methodsOfClass:[INEPerson <span class=\"keyword\">class</span>]]);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;属性列表：%@&quot;</span>, [<span class=\"keyword\">self</span> propsOfClass:[INEPerson <span class=\"keyword\">class</span>]]);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;成员变量列表：%@&quot;</span>, [<span class=\"keyword\">self</span> ivarsOfClass:[INEPerson <span class=\"keyword\">class</span>]]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>控制台打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">实例方法列表：(</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">属性列表：(</span><br><span class=\"line\">    name</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">成员变量列表：(</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>可见给分类添加一个属性，确确实实没有生成对应的成员变量，也没有生成对应<code>setter</code>、<code>getter</code>方法的实现（方法只有被实现了，才会被放入类的<code>methods</code>成员变量中）。</p>\n<p>此时我们去<code>INEEat</code>分类里，尝试自己实现一下<code>name</code>属性的<code>setter</code>、<code>getter</code>方法，发现方法名敲一半它们会自动弹出来，这就证明<code>name</code>属性的<code>setter</code>、<code>getter</code>方法已经被声明了。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718104234339.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1008.png\" alt=\"img\"></p>\n<p><strong>那为什么分类里能添加属性，但仅仅是生成了对应<code>setter</code>、<code>getter</code>方法的声明，而不生成它们的实现呢？这主要还是因为分类内部结构里不能存储成员变量，而导致没有生成属性对应的成员变量，进而导致没法生成<code>setter</code>、<code>getter</code>方法的实现，我们知道<code>setter</code>、<code>getter</code>方法的内部实现不就是给成员变量赋值、取值嘛。</strong></p>\n<h4 id=\"3、利用关联对象给分类添加完整的属性\"><a href=\"#3、利用关联对象给分类添加完整的属性\" class=\"headerlink\" title=\"3、利用关联对象给分类添加完整的属性\"></a>3、利用关联对象给分类添加完整的属性</h4><p>在开发中，我们肯定会遇到往分类里添加属性的需求，但既然系统不会为我们自动生成对应的成员变量和<code>setter</code>、<code>getter</code>方法的实现，那我们就自己搞成一个完整的属性吧。</p>\n<p>自己搞的话，添加一对儿<code>setter</code>、<code>getter</code>方法倒是很简单，难的地方在于它俩的内部实现应该怎么写，也就是说数据要存储在哪里、又从哪里读取，再进一步就是说我们得想办法找一个类似于成员变量那么个东西来存储数据、并从它里面读取数据，要不然<code>setter</code>、<code>getter</code>方法里面没法写啊！当然我们可以自己写一个全局的字典来模拟成员变量那样存取数据，不过要做很多额外的考虑（例如数据是否和对象一对一、数据何时应该销毁、多线程条件下数据写入是否安全等），所以就<strong>直接用Runtime给我们提供的关联对象来代替成员变量存储数据吧！关联对象其实就是一个对象，和成员变量的功能差不多，用来帮助我们存储数据和读取数据。</strong></p>\n<p>有了代替成员变量的关联对象，我们就可以顺利地自己实现<code>setter</code>、<code>getter</code>方法了，用到的是Runtime的API。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson+INEEat.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEEat.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// object：被关联对象</span></span><br><span class=\"line\">    <span class=\"comment\">// key：存储关联对象时对应的key</span></span><br><span class=\"line\">    <span class=\"comment\">// value：要存储的数据</span></span><br><span class=\"line\">    <span class=\"comment\">// policy：存储数据的策略</span></span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;name&quot;</span>, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// object：被关联对象</span></span><br><span class=\"line\">    <span class=\"comment\">// key：存储关联对象时对应的key</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;name&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>移除关联对象：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 移除某个关联对象，把value设置为nil即可</span></span><br><span class=\"line\">objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;name&quot;</span>, <span class=\"literal\">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 移除所有的关联对象</span></span><br><span class=\"line\">objc_removeAssociatedObjects(<span class=\"type\">id</span> object);</span><br></pre></td></tr></table></figure>\n\n<p>数据存储策略：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">objc_AssociationPolicy</th>\n<th align=\"center\">对应修饰符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">OBJC_ASSOCIATION_ASSIGN</td>\n<td align=\"center\">assign</td>\n</tr>\n<tr>\n<td align=\"center\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>\n<td align=\"center\">strong、nonatomic</td>\n</tr>\n<tr>\n<td align=\"center\">OBJC_ASSOCIATION_COPY_NONATOMIC</td>\n<td align=\"center\">copy、nonatomic</td>\n</tr>\n<tr>\n<td align=\"center\">OBJC_ASSOCIATION_RETAIN</td>\n<td align=\"center\">strong、atomic</td>\n</tr>\n<tr>\n<td align=\"center\">OBJC_ASSOCIATION_COPY</td>\n<td align=\"center\">copy、atomic</td>\n</tr>\n</tbody></table>\n<h4 id=\"4、关联对象的本质\"><a href=\"#4、关联对象的本质\" class=\"headerlink\" title=\"4、关联对象的本质\"></a>4、关联对象的本质</h4><p>通过查看Runtime的源码（<code>objc-references.mm</code>文件），我们得到关联对象的定义如下：（伪代码）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc_setAssociatedObject(..., ..., value, policy);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ObjcAssociation</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> _policy;</span><br><span class=\"line\">    id _value;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可见<strong>关联对象的本质就是一个C++的<code>ObjcAssociation</code>对象，它内部存储着我们想要存储的数据和存储数据的策略，即<code>objc_setAssociatedObject(...)</code>函数的第三个、第四个参数。</strong></p>\n<p>然后关联对象会跟<code>objc_setAssociatedObject(...)</code>函数的第二个参数映射到一个叫<code>AssociationsMap</code>的小字典里，这个小字典维护着某个对象所有的关联对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc_setAssociatedObject(..., key, ..., ...);</span></span><br><span class=\"line\"></span><br><span class=\"line\">AssociationsMap = @&#123;</span><br><span class=\"line\">                    key: ObjcAssociation,</span><br><span class=\"line\">                    key: ObjcAssociation,</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例如：</span></span><br><span class=\"line\">AssociationsMap = @&#123;</span><br><span class=\"line\">                    <span class=\"string\">&quot;name&quot;</span>: name属性对应的关联对象,</span><br><span class=\"line\">                    <span class=\"string\">&quot;age&quot;</span>: age属性对应的关联对象,</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后<code>AssociationsMap</code>的小字典又会跟<code>objc_setAssociatedObject(...)</code>函数的第一个参数映射到一个叫<code>AssociationsHashMap</code>的大字典里，这个大字典是Runtime维护的一个全局的字典，它维护着整个项目中所有对象的所有关联对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc_setAssociatedObject(object, ..., ..., ...);</span></span><br><span class=\"line\"></span><br><span class=\"line\">AssociationsHashMap = @&#123;</span><br><span class=\"line\">                        objcet: AssociationsMap,</span><br><span class=\"line\">                        objcet: AssociationsMap,</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例如：</span></span><br><span class=\"line\">AssociationsHashMap = @&#123;</span><br><span class=\"line\">                        person1: person1的AssociationsMap,</span><br><span class=\"line\">                        person2: person2的AssociationsMap,</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二、获取一个类所有的成员变量。实现一键归档解裆\"><a href=\"#二、获取一个类所有的成员变量。实现一键归档解裆\" class=\"headerlink\" title=\"二、获取一个类所有的成员变量。实现一键归档解裆\"></a>二、获取一个类所有的成员变量。实现一键归档解裆</h3><p>我们知道把一个复杂对象存储进<code>NSUserDefaults</code>的时候，必须先把复杂对象归档为<code>NSData</code>再存进去，读取的时候也必须先把<code>NSData</code>读出来然后再解裆为复杂对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------<span class=\"built_in\">NSUserDefaults</span>+INESaveComplexObject.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSUserDefaults</span> (<span class=\"title\">INESaveComplexObject</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_setComplexObject:(<span class=\"type\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)defaultName;</span><br><span class=\"line\">- (<span class=\"type\">id</span>)ine_complexObjectForKey:(<span class=\"built_in\">NSString</span> *)defaultName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------<span class=\"built_in\">NSUserDefaults</span>+INESaveComplexObject.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;NSUserDefaults+INESaveComplexObject.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSUserDefaults</span> (<span class=\"title\">INESaveComplexObject</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_setComplexObject:(<span class=\"type\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)defaultName &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *writeData = [<span class=\"built_in\">NSKeyedArchiver</span> archivedDataWithRootObject:value];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:writeData forKey:defaultName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">id</span>)ine_complexObjectForKey:(<span class=\"built_in\">NSString</span> *)defaultName &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *readData = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:defaultName];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithData:readData];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>而对象在归档解裆时又必须遵循<code>NSCoding</code>协议，并实现协议里的<code>encodeWithCoder:</code>、<code>initWithCoder:</code>方法，我们总不能把项目里所有的对象的所有的成员变量都这么写一遍吧，那样工作量太大了，并且这种重复的工作似乎没太大意义，于是可以考虑使用Runtime来做。给<code>NSObject</code>添加一个分类，让它遵循<code>NSCoding</code>协议，并且实现协议里的<code>encodeWithCoder:</code>、<code>initWithCoder:</code>方法，我们调用Runtime得API遍历一个类所有的成员变量，实现一键归解档。</p>\n<h3 id=\"三、使用Method-Swizzling\"><a href=\"#三、使用Method-Swizzling\" class=\"headerlink\" title=\"三、使用Method Swizzling\"></a>三、使用<code>Method Swizzling</code></h3><p>使用<code>Method Swizzling</code>需要注意以下几点：</p>\n<ul>\n<li><p><strong>方法交互操作一定要写在<code>+load</code>方法里，而不能写在<code>+initialize</code>方法里。</strong>因为<code>+load</code>方法是在类和分类加载到内存的时候调用的，不管代码里使用或者不使用这个类的分类都会被调用，而<code>+initialize</code>则是类被初始化的时候调用的，项目里没有用到这个类就不会被调用，所以要写在<code>+load</code>方法确保方法交换成功。</p>\n</li>\n<li><p><strong>方法交换操作一定要写在<code>dispatch_once</code>里。</strong>算然说<code>+load</code>方法本身只会执行一次，但是并不能确保其他人不会再某些地方主动再调用一次<code>+load</code>方法，这就可能导致又把两个方法的实现给交换回去了。</p>\n</li>\n<li><p><strong>在我们自己写的方法里，要判断一下触发了该方法的类是不是当前类，以免把类簇里的子类方法也替换掉。</strong>（例如下面的<code>UIButton</code>和<code>UITableView</code>就有类簇，OC中大量使用了类簇，我们常用的<code>NSString</code>、<code>NSArray</code>、<code>NSDictionary</code>等都采用类簇的形式实现）</p>\n</li>\n<li><p><strong>在我们自己写的方法里，记得要调用一些方法的原生实现</strong>（除非你非常确定不需要调用方法的原生实现），因为不调用一下的话，就可能因为丢掉方法的原生实现而导致不可预知的bug。</p>\n</li>\n</ul>\n<h4 id=\"1、防止button的暴力点击\"><a href=\"#1、防止button的暴力点击\" class=\"headerlink\" title=\"1、防止button的暴力点击\"></a>1、防止button的暴力点击</h4><p>我们知道所有继承自<code>UIControl</code>的类，在处理事件时都会首先调用<code>sendAction:to:forEvent:</code>方法，我们可以交换它的实现来防止<code>Button</code>的暴力点击。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;UIButton+INEPreventViolentClick.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> kTimeInterval 0.5 <span class=\"comment\">// 被认定为暴力点击的时间间隔</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSTimeInterval</span> ine_lastTimeClickTimestamp; <span class=\"comment\">// 上一次点击的时间戳</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">INEPreventViolentClick</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(sendAction:to:forEvent:);</span><br><span class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(ine_sendAction:to:forEvent:);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(<span class=\"keyword\">self</span>, originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(<span class=\"keyword\">self</span>, swizzledSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        IMP originalIMP = method_getImplementation(originalMethod);</span><br><span class=\"line\">        IMP swizzleIMP = method_getImplementation(swizzledMethod);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"type\">char</span> *originalTypeEncoding = method_getTypeEncoding(originalMethod);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"type\">char</span> *swizzledTypeEncoding = method_getTypeEncoding(swizzledMethod);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">BOOL</span> didAddMethod = class_addMethod(<span class=\"keyword\">self</span>, originalSelector, swizzleIMP, swizzledTypeEncoding);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">self</span>, swizzledSelector, originalIMP, originalTypeEncoding);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_sendAction:(SEL)action to:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span>)target forEvent:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIEvent</span> *)event  &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] isEqual:[<span class=\"built_in\">UIButton</span> <span class=\"keyword\">class</span>]]) &#123; <span class=\"comment\">// 以免把UIButton类簇里子类的方法也交换掉</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取此次点击的时间戳</span></span><br><span class=\"line\">        <span class=\"built_in\">NSTimeInterval</span> currentTimeClickTimestamp = [[<span class=\"built_in\">NSDate</span> date] timeIntervalSince1970];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentTimeClickTimestamp - <span class=\"keyword\">self</span>.ine_lastTimeClickTimestamp &lt; kTwoTimeClickTimeInterval) &#123; <span class=\"comment\">// 如果此次点击和上一次点击的时间间隔小于我们设定的时间间隔，则判定此次点击为暴力点击，什么都不做</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 否则我们判定此次点击为正常点击，button正常处理事件</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 记录上次点击的时间戳</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.ine_lastTimeClickTimestamp = currentTimeClickTimestamp;</span><br><span class=\"line\">            </span><br><span class=\"line\">            [<span class=\"keyword\">self</span> ine_sendAction:action to:target forEvent:event];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_sendAction:action to:target forEvent:event];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_lastTimeClickTimestamp:(<span class=\"built_in\">NSTimeInterval</span>)ine_lastTimeClickTimestamp &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_lastTimeClickTimestamp&quot;</span>, @(ine_lastTimeClickTimestamp), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSTimeInterval</span>)ine_lastTimeClickTimestamp &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_lastTimeClickTimestamp&quot;</span>) doubleValue];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、刷新TableView、CollectionView时，自动判断是否该显示暂无数据\"><a href=\"#2、刷新TableView、CollectionView时，自动判断是否该显示暂无数据\" class=\"headerlink\" title=\"2、刷新TableView、CollectionView时，自动判断是否该显示暂无数据\"></a>2、刷新<code>TableView</code>、<code>CollectionView</code>时，自动判断是否该显示暂无数据</h4><p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103053060.png\" alt=\"img\"></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UITableView+PromptImage.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UITableView</span> (<span class=\"title\">INEPromptImage</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 提示图的名字</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *ine_promptImageName;</span><br><span class=\"line\"><span class=\"comment\">/// 提示文本</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *ine_promptText;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 点击提示图的回调</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"type\">void</span>(^ine_didTapPromptImage)(<span class=\"type\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 不使用该分类里的这套判定规则</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"type\">BOOL</span> ine_dontUseThisCategory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UITableView+PromptImage.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;UITableView+INEPromptImage.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UITableView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 已经调用过reloadData方法了</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"type\">BOOL</span> ine_hasInvokedReloadData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提示图</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIButton</span> *ine_promptImageView;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UITableView</span> (<span class=\"title\">INEPromptImage</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> methodSwizzlingWithOriginalSelector:<span class=\"keyword\">@selector</span>(reloadData) swizzledSelector:<span class=\"keyword\">@selector</span>(ine_reloadData)];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_reloadData &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] isEqual:[<span class=\"built_in\">UITableView</span> <span class=\"keyword\">class</span>]] &amp;&amp; !<span class=\"keyword\">self</span>.ine_dontUseThisCategory) &#123;<span class=\"comment\">// 防止替换掉UITableView类簇里子类方法的实现</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_reloadData];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.ine_hasInvokedReloadData) &#123;<span class=\"comment\">// 而是只在请求数据完成后，调用reloadData刷新界面时才处理提示图的显隐</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            [<span class=\"keyword\">self</span> ine_handlePromptImage];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// tableView第一次加载的时候会自动调用一下reloadData方法，这一次调用我们不处理提示图的显隐</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">self</span>.ine_hasInvokedReloadData = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_reloadData];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark - private method</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提示图的显隐</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_handlePromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> ine_dataIsEmpty]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_showPromptImage];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_hidePromptImage];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断请求到的数据是否为空</span></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)ine_dataIsEmpty &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取分区数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> sections = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.dataSource respondsToSelector:<span class=\"keyword\">@selector</span>(numberOfSectionsInTableView:)]) &#123;<span class=\"comment\">// 如果外界实现了该方法，则读取外界提供的分区数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sections = [<span class=\"keyword\">self</span> numberOfSections];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 如果外界没实现该方法，系统不是会自动给我们返回一个分区嘛</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sections = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sections == <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 分区数为0，说明数据为空</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 分区数不为0，则需要判断每个分区下的行数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sections; i ++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取各个分区的行数</span></span><br><span class=\"line\">        <span class=\"built_in\">NSInteger</span> rows = [<span class=\"keyword\">self</span> numberOfRowsInSection:i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rows != <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 但凡有一个分区下的行数不为0，说明数据不为空</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果所有分区下的行数都为0，才说明数据为空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 显示提示图</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_showPromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.ine_promptImageView == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">60</span>, <span class=\"number\">90</span>)];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.backgroundColor = [<span class=\"built_in\">UIColor</span> clearColor];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.contentMode = <span class=\"built_in\">UIViewContentModeCenter</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.userInteractionEnabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.adjustsImageWhenHighlighted = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView setTitleColor:Color_With_RGB(<span class=\"number\">170</span>, <span class=\"number\">170</span>, <span class=\"number\">170</span>, <span class=\"number\">1</span>) forState:(<span class=\"built_in\">UIControlStateNormal</span>)];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.titleLabel.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">12</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (String_Is_Empty(<span class=\"keyword\">self</span>.ine_promptText)) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">self</span>.ine_promptText = <span class=\"string\">@&quot;暂无数据&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView setTitle:<span class=\"keyword\">self</span>.ine_promptText forState:(<span class=\"built_in\">UIControlStateNormal</span>)];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.ine_promptImageName.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">self</span>.ine_promptImageName = <span class=\"string\">@&quot;BaseProject_NoDataPromptImage&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"keyword\">self</span>.ine_promptImageName] forState:(<span class=\"built_in\">UIControlStateNormal</span>)];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView layoutImageAndTitle:(ImageAndTitleLayoutStyleImageOnLabel) imageTitleSpace:<span class=\"number\">5</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">UITapGestureRecognizer</span> *tapGestureRecognizer = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(ine_didTapPromptImage:)];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView addGestureRecognizer:tapGestureRecognizer];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.backgroundView = <span class=\"keyword\">self</span>.ine_promptImageView;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 隐藏提示图</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_hidePromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.backgroundView = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 点击提示图的回调</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_didTapPromptImage:(<span class=\"built_in\">UITapGestureRecognizer</span> *)tapGestureRecognizer &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.ine_didTapPromptImage) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_didTapPromptImage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark - setter, getter</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_hasInvokedReloadData:(<span class=\"type\">BOOL</span>)ine_hasInvokedReloadData &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_hasInvokedReloadData&quot;</span>, @(ine_hasInvokedReloadData), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)ine_hasInvokedReloadData &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_hasInvokedReloadData&quot;</span>) boolValue];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_promptImageView:(<span class=\"built_in\">UIImageView</span> *)ine_promptImageView &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptImageView&quot;</span>, ine_promptImageView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">UIImageView</span> *)ine_promptImageView &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptImageView&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_promptText:(<span class=\"built_in\">NSString</span> *)ine_promptText &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptText&quot;</span>, ine_promptText, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)ine_promptText &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptText&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_promptImageName:(<span class=\"built_in\">NSString</span> *)ine_promptImageName &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptImageName&quot;</span>, ine_promptImageName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)ine_promptImageName &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptImageName&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_didTapPromptImage:(<span class=\"type\">void</span> (^)(<span class=\"type\">void</span>))ine_didTapPromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_didTapPromptImage&quot;</span>, ine_didTapPromptImage, OBJC_ASSOCIATION_COPY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span> (^)(<span class=\"type\">void</span>))ine_didTapPromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_didTapPromptImage&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_dontUseThisCategory:(<span class=\"type\">BOOL</span>)ine_dontUseThisCategory &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_dontUseThisCategory&quot;</span>, @(ine_dontUseThisCategory), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)ine_dontUseThisCategory &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_dontUseThisCategory&quot;</span>) boolValue];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200.png\" alt=\"img\"></p>","more":"<blockquote>\n<p>一、利用关联对象给分类添加完整属性</p>\n<p>​    1、分类能添加属性，但不能添加成员变量</p>\n<p>​    2、虽然能添加属性，但添加的是不完整的属性</p>\n<p>​    3、利用关联对象给分类添加完整的属性</p>\n<p>​    4、关联对象的本质</p>\n<p>二、获取一个类所有的成员变量。实现一键归档解裆</p>\n<p>三、使用<code>Method Swizzling</code></p>\n<p>​    1、防止button的暴力点击</p>\n<p>​    2、刷新<code>TableView</code>、<code>CollectionView</code>时，自动判断是否该显示暂无数据。</p>\n</blockquote>\n<h3 id=\"一、利用关联对象给分类添加完整属性\"><a href=\"#一、利用关联对象给分类添加完整属性\" class=\"headerlink\" title=\"一、利用关联对象给分类添加完整属性\"></a>一、利用关联对象给分类添加完整属性</h3><h4 id=\"1、分类里能添加属性，但不能添加成员变量\"><a href=\"#1、分类里能添加属性，但不能添加成员变量\" class=\"headerlink\" title=\"1、分类里能添加属性，但不能添加成员变量\"></a>1、分类里能添加属性，但不能添加成员变量</h4><p>举例来验证下：</p>\n<p>假设有一个<code>INEPerson</code>类，并且为它创建了一个分类<code>INEEat</code>。</p>\n<ul>\n<li>当我们在分类里添加属性时，编译器仅仅报警告说“<code>name</code>属性需要<code>name</code>方法和<code>setName:</code>方法的实现”，并建议我们“用<code>@dynamic</code>告诉编译器运行时才添加，或者直接在分类里添加这两个方法的实现”，编译能通过就证明：<strong>分类里能添加属性。</strong></li>\n</ul>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103622988.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103636300.png\" alt=\"img\"></p>\n<ul>\n<li>而当我们在分类里添加成员变量时，编译器直接报错说“成员变量不应该放在分类里”，编译报错就证明：<strong>分类里不能添加成员变量。</strong></li>\n</ul>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103750853.png\" alt=\"img\"></p>\n<p><strong>那为什么分类里能添加属性，但不能添加成员变量呢？首先我们知道类的成员变量列表是只读的（类的本质、<code>class_ro_t</code>、<code>ivars</code>那儿还记得吧），所以它在编译后就不能被修改了。其次分类的内部有相应的成员变量来存储该分类为类扩展的方法、属性和协议，但没有特定的成员变量用来存储分类为类扩展的成员变量（分类的本质那儿还记得吧），因此分类能为类扩展属性，但不能为类扩展成员变量。</strong></p>\n<h4 id=\"2、虽然能添加属性，但添加的是不完整的属性\"><a href=\"#2、虽然能添加属性，但添加的是不完整的属性\" class=\"headerlink\" title=\"2、虽然能添加属性，但添加的是不完整的属性\"></a>2、虽然能添加属性，但添加的是不完整的属性</h4><p>我们都知道，给类添加一个属性，系统其实做了三件事：</p>\n<blockquote>\n<ul>\n<li>生成对应的成员变量</li>\n<li>生成对应<code>setter</code>、<code>getter</code>方法的声明</li>\n<li>生成对应<code>setter</code>、<code>getter</code>方法的实现</li>\n</ul>\n<p>我们称这为完整的属性</p>\n</blockquote>\n<p>举例来验证下：</p>\n<p>接着第1小节的例子，我们仅仅在<code>INEEat</code>分类里为<code>INEPerson</code>类添加了一个<code>name</code>属性，现在打印一下<code>INEPerson</code>类的实例方法列表、属性列表和成员变量列表。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------ViewController.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)methodsOfClass:(Class)cls &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *methods = [@[] mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; count; i ++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Method method = methodList[I];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *methodName = <span class=\"built_in\">NSStringFromSelector</span>(method_getName(method));</span><br><span class=\"line\">        </span><br><span class=\"line\">        [methods addObject:methodName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(methodList);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> methods;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)propsOfClass:(Class)cls &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *props = [@[] mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\">    objc_property_t *propList = class_copyPropertyList(cls, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">NSInteger</span> i = <span class=\"number\">0</span>; i &lt; count; i ++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        objc_property_t property = propList[I];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *propName = [<span class=\"built_in\">NSString</span> stringWithUTF8String:property_getName(property)];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [props addObject:propName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(propList);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> props;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSArray</span> *)ivarsOfClass:(Class)cls &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *ivars = [@[] mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\">    Ivar *ivarList = class_copyIvarList(cls, &amp;count);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i ++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Ivar ivar = ivarList[I];</span><br><span class=\"line\">        <span class=\"built_in\">NSString</span> *ivarName = [<span class=\"built_in\">NSString</span> stringWithUTF8String:ivar_getName(ivar)];</span><br><span class=\"line\">        </span><br><span class=\"line\">        [ivars addObject:ivarName];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    free(ivarList);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ivars;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;实例方法列表：%@&quot;</span>, [<span class=\"keyword\">self</span> methodsOfClass:[INEPerson <span class=\"keyword\">class</span>]]);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;属性列表：%@&quot;</span>, [<span class=\"keyword\">self</span> propsOfClass:[INEPerson <span class=\"keyword\">class</span>]]);</span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;成员变量列表：%@&quot;</span>, [<span class=\"keyword\">self</span> ivarsOfClass:[INEPerson <span class=\"keyword\">class</span>]]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>控制台打印如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">实例方法列表：(</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">属性列表：(</span><br><span class=\"line\">    name</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">成员变量列表：(</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>可见给分类添加一个属性，确确实实没有生成对应的成员变量，也没有生成对应<code>setter</code>、<code>getter</code>方法的实现（方法只有被实现了，才会被放入类的<code>methods</code>成员变量中）。</p>\n<p>此时我们去<code>INEEat</code>分类里，尝试自己实现一下<code>name</code>属性的<code>setter</code>、<code>getter</code>方法，发现方法名敲一半它们会自动弹出来，这就证明<code>name</code>属性的<code>setter</code>、<code>getter</code>方法已经被声明了。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718104234339.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1008.png\" alt=\"img\"></p>\n<p><strong>那为什么分类里能添加属性，但仅仅是生成了对应<code>setter</code>、<code>getter</code>方法的声明，而不生成它们的实现呢？这主要还是因为分类内部结构里不能存储成员变量，而导致没有生成属性对应的成员变量，进而导致没法生成<code>setter</code>、<code>getter</code>方法的实现，我们知道<code>setter</code>、<code>getter</code>方法的内部实现不就是给成员变量赋值、取值嘛。</strong></p>\n<h4 id=\"3、利用关联对象给分类添加完整的属性\"><a href=\"#3、利用关联对象给分类添加完整的属性\" class=\"headerlink\" title=\"3、利用关联对象给分类添加完整的属性\"></a>3、利用关联对象给分类添加完整的属性</h4><p>在开发中，我们肯定会遇到往分类里添加属性的需求，但既然系统不会为我们自动生成对应的成员变量和<code>setter</code>、<code>getter</code>方法的实现，那我们就自己搞成一个完整的属性吧。</p>\n<p>自己搞的话，添加一对儿<code>setter</code>、<code>getter</code>方法倒是很简单，难的地方在于它俩的内部实现应该怎么写，也就是说数据要存储在哪里、又从哪里读取，再进一步就是说我们得想办法找一个类似于成员变量那么个东西来存储数据、并从它里面读取数据，要不然<code>setter</code>、<code>getter</code>方法里面没法写啊！当然我们可以自己写一个全局的字典来模拟成员变量那样存取数据，不过要做很多额外的考虑（例如数据是否和对象一对一、数据何时应该销毁、多线程条件下数据写入是否安全等），所以就<strong>直接用Runtime给我们提供的关联对象来代替成员变量存储数据吧！关联对象其实就是一个对象，和成员变量的功能差不多，用来帮助我们存储数据和读取数据。</strong></p>\n<p>有了代替成员变量的关联对象，我们就可以顺利地自己实现<code>setter</code>、<code>getter</code>方法了，用到的是Runtime的API。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------INEPerson+INEEat.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;INEPerson+INEEat.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> (<span class=\"title\">INEEat</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// object：被关联对象</span></span><br><span class=\"line\">    <span class=\"comment\">// key：存储关联对象时对应的key</span></span><br><span class=\"line\">    <span class=\"comment\">// value：要存储的数据</span></span><br><span class=\"line\">    <span class=\"comment\">// policy：存储数据的策略</span></span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;name&quot;</span>, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// object：被关联对象</span></span><br><span class=\"line\">    <span class=\"comment\">// key：存储关联对象时对应的key</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;name&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>移除关联对象：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 移除某个关联对象，把value设置为nil即可</span></span><br><span class=\"line\">objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;name&quot;</span>, <span class=\"literal\">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 移除所有的关联对象</span></span><br><span class=\"line\">objc_removeAssociatedObjects(<span class=\"type\">id</span> object);</span><br></pre></td></tr></table></figure>\n\n<p>数据存储策略：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">objc_AssociationPolicy</th>\n<th align=\"center\">对应修饰符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">OBJC_ASSOCIATION_ASSIGN</td>\n<td align=\"center\">assign</td>\n</tr>\n<tr>\n<td align=\"center\">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>\n<td align=\"center\">strong、nonatomic</td>\n</tr>\n<tr>\n<td align=\"center\">OBJC_ASSOCIATION_COPY_NONATOMIC</td>\n<td align=\"center\">copy、nonatomic</td>\n</tr>\n<tr>\n<td align=\"center\">OBJC_ASSOCIATION_RETAIN</td>\n<td align=\"center\">strong、atomic</td>\n</tr>\n<tr>\n<td align=\"center\">OBJC_ASSOCIATION_COPY</td>\n<td align=\"center\">copy、atomic</td>\n</tr>\n</tbody></table>\n<h4 id=\"4、关联对象的本质\"><a href=\"#4、关联对象的本质\" class=\"headerlink\" title=\"4、关联对象的本质\"></a>4、关联对象的本质</h4><p>通过查看Runtime的源码（<code>objc-references.mm</code>文件），我们得到关联对象的定义如下：（伪代码）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc_setAssociatedObject(..., ..., value, policy);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ObjcAssociation</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> _policy;</span><br><span class=\"line\">    id _value;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可见<strong>关联对象的本质就是一个C++的<code>ObjcAssociation</code>对象，它内部存储着我们想要存储的数据和存储数据的策略，即<code>objc_setAssociatedObject(...)</code>函数的第三个、第四个参数。</strong></p>\n<p>然后关联对象会跟<code>objc_setAssociatedObject(...)</code>函数的第二个参数映射到一个叫<code>AssociationsMap</code>的小字典里，这个小字典维护着某个对象所有的关联对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc_setAssociatedObject(..., key, ..., ...);</span></span><br><span class=\"line\"></span><br><span class=\"line\">AssociationsMap = @&#123;</span><br><span class=\"line\">                    key: ObjcAssociation,</span><br><span class=\"line\">                    key: ObjcAssociation,</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例如：</span></span><br><span class=\"line\">AssociationsMap = @&#123;</span><br><span class=\"line\">                    <span class=\"string\">&quot;name&quot;</span>: name属性对应的关联对象,</span><br><span class=\"line\">                    <span class=\"string\">&quot;age&quot;</span>: age属性对应的关联对象,</span><br><span class=\"line\">                    ...</span><br><span class=\"line\">                    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后<code>AssociationsMap</code>的小字典又会跟<code>objc_setAssociatedObject(...)</code>函数的第一个参数映射到一个叫<code>AssociationsHashMap</code>的大字典里，这个大字典是Runtime维护的一个全局的字典，它维护着整个项目中所有对象的所有关联对象。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// objc_setAssociatedObject(object, ..., ..., ...);</span></span><br><span class=\"line\"></span><br><span class=\"line\">AssociationsHashMap = @&#123;</span><br><span class=\"line\">                        objcet: AssociationsMap,</span><br><span class=\"line\">                        objcet: AssociationsMap,</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 例如：</span></span><br><span class=\"line\">AssociationsHashMap = @&#123;</span><br><span class=\"line\">                        person1: person1的AssociationsMap,</span><br><span class=\"line\">                        person2: person2的AssociationsMap,</span><br><span class=\"line\">                        ...</span><br><span class=\"line\">                        &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"二、获取一个类所有的成员变量。实现一键归档解裆\"><a href=\"#二、获取一个类所有的成员变量。实现一键归档解裆\" class=\"headerlink\" title=\"二、获取一个类所有的成员变量。实现一键归档解裆\"></a>二、获取一个类所有的成员变量。实现一键归档解裆</h3><p>我们知道把一个复杂对象存储进<code>NSUserDefaults</code>的时候，必须先把复杂对象归档为<code>NSData</code>再存进去，读取的时候也必须先把<code>NSData</code>读出来然后再解裆为复杂对象。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-----------<span class=\"built_in\">NSUserDefaults</span>+INESaveComplexObject.h-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">NSUserDefaults</span> (<span class=\"title\">INESaveComplexObject</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_setComplexObject:(<span class=\"type\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)defaultName;</span><br><span class=\"line\">- (<span class=\"type\">id</span>)ine_complexObjectForKey:(<span class=\"built_in\">NSString</span> *)defaultName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">-----------<span class=\"built_in\">NSUserDefaults</span>+INESaveComplexObject.m-----------</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;NSUserDefaults+INESaveComplexObject.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">NSUserDefaults</span> (<span class=\"title\">INESaveComplexObject</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_setComplexObject:(<span class=\"type\">id</span>)value forKey:(<span class=\"built_in\">NSString</span> *)defaultName &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *writeData = [<span class=\"built_in\">NSKeyedArchiver</span> archivedDataWithRootObject:value];</span><br><span class=\"line\">    [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] setObject:writeData forKey:defaultName];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">id</span>)ine_complexObjectForKey:(<span class=\"built_in\">NSString</span> *)defaultName &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *readData = [[<span class=\"built_in\">NSUserDefaults</span> standardUserDefaults] objectForKey:defaultName];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSKeyedUnarchiver</span> unarchiveObjectWithData:readData];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>而对象在归档解裆时又必须遵循<code>NSCoding</code>协议，并实现协议里的<code>encodeWithCoder:</code>、<code>initWithCoder:</code>方法，我们总不能把项目里所有的对象的所有的成员变量都这么写一遍吧，那样工作量太大了，并且这种重复的工作似乎没太大意义，于是可以考虑使用Runtime来做。给<code>NSObject</code>添加一个分类，让它遵循<code>NSCoding</code>协议，并且实现协议里的<code>encodeWithCoder:</code>、<code>initWithCoder:</code>方法，我们调用Runtime得API遍历一个类所有的成员变量，实现一键归解档。</p>\n<h3 id=\"三、使用Method-Swizzling\"><a href=\"#三、使用Method-Swizzling\" class=\"headerlink\" title=\"三、使用Method Swizzling\"></a>三、使用<code>Method Swizzling</code></h3><p>使用<code>Method Swizzling</code>需要注意以下几点：</p>\n<ul>\n<li><p><strong>方法交互操作一定要写在<code>+load</code>方法里，而不能写在<code>+initialize</code>方法里。</strong>因为<code>+load</code>方法是在类和分类加载到内存的时候调用的，不管代码里使用或者不使用这个类的分类都会被调用，而<code>+initialize</code>则是类被初始化的时候调用的，项目里没有用到这个类就不会被调用，所以要写在<code>+load</code>方法确保方法交换成功。</p>\n</li>\n<li><p><strong>方法交换操作一定要写在<code>dispatch_once</code>里。</strong>算然说<code>+load</code>方法本身只会执行一次，但是并不能确保其他人不会再某些地方主动再调用一次<code>+load</code>方法，这就可能导致又把两个方法的实现给交换回去了。</p>\n</li>\n<li><p><strong>在我们自己写的方法里，要判断一下触发了该方法的类是不是当前类，以免把类簇里的子类方法也替换掉。</strong>（例如下面的<code>UIButton</code>和<code>UITableView</code>就有类簇，OC中大量使用了类簇，我们常用的<code>NSString</code>、<code>NSArray</code>、<code>NSDictionary</code>等都采用类簇的形式实现）</p>\n</li>\n<li><p><strong>在我们自己写的方法里，记得要调用一些方法的原生实现</strong>（除非你非常确定不需要调用方法的原生实现），因为不调用一下的话，就可能因为丢掉方法的原生实现而导致不可预知的bug。</p>\n</li>\n</ul>\n<h4 id=\"1、防止button的暴力点击\"><a href=\"#1、防止button的暴力点击\" class=\"headerlink\" title=\"1、防止button的暴力点击\"></a>1、防止button的暴力点击</h4><p>我们知道所有继承自<code>UIControl</code>的类，在处理事件时都会首先调用<code>sendAction:to:forEvent:</code>方法，我们可以交换它的实现来防止<code>Button</code>的暴力点击。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;UIButton+INEPreventViolentClick.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> kTimeInterval 0.5 <span class=\"comment\">// 被认定为暴力点击的时间间隔</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UIButton</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"built_in\">NSTimeInterval</span> ine_lastTimeClickTimestamp; <span class=\"comment\">// 上一次点击的时间戳</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UIButton</span> (<span class=\"title\">INEPreventViolentClick</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        SEL originalSelector = <span class=\"keyword\">@selector</span>(sendAction:to:forEvent:);</span><br><span class=\"line\">        SEL swizzledSelector = <span class=\"keyword\">@selector</span>(ine_sendAction:to:forEvent:);</span><br><span class=\"line\">        </span><br><span class=\"line\">        Method originalMethod = class_getInstanceMethod(<span class=\"keyword\">self</span>, originalSelector);</span><br><span class=\"line\">        Method swizzledMethod = class_getInstanceMethod(<span class=\"keyword\">self</span>, swizzledSelector);</span><br><span class=\"line\">        </span><br><span class=\"line\">        IMP originalIMP = method_getImplementation(originalMethod);</span><br><span class=\"line\">        IMP swizzleIMP = method_getImplementation(swizzledMethod);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"type\">char</span> *originalTypeEncoding = method_getTypeEncoding(originalMethod);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"type\">char</span> *swizzledTypeEncoding = method_getTypeEncoding(swizzledMethod);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">BOOL</span> didAddMethod = class_addMethod(<span class=\"keyword\">self</span>, originalSelector, swizzleIMP, swizzledTypeEncoding);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (didAddMethod) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            class_replaceMethod(<span class=\"keyword\">self</span>, swizzledSelector, originalIMP, originalTypeEncoding);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_sendAction:(SEL)action to:(<span class=\"keyword\">nullable</span> <span class=\"type\">id</span>)target forEvent:(<span class=\"keyword\">nullable</span> <span class=\"built_in\">UIEvent</span> *)event  &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] isEqual:[<span class=\"built_in\">UIButton</span> <span class=\"keyword\">class</span>]]) &#123; <span class=\"comment\">// 以免把UIButton类簇里子类的方法也交换掉</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取此次点击的时间戳</span></span><br><span class=\"line\">        <span class=\"built_in\">NSTimeInterval</span> currentTimeClickTimestamp = [[<span class=\"built_in\">NSDate</span> date] timeIntervalSince1970];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentTimeClickTimestamp - <span class=\"keyword\">self</span>.ine_lastTimeClickTimestamp &lt; kTwoTimeClickTimeInterval) &#123; <span class=\"comment\">// 如果此次点击和上一次点击的时间间隔小于我们设定的时间间隔，则判定此次点击为暴力点击，什么都不做</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 否则我们判定此次点击为正常点击，button正常处理事件</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 记录上次点击的时间戳</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.ine_lastTimeClickTimestamp = currentTimeClickTimestamp;</span><br><span class=\"line\">            </span><br><span class=\"line\">            [<span class=\"keyword\">self</span> ine_sendAction:action to:target forEvent:event];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_sendAction:action to:target forEvent:event];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_lastTimeClickTimestamp:(<span class=\"built_in\">NSTimeInterval</span>)ine_lastTimeClickTimestamp &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_lastTimeClickTimestamp&quot;</span>, @(ine_lastTimeClickTimestamp), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSTimeInterval</span>)ine_lastTimeClickTimestamp &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_lastTimeClickTimestamp&quot;</span>) doubleValue];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、刷新TableView、CollectionView时，自动判断是否该显示暂无数据\"><a href=\"#2、刷新TableView、CollectionView时，自动判断是否该显示暂无数据\" class=\"headerlink\" title=\"2、刷新TableView、CollectionView时，自动判断是否该显示暂无数据\"></a>2、刷新<code>TableView</code>、<code>CollectionView</code>时，自动判断是否该显示暂无数据</h4><p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/1200-20220718103053060.png\" alt=\"img\"></p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// UITableView+PromptImage.h</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UITableView</span> (<span class=\"title\">INEPromptImage</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 提示图的名字</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *ine_promptImageName;</span><br><span class=\"line\"><span class=\"comment\">/// 提示文本</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"built_in\">NSString</span> *ine_promptText;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 点击提示图的回调</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">copy</span>) <span class=\"type\">void</span>(^ine_didTapPromptImage)(<span class=\"type\">void</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 不使用该分类里的这套判定规则</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"type\">BOOL</span> ine_dontUseThisCategory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// UITableView+PromptImage.m</span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;UITableView+INEPromptImage.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&lt;objc/runtime.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">UITableView</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 已经调用过reloadData方法了</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">assign</span>) <span class=\"type\">BOOL</span> ine_hasInvokedReloadData;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提示图</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">UIButton</span> *ine_promptImageView;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">UITableView</span> (<span class=\"title\">INEPromptImage</span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\">+ (<span class=\"type\">void</span>)load &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">dispatch_once_t</span> onceToken;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> methodSwizzlingWithOriginalSelector:<span class=\"keyword\">@selector</span>(reloadData) swizzledSelector:<span class=\"keyword\">@selector</span>(ine_reloadData)];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_reloadData &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] isEqual:[<span class=\"built_in\">UITableView</span> <span class=\"keyword\">class</span>]] &amp;&amp; !<span class=\"keyword\">self</span>.ine_dontUseThisCategory) &#123;<span class=\"comment\">// 防止替换掉UITableView类簇里子类方法的实现</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_reloadData];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.ine_hasInvokedReloadData) &#123;<span class=\"comment\">// 而是只在请求数据完成后，调用reloadData刷新界面时才处理提示图的显隐</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            [<span class=\"keyword\">self</span> ine_handlePromptImage];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// tableView第一次加载的时候会自动调用一下reloadData方法，这一次调用我们不处理提示图的显隐</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">self</span>.ine_hasInvokedReloadData = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_reloadData];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark - private method</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 提示图的显隐</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_handlePromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span> ine_dataIsEmpty]) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_showPromptImage];</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span> ine_hidePromptImage];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断请求到的数据是否为空</span></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)ine_dataIsEmpty &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 获取分区数</span></span><br><span class=\"line\">    <span class=\"built_in\">NSInteger</span> sections = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"keyword\">self</span>.dataSource respondsToSelector:<span class=\"keyword\">@selector</span>(numberOfSectionsInTableView:)]) &#123;<span class=\"comment\">// 如果外界实现了该方法，则读取外界提供的分区数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sections = [<span class=\"keyword\">self</span> numberOfSections];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 如果外界没实现该方法，系统不是会自动给我们返回一个分区嘛</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        sections = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sections == <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 分区数为0，说明数据为空</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 分区数不为0，则需要判断每个分区下的行数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; sections; i ++) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 获取各个分区的行数</span></span><br><span class=\"line\">        <span class=\"built_in\">NSInteger</span> rows = [<span class=\"keyword\">self</span> numberOfRowsInSection:i];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rows != <span class=\"number\">0</span>) &#123;<span class=\"comment\">// 但凡有一个分区下的行数不为0，说明数据不为空</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果所有分区下的行数都为0，才说明数据为空</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">YES</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 显示提示图</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_showPromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.ine_promptImageView == <span class=\"literal\">nil</span>) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView = [[<span class=\"built_in\">UIButton</span> alloc] initWithFrame:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">60</span>, <span class=\"number\">90</span>)];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.backgroundColor = [<span class=\"built_in\">UIColor</span> clearColor];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.contentMode = <span class=\"built_in\">UIViewContentModeCenter</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.userInteractionEnabled = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.adjustsImageWhenHighlighted = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView setTitleColor:Color_With_RGB(<span class=\"number\">170</span>, <span class=\"number\">170</span>, <span class=\"number\">170</span>, <span class=\"number\">1</span>) forState:(<span class=\"built_in\">UIControlStateNormal</span>)];</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_promptImageView.titleLabel.font = [<span class=\"built_in\">UIFont</span> systemFontOfSize:<span class=\"number\">12</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (String_Is_Empty(<span class=\"keyword\">self</span>.ine_promptText)) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">self</span>.ine_promptText = <span class=\"string\">@&quot;暂无数据&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView setTitle:<span class=\"keyword\">self</span>.ine_promptText forState:(<span class=\"built_in\">UIControlStateNormal</span>)];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.ine_promptImageName.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">self</span>.ine_promptImageName = <span class=\"string\">@&quot;BaseProject_NoDataPromptImage&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView setImage:[<span class=\"built_in\">UIImage</span> imageNamed:<span class=\"keyword\">self</span>.ine_promptImageName] forState:(<span class=\"built_in\">UIControlStateNormal</span>)];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView layoutImageAndTitle:(ImageAndTitleLayoutStyleImageOnLabel) imageTitleSpace:<span class=\"number\">5</span>];</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"built_in\">UITapGestureRecognizer</span> *tapGestureRecognizer = [[<span class=\"built_in\">UITapGestureRecognizer</span> alloc] initWithTarget:<span class=\"keyword\">self</span> action:<span class=\"keyword\">@selector</span>(ine_didTapPromptImage:)];</span><br><span class=\"line\">        [<span class=\"keyword\">self</span>.ine_promptImageView addGestureRecognizer:tapGestureRecognizer];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.backgroundView = <span class=\"keyword\">self</span>.ine_promptImageView;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 隐藏提示图</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_hidePromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">self</span>.backgroundView = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 点击提示图的回调</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)ine_didTapPromptImage:(<span class=\"built_in\">UITapGestureRecognizer</span> *)tapGestureRecognizer &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.ine_didTapPromptImage) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ine_didTapPromptImage();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">pragma</span> mark - setter, getter</span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_hasInvokedReloadData:(<span class=\"type\">BOOL</span>)ine_hasInvokedReloadData &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_hasInvokedReloadData&quot;</span>, @(ine_hasInvokedReloadData), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)ine_hasInvokedReloadData &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_hasInvokedReloadData&quot;</span>) boolValue];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_promptImageView:(<span class=\"built_in\">UIImageView</span> *)ine_promptImageView &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptImageView&quot;</span>, ine_promptImageView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">UIImageView</span> *)ine_promptImageView &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptImageView&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_promptText:(<span class=\"built_in\">NSString</span> *)ine_promptText &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptText&quot;</span>, ine_promptText, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)ine_promptText &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptText&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_promptImageName:(<span class=\"built_in\">NSString</span> *)ine_promptImageName &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptImageName&quot;</span>, ine_promptImageName, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)ine_promptImageName &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_promptImageName&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_didTapPromptImage:(<span class=\"type\">void</span> (^)(<span class=\"type\">void</span>))ine_didTapPromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_didTapPromptImage&quot;</span>, ine_didTapPromptImage, OBJC_ASSOCIATION_COPY);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span> (^)(<span class=\"type\">void</span>))ine_didTapPromptImage &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_didTapPromptImage&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setine_dontUseThisCategory:(<span class=\"type\">BOOL</span>)ine_dontUseThisCategory &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    objc_setAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_dontUseThisCategory&quot;</span>, @(ine_dontUseThisCategory), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">BOOL</span>)ine_dontUseThisCategory &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> [objc_getAssociatedObject(<span class=\"keyword\">self</span>, <span class=\"string\">@&quot;ine_dontUseThisCategory&quot;</span>) boolValue];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl5ahys8f0000mcfya1l14aqe","tag_id":"cl5ahys8l0001mcfy5afi7acf","_id":"cl5ahys8p0003mcfyhsssaevq"},{"post_id":"cl4y1tfwm00002cfy9dri58wq","tag_id":"cl5ahys8o0002mcfy3485gbqv","_id":"cl5ahys8q0005mcfy5e7hai8s"},{"post_id":"cl582bsyi00007pfy2r7df1gg","tag_id":"cl5ahys8o0002mcfy3485gbqv","_id":"cl5ahys8q0007mcfy1os8d25p"},{"post_id":"cl481yqwy000336fy52h5hp7d","tag_id":"cl5ahys8o0002mcfy3485gbqv","_id":"cl5ahys8r0008mcfy3ly4exzp"},{"post_id":"cl481yqwv000136fy4lk172zm","tag_id":"cl5apnc660000vmfy1u32f910","_id":"cl5apnc690001vmfycq5n5ytd"},{"post_id":"cl5g66h3j0000ed2rhi1k2wow","tag_id":"cl5g66h3n0001ed2r5gvyctfj","_id":"cl5g66h3q0002ed2r8fgk3n5l"},{"post_id":"cl5jj18oy00002w2rgwswgs14","tag_id":"cl5ahys8l0001mcfy5afi7acf","_id":"cl5jj18p100012w2rf8yl2c2n"},{"post_id":"cl5kjln5c0000hz2r6yd191ta","tag_id":"cl5ahys8l0001mcfy5afi7acf","_id":"cl5kjln5i0001hz2rhy2yb8a3"},{"post_id":"cl5q61nbf00001rfybmnqbjku","tag_id":"cl5ahys8l0001mcfy5afi7acf","_id":"cl5q61nbk00011rfy7jhndkt4"}],"Tag":[{"name":"技术","_id":"cl481yqx0000436fy4yl1hvfi"},{"name":"Runtime系列","_id":"cl5ahys8l0001mcfy5afi7acf"},{"name":"内存管理系列","_id":"cl5ahys8o0002mcfy3485gbqv"},{"name":"博客","_id":"cl5apnc660000vmfy1u32f910"},{"name":"RunLoop","_id":"cl5g66h3n0001ed2r5gvyctfj"}]}}