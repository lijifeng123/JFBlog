{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by 下午3.31.26.svg","path":"images/cc-by 下午3.31.26.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b4e9149442e77bb97f61ded2e3801f8918022788","modified":1654671315642},{"_id":"source/CNAME","hash":"f43e0f14d22cd3208184e6982f5aeb3f2cfe5ed8","modified":1652455899210},{"_id":"source/_posts/.DS_Store","hash":"1075ee21affc471a6b247441b332194aa305a671","modified":1656645212876},{"_id":"source/_posts/hello-world.md","hash":"50b5764dbca53724e4c6b411bedba2bb54bf5e5f","modified":1654588332334},{"_id":"source/_posts/理解指针.md","hash":"20c2f9dc704a0ab0f62165cb8ca7685e98b4fcab","modified":1655892823037},{"_id":"source/about/index.md","hash":"8563513b318b033597b33994ae4bdd670b96c91a","modified":1654833464229},{"_id":"source/tags/index.md","hash":"10ad19761cefe3c79994a1c707c3949c58ced5b2","modified":1652581034025},{"_id":"source/uploads/.DS_Store","hash":"558099c2317749b8bb3969038346dd1e12e54bb9","modified":1654827959652},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1652425454387},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1652425454387},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1652425454387},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1652425454391},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1652425454390},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1652425454391},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1652425454391},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1652425454391},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1652425454399},{"_id":"themes/next/_config.yml","hash":"5db18299698fc85480fc03fcbfff916ea4c71b18","modified":1652581168389},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1652425454392},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1652425454440},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1652425454388},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1652425454388},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1652425454389},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1652425454389},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1652425454389},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1652425454389},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1652425454390},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1652425454390},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1652425454390},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1652425454390},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1652425454390},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1652425454393},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1652425454393},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1652425454393},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1652425454394},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1652425454394},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1652425454394},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1652425454394},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1652425454395},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1652425454399},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1652425454395},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1652425454400},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1652425454400},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1652425454400},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1652425454401},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1652425454400},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1652425454401},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1652425454402},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1652425454402},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1652425454401},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1652425454403},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1652425454403},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1652425454403},{"_id":"themes/next/languages/tr.yml","hash":"2b041eeb8bd096f549464f191cfc1ea0181daca4","modified":1652425454404},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1652425454403},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1652425454404},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1652425454405},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1652425454404},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1652425454405},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1652425454405},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1652425454402},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1652425454406},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1652425454405},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1652425454439},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1652425454438},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1652425454439},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1652425454439},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1652425454440},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1652425454388},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1652425454472},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1652425454388},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1652425454389},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1652425454396},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1652425454389},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1652425454397},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1652425454438},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1652425454397},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1652425454397},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1652425454398},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1652425454398},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1652425454399},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1652425454398},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1652425454399},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1652425454396},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1652425454396},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1652425454395},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1652425454406},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1652425454407},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1652425454407},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1652425454407},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1652425454408},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1652425454411},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1652425454412},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1652425454417},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1652425454416},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1652425454417},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1652425454422},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1652425454424},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1652425454423},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1652425454426},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1652425454429},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1652425454430},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1652425454396},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1652425454440},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1652425454444},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1652425454453},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1652425454445},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1652425454458},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1652425454458},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1652425454458},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1652425454471},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1652425454465},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1652425454459},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1652425454472},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1652425454473},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1652425454472},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1652425454473},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1652425454473},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1652425454474},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1652425454473},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1652425454474},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1652425454474},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1652425454474},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1652425454475},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1652425454509},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1652425454515},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1652425454516},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1652425454516},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1652425454516},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1652425454517},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1652425454516},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1652425454517},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1652425454517},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1652425454518},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1652425454518},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1652425454518},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1652425454520},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1652425454521},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1652425454521},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1652425454521},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1652425454522},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1652425454521},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1652425454524},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1652425454523},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1652425454526},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1652425454525},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1652425454409},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1652425454408},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1652425454409},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1652425454409},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1652425454410},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1652425454410},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1652425454411},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1652425454410},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1652425454412},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1652425454411},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1652425454413},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1652425454413},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1652425454413},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1652425454414},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1652425454414},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1652425454414},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1652425454415},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1652425454416},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1652425454423},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1652425454422},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1652425454431},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1652425454423},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1652425454423},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1652425454423},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1652425454425},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1652425454424},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1652425454426},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1652425454425},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1652425454425},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1652425454426},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1652425454428},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1652425454427},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1652425454427},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1652425454428},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1652425454428},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1652425454430},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1652425454429},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1652425454430},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1652425454432},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1652425454431},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1652425454430},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1652425454432},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1652425454434},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1652425454434},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1652425454435},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1652425454432},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1652425454435},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1652425454441},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1652425454436},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1652425454438},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1652425454441},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1652425454441},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1652425454442},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1652425454442},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1652425454442},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1652425454443},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1652425454443},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1652425454443},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1652425454444},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1652425454444},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1652425454514},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1652425454514},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1652425454514},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1652425454515},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1652425454524},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1652425454515},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1652425454525},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1652425454530},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1652425454531},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1652425454475},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1652425454476},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1652425454475},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1652425454480},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1652425454493},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1652425454504},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1652425454493},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1652425454503},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1652425454504},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1652425454505},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1652425454505},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1652425454506},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1652425454506},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1652425454508},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1652425454509},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1652425454511},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1652425454510},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1652425454511},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1652425454511},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1652425454511},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1652425454512},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1652425454512},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1652425454512},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1652425454513},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1652425454513},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1652425454527},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1652425454513},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1652425454513},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1652425454513},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1652425454476},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1652425454528},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1652425454476},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1652425454477},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1652425454477},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1652425454477},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1652425454477},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1652425454478},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1652425454478},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1652425454478},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1652425454478},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1652425454479},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1652425454480},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1652425454480},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1652425454481},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1652425454480},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1652425454481},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1652425454481},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1652425454490},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1652425454491},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1652425454490},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1652425454491},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1652425454491},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1652425454491},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1652425454492},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1652425454492},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1652425454492},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1652425454493},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1652425454492},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1652425454495},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1652425454494},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1652425454503},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1652425454503},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1652425454495},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1652425454504},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1652425454505},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1652425454504},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1652425454505},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1652425454506},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1652425454507},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1652425454507},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1652425454507},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1652425454507},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1652425454508},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1652425454508},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1652425454527},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1652425454529},{"_id":"public/about/index.html","hash":"2f2aa7e234a776e5d89ca3746cc2e07d755fbf6d","modified":1657089499873},{"_id":"public/tags/index.html","hash":"b067d96d929e8573b801184c149c7fc977b58319","modified":1657089499873},{"_id":"public/archives/index.html","hash":"16867574f53e09244eabb8f252fb44c9444d70c7","modified":1657089499873},{"_id":"public/archives/2022/index.html","hash":"22c1c550b022c6ca265b2982828cf553542b656f","modified":1657089499873},{"_id":"public/archives/2022/05/index.html","hash":"6c40d565722d53345f5bb25b782618072526ad90","modified":1657089499873},{"_id":"public/archives/2022/06/index.html","hash":"9ef1255fd615ca54f96583af348a718ecd6695f7","modified":1657089499873},{"_id":"public/tags/技术/index.html","hash":"693808dd4ed57c59c3edba48176d18185e17392b","modified":1657089499873},{"_id":"public/index.html","hash":"7700864a29452cc36e43ae5208393689f3fdc0cf","modified":1657089499873},{"_id":"public/2022/06/07/理解指针/index.html","hash":"29ae2d0eba6531140586079112ea0ec69a306d55","modified":1657089499873},{"_id":"public/2022/05/16/hello-world/index.html","hash":"609ba34878586fbde4a8e932660067f791637e68","modified":1657089499873},{"_id":"public/CNAME","hash":"f43e0f14d22cd3208184e6982f5aeb3f2cfe5ed8","modified":1654841605240},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1654841605240},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1654841605240},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1654841605240},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1654841605240},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1654841605240},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1654841605240},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1654841605240},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1654841605240},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1654841605240},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1654841605240},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1654841605240},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1654841605240},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1654841605240},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1654841605240},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1654841605240},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1654841605240},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1654841605240},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1654841605240},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1654841605240},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1654841605240},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1654841605240},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1654841605240},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1654841605240},{"_id":"public/css/main.css","hash":"f57e50bca44cf451c6f39caca3d4d6db5c1e97ec","modified":1654841605240},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1654841605240},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1654841605240},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1654841605240},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1654841605240},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1654841605240},{"_id":"source/_posts/内存管理一.md","hash":"c1780244c30ede203d0047439f89419ed600a729","modified":1657087360732},{"_id":"public/2022/06/22/内存管理一/index.html","hash":"9eefd53d40619b2256e93b13b892cec054550ac6","modified":1657089499873},{"_id":"themes/next/layout/.DS_Store","hash":"8cff284546b7e636fcdb25a8f0c5849c6634f6bb","modified":1657087459665},{"_id":"themes/next/docs/.DS_Store","hash":"c97624fc53ed4478299657965a0ea3a64e0820b7","modified":1657087454659},{"_id":"themes/next/source/.DS_Store","hash":"c74e0d5e1f05bc90d5c9141a1f67f65693f730f8","modified":1657087459667},{"_id":"themes/next/layout/_partials/.DS_Store","hash":"b36802665beb1a44d0141f7d69bfe54bfab25193","modified":1657087459669},{"_id":"themes/next/layout/_scripts/.DS_Store","hash":"70475c98f050de840e9e85a1e0ce31805b570a2b","modified":1657087454662},{"_id":"themes/next/scripts/.DS_Store","hash":"cada1f9f4a02bbfdc2ca0ede9a6d231ff3127d63","modified":1657087459664},{"_id":"themes/next/.DS_Store","hash":"80caf8113bc0745a2967c6c2a4d67f46ad4d2394","modified":1657087459670},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"35936b49b976bd4adf5c52397c3dea4151a7ac51","modified":1657087459668},{"_id":"themes/next/source/images/cc-by 下午3.31.26.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1652425454518},{"_id":"themes/next/source/css/.DS_Store","hash":"d81525b890c2a770b7b8323930cfe91dd547cc62","modified":1657087459663},{"_id":"themes/next/source/images/.DS_Store","hash":"46746c5e99737c05634372ba5ed0e83c5d5f76a6","modified":1656487971596},{"_id":"themes/next/source/lib/.DS_Store","hash":"7e2d86f40e97c75ff97072824226e105088c57fc","modified":1657087459666},{"_id":"public/images/cc-by 下午3.31.26.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1656645635407},{"_id":"source/_posts/内存管理二.md","hash":"7fe1a412dc2f20057bd24d5bf3a7ca25adf71ff1","modified":1657087360732},{"_id":"public/archives/2022/07/index.html","hash":"24f96319ff9f7454e45df94e60b9c8431ec2f902","modified":1657089499873},{"_id":"public/2022/07/05/内存管理二/index.html","hash":"4ea83510e422db52b10957bb058d6acd0946c10f","modified":1657089499873},{"_id":"source/_posts/【Runtime系列】一、Runtime是什么？.md","hash":"d4eedeaf84f3816e51d7ed99f860a27cb721a465","modified":1657089048849},{"_id":"source/_posts/【Runtime系列】Runtime是什么？.md","hash":"d4eedeaf84f3816e51d7ed99f860a27cb721a465","modified":1657089048849},{"_id":"public/2022/07/06/【Runtime系列】Runtime是什么？/index.html","hash":"d7ebec32ccf2ee09eb80cd64016c0c530f15a182","modified":1657089499873}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2022-05-15T02:15:52.000Z","comments":0,"_content":"\n\n\n用blog记录知识，记录生活。\n\n技术要严谨，生活要精彩。\n\n![tangsan](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/tangsan.png)","source":"about/index.md","raw":"---\ntitle: about\ndate: 2022-05-15 10:15:52\ncomments: false\n---\n\n\n\n用blog记录知识，记录生活。\n\n技术要严谨，生活要精彩。\n\n![tangsan](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/tangsan.png)","updated":"2022-06-10T03:57:44.229Z","path":"about/index.html","layout":"page","_id":"cl481yqwr000036fy16gbfyxn","content":"<p>用blog记录知识，记录生活。</p>\n<p>技术要严谨，生活要精彩。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/tangsan.png\" alt=\"tangsan\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>用blog记录知识，记录生活。</p>\n<p>技术要严谨，生活要精彩。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/tangsan.png\" alt=\"tangsan\"></p>\n"},{"title":"tags","date":"2022-05-15T02:14:38.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-05-15 10:14:38\ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-05-15T02:17:14.025Z","path":"tags/index.html","layout":"page","_id":"cl481yqwx000236fy0q3ibymu","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","date":"2022-05-15T16:00:00.000Z","_content":"\nhexo创建发布博客流程\n\n<!--more-->\n\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2022.5.16\ntags: 技术\n---\n\nhexo创建发布博客流程\n\n<!--more-->\n\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2022-06-07T07:52:12.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl481yqwv000136fy4lk172zm","content":"<p>hexo创建发布博客流程</p>\n<span id=\"more\"></span>\n\n\n\n<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>hexo创建发布博客流程</p>","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>"},{"title":"理解指针","date":"2022-06-07T07:54:39.000Z","_content":"\n### 一、引言：\n\n日常开发中，我们经常遇到指针，同时指针也是C语言里极为重要的一个知识点，今天我们就来把它彻底弄明白。\n\n<!--more-->\n\n\n\n### 二：正文\n\n#### 变量与变量值:\n\n```\n    //数据类型（int） 变量名（a） = 值（10）\n    int a = 10;\n```\n\n变量：变量是一个**抽象概念**，可以理解为允许存放数据的空间。当声明一个变量，计算机就会分配空间存放数据。变量可以通过变量名访问。\n\n变量值：变量里面存储的数据即为变量值，变量值可以为数值、字符等类型。\n\n\n\n#### 指针：\n\n**指针：**是一种<u>变量</u>，它的值是一个**内存地址**。（从三个方面分析指针：指针的类型、指针所指向的类型、指针的值）\n\n**指针类型：**`数据类型 *`，int *：整形数据类型的指针； char *： 字符数据类型的指针； void *：无数据类型的指针；等等...\n\n**取地址运算：**`&变量 ` ，取得的结果是变量的**首**地址，是一个**值**（eg：x10db5640）。\n\n**取变量运算：**`*指针变量`，取得的结果是一个变量。\n\n\n\n1.整形数据类型指针：\n\n```\n- (void)testIntExample {\n    \n    //int类型变量a赋值为10\n    int a = 10;\n    //int*类型的指针变量b赋值为&a\n    int *b = &a;\n    //int类型变量c赋值为*b\n    int c = *b;\n    \n    printf(\"变量b---值：%d 地址：%p\",*b,b);\n    printf(\"变量c---值：%d 地址：%p\",c,&c);\n    \n    打印结果：\n    变量b---值：10 地址：0x10db5641c\n    变量c---值：10 地址：0x10db5640c\n}\n```\n\n解读：指针变量b的类型是：int *，指针变量b所指向的变量类型是int类型，b的值是一个地址：0x10db5641c。\n\n\n\n2.字符数据类型指针：\n\n```\n- (void)testCharExample {\n\n    char *a = \"blog\";\n    char *b = a;\n    char *c = b;\n    \n    printf(\"变量b所指变量的值：%s 变量b所指变量的首地址：%p 变量b的地址：%p\",b,b,&b);\n    printf(\"变量c所指变量的值：%s 变量c所指变量的首地址：%p 变量c的地址：%p\",c,c,&c);\n    \n    打印结果：\n\t\t变量b所指变量的值：blog 变量b所指变量的首地址：0x10a951bfc 变量b的地址：0x10a76f410\n\t\t变量c所指变量的值：blog 变量c所指变量的首地址：0x10a951bfc 变量c的地址：0x10a76f408\n}\n```\n\n解读：char*类型指针 变量a 指向char类型变量blog，a的值是 变量blog的首地址0x10a951bfc。\n\n\n\n3.指针与数组：\n\n```\n- (void)testArrayExample {\n    \n    int arr[] = {4,12,34,6,7,788};\n    int *a = arr;//得到的是arr的首地址\n    int *b = &arr[0];//得到的是arr数组第一个元素的地址\n    int *c = arr + 1;//得到的是arr数组第二个元素的地址\n    int *d = &arr[0] + 1;//得到的是arr数组第二个元素的地址\n\n    printf(\"a:%p---b:%p\",a,b);//可以得出a和b是相等的\n    printf(\"c:%p---d:%p\",c,d);//可以得出c和d是相等的\n    printf(\"num:%ld\",c-a);//可以得出c和a之间有几个元素\n    printf(\"数组中第一个元素的字节数：%ld\",sizeof(arr[0]));//获取数组第一个元素的字节数\n    \n    *c = 99;\n    printf(\"arr+1: %d---%p\",*c,c);\n\n    //打印结果：\n    a:0x106f54410---b:0x106f54410\n    c:0x106f54414---d:0x106f54414\n    num:1\n    数组中第一个元素的字节数：4\n    arr+1: 99---0x106f54414\n}\n```\n\n解读：\n\n1）arr 表示arr[]数组的首地址\n\n2）指针c - 指针a，能获取到两个指针之间有几个元素\n\n3）指针变量加减一个整数,p(指针)(+/-)n(整数)计算方式为：指针地址 (+/-) n * 变量占有的字节数\n\n4）sizeof的用法：\n\n- 每种类型的数据在内存单元中占有的字节数是固定的,因此sizeof(arr)/sizeof(arr[0]) = 数组的元素的个数\n- sizeof(arr)：获取的是数组总共占有多少字节\n- sizeof(arr[0])：获取的是数组中一个元素占有的字节数\n\n5）数组变量保存的是地址,但数组变量中保存的地址是不能改变的,注意说的是指针地址不能变,但是指针指向的值是可以变的,因此数组变量应称为指针常量，可以改变数组中地址中存储的值。\n\n\n\n#### OC 应用场景示例：\n\n```\n//采用这种方式传参，可以获取到error的值\n- (void)testErrorExample {\n\n    NSError *err = nil;\n    [self handleResponseCode:400 error:&err];\n    \n    NSLog(@\"err---%p--%@\",err,err);\n    \n    //指针运算符&和*是从右往左运算,他们的优先级相同。*&err和err一样。\n    NSLog(@\"*&err---%p--%@\",*&err,*&err);\n    \n    //打印结果\n    err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 \"(null)\" UserInfo={data=99}\n    *&err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 \"(null)\" UserInfo={data=99}\n    \n}\n\n- (void)handleResponseCode:(NSInteger)code error:(NSError **)error{\n    if (code != 0) {\n        *error = [NSError errorWithDomain:NSCocoaErrorDomain code:100 userInfo:@{@\"data\":@\"99\"}];\n    }\n}\n```\n\n\n\n### 三、扩展\n\n1. 操作系统分为32位和64位，32位的最多只能支持4GB的内存，因为计算机底层并不使用十进制，使用的是二进制，32位的二进制只能支持4G个编号，这意味着操作系统只能为4GB的内存单元编号，因此32位的操作系统最多只能支持4GB的内存，多余的内存不会有编号,因此无法将数据存入这些内存单元中。\n\n2. 指针存储于栈区，不同数据类型的指针大小都相等，因为他们的值都是一个地址，并且长度也相同。32位操作系统中，指针大小是4个字节，64位操作系统中指针大小是8个字节。\n\n   ```\n   //下面代码是在64位操作系统演示\n   -(void)testGetPointerNum {\n       \n       char *a = \"myBlog\";\n       \n       int num1 = 1234325;\n       int *b = &num1;\n       \n       double num2 = 3232.434;\n       double *c = &num2;\n       \n       printf(\"char *类型指针变量a所占字节数：%ld\",sizeof(a));\n       printf(\"int *类型指针变量b所占字节数：%ld\",sizeof(b));\n       printf(\"double *类型指针变量c所占字节数：%ld\",sizeof(c));\n       \n       //打印结果\n       char *类型指针变量a所占字节数：8\n       int *类型指针变量b所占字节数：8\n       double *类型指针变量c所占字节数：8\n   }\n   ```\n\n3. 结构体数据类型变量的大小：`对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。`\n\n   ```\n   - (void)testStructExample {\n       \n       struct Data1{\n           int a;\n           char b;\n           char c;\n       };\n       \n       struct Data2{\n           char c;\n           int a;\n           char b;\n       };\n       \n       struct Data1 p1;\n       p1.a = 1;\n       p1.b = 'd';\n       p1.c = 'f';\n       \n       struct Data2 p2;\n       p2.a = 1;\n       p2.b = 'd';\n       p2.c = 'f';\n       \n       printf(\"p1结构体占用的字节个数为：%ld\",sizeof(p1));\n       printf(\"p2结构体占用的字节个数为：%ld\",sizeof(p2));\n       \n       //打印结果\n       p1结构体占用的字节个数为：8\n       p2结构体占用的字节个数为：12\n   }\n   ```\n\n   解读：\n\n   ![结构体内存结构示意图](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n   你可以看到，在 Data1 中，首先是 int 类型的 a 变量，占用了第一个存储单元，然后 b 和 c 占用了第二个存储单元的前两个字节。再看 Data2，由于 Data2 不同于 Data1 的字段顺序，b 占用了第一个存储单元的第一个字节，剩余的 3 个字节不够存放一个 int 类型变量的，所以按照上面我们讲的规则“当本存储单元不够安放的时候，就从下个存储单元的头部开始安放”， a 变量就单独占用了第二个存储单元，c 自己占用第三个存储单元的第一个字节。所以，虽然在数据表示上，Data1 和 Data2 是等价的，可 Data2 却占用了更多的存储空间，相比于 Data1 造成了 50% 的空间浪费。由此可见，在设计结构体的时候，不仅要设计新的结构体类型中所包含的数据字段，还需要关注各个字段之间的顺序排布。\n\n4. 32位操作系统内存与地址分布图：\n\n![内存空间布局](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png)\n\n5. 64位操作系统常用数据类型占用的内存大小：\n\n   |     常用数据类型      | 占用内存大小（字节） |\n   | :-------------------: | :------------------: |\n   |  char、unsigned char  |          1           |\n   |         bool          |          1           |\n   | short、unsigned short |          2           |\n   |   int、unsigned int   |          4           |\n   |  long、unsigned long  |          8           |\n   |         float         |          4           |\n   |        double         |          8           |\n   |         指针          |          8           |\n\n","source":"_posts/理解指针.md","raw":"---\ntitle: 理解指针\ndate: 2022-06-07 15:54:39\ntags: 技术\n---\n\n### 一、引言：\n\n日常开发中，我们经常遇到指针，同时指针也是C语言里极为重要的一个知识点，今天我们就来把它彻底弄明白。\n\n<!--more-->\n\n\n\n### 二：正文\n\n#### 变量与变量值:\n\n```\n    //数据类型（int） 变量名（a） = 值（10）\n    int a = 10;\n```\n\n变量：变量是一个**抽象概念**，可以理解为允许存放数据的空间。当声明一个变量，计算机就会分配空间存放数据。变量可以通过变量名访问。\n\n变量值：变量里面存储的数据即为变量值，变量值可以为数值、字符等类型。\n\n\n\n#### 指针：\n\n**指针：**是一种<u>变量</u>，它的值是一个**内存地址**。（从三个方面分析指针：指针的类型、指针所指向的类型、指针的值）\n\n**指针类型：**`数据类型 *`，int *：整形数据类型的指针； char *： 字符数据类型的指针； void *：无数据类型的指针；等等...\n\n**取地址运算：**`&变量 ` ，取得的结果是变量的**首**地址，是一个**值**（eg：x10db5640）。\n\n**取变量运算：**`*指针变量`，取得的结果是一个变量。\n\n\n\n1.整形数据类型指针：\n\n```\n- (void)testIntExample {\n    \n    //int类型变量a赋值为10\n    int a = 10;\n    //int*类型的指针变量b赋值为&a\n    int *b = &a;\n    //int类型变量c赋值为*b\n    int c = *b;\n    \n    printf(\"变量b---值：%d 地址：%p\",*b,b);\n    printf(\"变量c---值：%d 地址：%p\",c,&c);\n    \n    打印结果：\n    变量b---值：10 地址：0x10db5641c\n    变量c---值：10 地址：0x10db5640c\n}\n```\n\n解读：指针变量b的类型是：int *，指针变量b所指向的变量类型是int类型，b的值是一个地址：0x10db5641c。\n\n\n\n2.字符数据类型指针：\n\n```\n- (void)testCharExample {\n\n    char *a = \"blog\";\n    char *b = a;\n    char *c = b;\n    \n    printf(\"变量b所指变量的值：%s 变量b所指变量的首地址：%p 变量b的地址：%p\",b,b,&b);\n    printf(\"变量c所指变量的值：%s 变量c所指变量的首地址：%p 变量c的地址：%p\",c,c,&c);\n    \n    打印结果：\n\t\t变量b所指变量的值：blog 变量b所指变量的首地址：0x10a951bfc 变量b的地址：0x10a76f410\n\t\t变量c所指变量的值：blog 变量c所指变量的首地址：0x10a951bfc 变量c的地址：0x10a76f408\n}\n```\n\n解读：char*类型指针 变量a 指向char类型变量blog，a的值是 变量blog的首地址0x10a951bfc。\n\n\n\n3.指针与数组：\n\n```\n- (void)testArrayExample {\n    \n    int arr[] = {4,12,34,6,7,788};\n    int *a = arr;//得到的是arr的首地址\n    int *b = &arr[0];//得到的是arr数组第一个元素的地址\n    int *c = arr + 1;//得到的是arr数组第二个元素的地址\n    int *d = &arr[0] + 1;//得到的是arr数组第二个元素的地址\n\n    printf(\"a:%p---b:%p\",a,b);//可以得出a和b是相等的\n    printf(\"c:%p---d:%p\",c,d);//可以得出c和d是相等的\n    printf(\"num:%ld\",c-a);//可以得出c和a之间有几个元素\n    printf(\"数组中第一个元素的字节数：%ld\",sizeof(arr[0]));//获取数组第一个元素的字节数\n    \n    *c = 99;\n    printf(\"arr+1: %d---%p\",*c,c);\n\n    //打印结果：\n    a:0x106f54410---b:0x106f54410\n    c:0x106f54414---d:0x106f54414\n    num:1\n    数组中第一个元素的字节数：4\n    arr+1: 99---0x106f54414\n}\n```\n\n解读：\n\n1）arr 表示arr[]数组的首地址\n\n2）指针c - 指针a，能获取到两个指针之间有几个元素\n\n3）指针变量加减一个整数,p(指针)(+/-)n(整数)计算方式为：指针地址 (+/-) n * 变量占有的字节数\n\n4）sizeof的用法：\n\n- 每种类型的数据在内存单元中占有的字节数是固定的,因此sizeof(arr)/sizeof(arr[0]) = 数组的元素的个数\n- sizeof(arr)：获取的是数组总共占有多少字节\n- sizeof(arr[0])：获取的是数组中一个元素占有的字节数\n\n5）数组变量保存的是地址,但数组变量中保存的地址是不能改变的,注意说的是指针地址不能变,但是指针指向的值是可以变的,因此数组变量应称为指针常量，可以改变数组中地址中存储的值。\n\n\n\n#### OC 应用场景示例：\n\n```\n//采用这种方式传参，可以获取到error的值\n- (void)testErrorExample {\n\n    NSError *err = nil;\n    [self handleResponseCode:400 error:&err];\n    \n    NSLog(@\"err---%p--%@\",err,err);\n    \n    //指针运算符&和*是从右往左运算,他们的优先级相同。*&err和err一样。\n    NSLog(@\"*&err---%p--%@\",*&err,*&err);\n    \n    //打印结果\n    err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 \"(null)\" UserInfo={data=99}\n    *&err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 \"(null)\" UserInfo={data=99}\n    \n}\n\n- (void)handleResponseCode:(NSInteger)code error:(NSError **)error{\n    if (code != 0) {\n        *error = [NSError errorWithDomain:NSCocoaErrorDomain code:100 userInfo:@{@\"data\":@\"99\"}];\n    }\n}\n```\n\n\n\n### 三、扩展\n\n1. 操作系统分为32位和64位，32位的最多只能支持4GB的内存，因为计算机底层并不使用十进制，使用的是二进制，32位的二进制只能支持4G个编号，这意味着操作系统只能为4GB的内存单元编号，因此32位的操作系统最多只能支持4GB的内存，多余的内存不会有编号,因此无法将数据存入这些内存单元中。\n\n2. 指针存储于栈区，不同数据类型的指针大小都相等，因为他们的值都是一个地址，并且长度也相同。32位操作系统中，指针大小是4个字节，64位操作系统中指针大小是8个字节。\n\n   ```\n   //下面代码是在64位操作系统演示\n   -(void)testGetPointerNum {\n       \n       char *a = \"myBlog\";\n       \n       int num1 = 1234325;\n       int *b = &num1;\n       \n       double num2 = 3232.434;\n       double *c = &num2;\n       \n       printf(\"char *类型指针变量a所占字节数：%ld\",sizeof(a));\n       printf(\"int *类型指针变量b所占字节数：%ld\",sizeof(b));\n       printf(\"double *类型指针变量c所占字节数：%ld\",sizeof(c));\n       \n       //打印结果\n       char *类型指针变量a所占字节数：8\n       int *类型指针变量b所占字节数：8\n       double *类型指针变量c所占字节数：8\n   }\n   ```\n\n3. 结构体数据类型变量的大小：`对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。`\n\n   ```\n   - (void)testStructExample {\n       \n       struct Data1{\n           int a;\n           char b;\n           char c;\n       };\n       \n       struct Data2{\n           char c;\n           int a;\n           char b;\n       };\n       \n       struct Data1 p1;\n       p1.a = 1;\n       p1.b = 'd';\n       p1.c = 'f';\n       \n       struct Data2 p2;\n       p2.a = 1;\n       p2.b = 'd';\n       p2.c = 'f';\n       \n       printf(\"p1结构体占用的字节个数为：%ld\",sizeof(p1));\n       printf(\"p2结构体占用的字节个数为：%ld\",sizeof(p2));\n       \n       //打印结果\n       p1结构体占用的字节个数为：8\n       p2结构体占用的字节个数为：12\n   }\n   ```\n\n   解读：\n\n   ![结构体内存结构示意图](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n   你可以看到，在 Data1 中，首先是 int 类型的 a 变量，占用了第一个存储单元，然后 b 和 c 占用了第二个存储单元的前两个字节。再看 Data2，由于 Data2 不同于 Data1 的字段顺序，b 占用了第一个存储单元的第一个字节，剩余的 3 个字节不够存放一个 int 类型变量的，所以按照上面我们讲的规则“当本存储单元不够安放的时候，就从下个存储单元的头部开始安放”， a 变量就单独占用了第二个存储单元，c 自己占用第三个存储单元的第一个字节。所以，虽然在数据表示上，Data1 和 Data2 是等价的，可 Data2 却占用了更多的存储空间，相比于 Data1 造成了 50% 的空间浪费。由此可见，在设计结构体的时候，不仅要设计新的结构体类型中所包含的数据字段，还需要关注各个字段之间的顺序排布。\n\n4. 32位操作系统内存与地址分布图：\n\n![内存空间布局](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png)\n\n5. 64位操作系统常用数据类型占用的内存大小：\n\n   |     常用数据类型      | 占用内存大小（字节） |\n   | :-------------------: | :------------------: |\n   |  char、unsigned char  |          1           |\n   |         bool          |          1           |\n   | short、unsigned short |          2           |\n   |   int、unsigned int   |          4           |\n   |  long、unsigned long  |          8           |\n   |         float         |          4           |\n   |        double         |          8           |\n   |         指针          |          8           |\n\n","slug":"理解指针","published":1,"updated":"2022-06-22T10:13:43.037Z","_id":"cl481yqwy000336fy52h5hp7d","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"一、引言：\"><a href=\"#一、引言：\" class=\"headerlink\" title=\"一、引言：\"></a>一、引言：</h3><p>日常开发中，我们经常遇到指针，同时指针也是C语言里极为重要的一个知识点，今天我们就来把它彻底弄明白。</p>\n<span id=\"more\"></span>\n\n\n\n<h3 id=\"二：正文\"><a href=\"#二：正文\" class=\"headerlink\" title=\"二：正文\"></a>二：正文</h3><h4 id=\"变量与变量值\"><a href=\"#变量与变量值\" class=\"headerlink\" title=\"变量与变量值:\"></a>变量与变量值:</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据类型（int） 变量名（a） = 值（10）</span><br><span class=\"line\">int a = 10;</span><br></pre></td></tr></table></figure>\n\n<p>变量：变量是一个<strong>抽象概念</strong>，可以理解为允许存放数据的空间。当声明一个变量，计算机就会分配空间存放数据。变量可以通过变量名访问。</p>\n<p>变量值：变量里面存储的数据即为变量值，变量值可以为数值、字符等类型。</p>\n<h4 id=\"指针：\"><a href=\"#指针：\" class=\"headerlink\" title=\"指针：\"></a>指针：</h4><p><strong>指针：</strong>是一种<u>变量</u>，它的值是一个<strong>内存地址</strong>。（从三个方面分析指针：指针的类型、指针所指向的类型、指针的值）</p>\n<p><strong>指针类型：</strong><code>数据类型 *</code>，int *：整形数据类型的指针； char *： 字符数据类型的指针； void *：无数据类型的指针；等等…</p>\n<p><strong>取地址运算：</strong><code>&amp;变量 </code> ，取得的结果是变量的<strong>首</strong>地址，是一个<strong>值</strong>（eg：x10db5640）。</p>\n<p><strong>取变量运算：</strong><code>*指针变量</code>，取得的结果是一个变量。</p>\n<p>1.整形数据类型指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testIntExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //int类型变量a赋值为10</span><br><span class=\"line\">    int a = 10;</span><br><span class=\"line\">    //int*类型的指针变量b赋值为&amp;a</span><br><span class=\"line\">    int *b = &amp;a;</span><br><span class=\"line\">    //int类型变量c赋值为*b</span><br><span class=\"line\">    int c = *b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;变量b---值：%d 地址：%p&quot;,*b,b);</span><br><span class=\"line\">    printf(&quot;变量c---值：%d 地址：%p&quot;,c,&amp;c);</span><br><span class=\"line\">    </span><br><span class=\"line\">    打印结果：</span><br><span class=\"line\">    变量b---值：10 地址：0x10db5641c</span><br><span class=\"line\">    变量c---值：10 地址：0x10db5640c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：指针变量b的类型是：int *，指针变量b所指向的变量类型是int类型，b的值是一个地址：0x10db5641c。</p>\n<p>2.字符数据类型指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testCharExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    char *a = &quot;blog&quot;;</span><br><span class=\"line\">    char *b = a;</span><br><span class=\"line\">    char *c = b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;变量b所指变量的值：%s 变量b所指变量的首地址：%p 变量b的地址：%p&quot;,b,b,&amp;b);</span><br><span class=\"line\">    printf(&quot;变量c所指变量的值：%s 变量c所指变量的首地址：%p 变量c的地址：%p&quot;,c,c,&amp;c);</span><br><span class=\"line\">    </span><br><span class=\"line\">    打印结果：</span><br><span class=\"line\">\t\t变量b所指变量的值：blog 变量b所指变量的首地址：0x10a951bfc 变量b的地址：0x10a76f410</span><br><span class=\"line\">\t\t变量c所指变量的值：blog 变量c所指变量的首地址：0x10a951bfc 变量c的地址：0x10a76f408</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：char*类型指针 变量a 指向char类型变量blog，a的值是 变量blog的首地址0x10a951bfc。</p>\n<p>3.指针与数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testArrayExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int arr[] = &#123;4,12,34,6,7,788&#125;;</span><br><span class=\"line\">    int *a = arr;//得到的是arr的首地址</span><br><span class=\"line\">    int *b = &amp;arr[0];//得到的是arr数组第一个元素的地址</span><br><span class=\"line\">    int *c = arr + 1;//得到的是arr数组第二个元素的地址</span><br><span class=\"line\">    int *d = &amp;arr[0] + 1;//得到的是arr数组第二个元素的地址</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;a:%p---b:%p&quot;,a,b);//可以得出a和b是相等的</span><br><span class=\"line\">    printf(&quot;c:%p---d:%p&quot;,c,d);//可以得出c和d是相等的</span><br><span class=\"line\">    printf(&quot;num:%ld&quot;,c-a);//可以得出c和a之间有几个元素</span><br><span class=\"line\">    printf(&quot;数组中第一个元素的字节数：%ld&quot;,sizeof(arr[0]));//获取数组第一个元素的字节数</span><br><span class=\"line\">    </span><br><span class=\"line\">    *c = 99;</span><br><span class=\"line\">    printf(&quot;arr+1: %d---%p&quot;,*c,c);</span><br><span class=\"line\"></span><br><span class=\"line\">    //打印结果：</span><br><span class=\"line\">    a:0x106f54410---b:0x106f54410</span><br><span class=\"line\">    c:0x106f54414---d:0x106f54414</span><br><span class=\"line\">    num:1</span><br><span class=\"line\">    数组中第一个元素的字节数：4</span><br><span class=\"line\">    arr+1: 99---0x106f54414</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：</p>\n<p>1）arr 表示arr[]数组的首地址</p>\n<p>2）指针c - 指针a，能获取到两个指针之间有几个元素</p>\n<p>3）指针变量加减一个整数,p(指针)(+/-)n(整数)计算方式为：指针地址 (+/-) n * 变量占有的字节数</p>\n<p>4）sizeof的用法：</p>\n<ul>\n<li>每种类型的数据在内存单元中占有的字节数是固定的,因此sizeof(arr)/sizeof(arr[0]) = 数组的元素的个数</li>\n<li>sizeof(arr)：获取的是数组总共占有多少字节</li>\n<li>sizeof(arr[0])：获取的是数组中一个元素占有的字节数</li>\n</ul>\n<p>5）数组变量保存的是地址,但数组变量中保存的地址是不能改变的,注意说的是指针地址不能变,但是指针指向的值是可以变的,因此数组变量应称为指针常量，可以改变数组中地址中存储的值。</p>\n<h4 id=\"OC-应用场景示例：\"><a href=\"#OC-应用场景示例：\" class=\"headerlink\" title=\"OC 应用场景示例：\"></a>OC 应用场景示例：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//采用这种方式传参，可以获取到error的值</span><br><span class=\"line\">- (void)testErrorExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSError *err = nil;</span><br><span class=\"line\">    [self handleResponseCode:400 error:&amp;err];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;err---%p--%@&quot;,err,err);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //指针运算符&amp;和*是从右往左运算,他们的优先级相同。*&amp;err和err一样。</span><br><span class=\"line\">    NSLog(@&quot;*&amp;err---%p--%@&quot;,*&amp;err,*&amp;err);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 &quot;(null)&quot; UserInfo=&#123;data=99&#125;</span><br><span class=\"line\">    *&amp;err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 &quot;(null)&quot; UserInfo=&#123;data=99&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleResponseCode:(NSInteger)code error:(NSError **)error&#123;</span><br><span class=\"line\">    if (code != 0) &#123;</span><br><span class=\"line\">        *error = [NSError errorWithDomain:NSCocoaErrorDomain code:100 userInfo:@&#123;@&quot;data&quot;:@&quot;99&quot;&#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"三、扩展\"><a href=\"#三、扩展\" class=\"headerlink\" title=\"三、扩展\"></a>三、扩展</h3><ol>\n<li><p>操作系统分为32位和64位，32位的最多只能支持4GB的内存，因为计算机底层并不使用十进制，使用的是二进制，32位的二进制只能支持4G个编号，这意味着操作系统只能为4GB的内存单元编号，因此32位的操作系统最多只能支持4GB的内存，多余的内存不会有编号,因此无法将数据存入这些内存单元中。</p>\n</li>\n<li><p>指针存储于栈区，不同数据类型的指针大小都相等，因为他们的值都是一个地址，并且长度也相同。32位操作系统中，指针大小是4个字节，64位操作系统中指针大小是8个字节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面代码是在64位操作系统演示</span><br><span class=\"line\">-(void)testGetPointerNum &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    char *a = &quot;myBlog&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int num1 = 1234325;</span><br><span class=\"line\">    int *b = &amp;num1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    double num2 = 3232.434;</span><br><span class=\"line\">    double *c = &amp;num2;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;char *类型指针变量a所占字节数：%ld&quot;,sizeof(a));</span><br><span class=\"line\">    printf(&quot;int *类型指针变量b所占字节数：%ld&quot;,sizeof(b));</span><br><span class=\"line\">    printf(&quot;double *类型指针变量c所占字节数：%ld&quot;,sizeof(c));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    char *类型指针变量a所占字节数：8</span><br><span class=\"line\">    int *类型指针变量b所占字节数：8</span><br><span class=\"line\">    double *类型指针变量c所占字节数：8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结构体数据类型变量的大小：<code>对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testStructExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data1&#123;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        char b;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data2&#123;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        char b;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data1 p1;</span><br><span class=\"line\">    p1.a = 1;</span><br><span class=\"line\">    p1.b = &#x27;d&#x27;;</span><br><span class=\"line\">    p1.c = &#x27;f&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data2 p2;</span><br><span class=\"line\">    p2.a = 1;</span><br><span class=\"line\">    p2.b = &#x27;d&#x27;;</span><br><span class=\"line\">    p2.c = &#x27;f&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;p1结构体占用的字节个数为：%ld&quot;,sizeof(p1));</span><br><span class=\"line\">    printf(&quot;p2结构体占用的字节个数为：%ld&quot;,sizeof(p2));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    p1结构体占用的字节个数为：8</span><br><span class=\"line\">    p2结构体占用的字节个数为：12</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"结构体内存结构示意图\"></p>\n<p>你可以看到，在 Data1 中，首先是 int 类型的 a 变量，占用了第一个存储单元，然后 b 和 c 占用了第二个存储单元的前两个字节。再看 Data2，由于 Data2 不同于 Data1 的字段顺序，b 占用了第一个存储单元的第一个字节，剩余的 3 个字节不够存放一个 int 类型变量的，所以按照上面我们讲的规则“当本存储单元不够安放的时候，就从下个存储单元的头部开始安放”， a 变量就单独占用了第二个存储单元，c 自己占用第三个存储单元的第一个字节。所以，虽然在数据表示上，Data1 和 Data2 是等价的，可 Data2 却占用了更多的存储空间，相比于 Data1 造成了 50% 的空间浪费。由此可见，在设计结构体的时候，不仅要设计新的结构体类型中所包含的数据字段，还需要关注各个字段之间的顺序排布。</p>\n</li>\n<li><p>32位操作系统内存与地址分布图：</p>\n</li>\n</ol>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png\" alt=\"内存空间布局\"></p>\n<ol start=\"5\">\n<li><p>64位操作系统常用数据类型占用的内存大小：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">常用数据类型</th>\n<th align=\"center\">占用内存大小（字节）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char、unsigned char</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">bool</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">short、unsigned short</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">int、unsigned int</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">long、unsigned long</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">指针</td>\n<td align=\"center\">8</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"一、引言：\"><a href=\"#一、引言：\" class=\"headerlink\" title=\"一、引言：\"></a>一、引言：</h3><p>日常开发中，我们经常遇到指针，同时指针也是C语言里极为重要的一个知识点，今天我们就来把它彻底弄明白。</p>","more":"<h3 id=\"二：正文\"><a href=\"#二：正文\" class=\"headerlink\" title=\"二：正文\"></a>二：正文</h3><h4 id=\"变量与变量值\"><a href=\"#变量与变量值\" class=\"headerlink\" title=\"变量与变量值:\"></a>变量与变量值:</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//数据类型（int） 变量名（a） = 值（10）</span><br><span class=\"line\">int a = 10;</span><br></pre></td></tr></table></figure>\n\n<p>变量：变量是一个<strong>抽象概念</strong>，可以理解为允许存放数据的空间。当声明一个变量，计算机就会分配空间存放数据。变量可以通过变量名访问。</p>\n<p>变量值：变量里面存储的数据即为变量值，变量值可以为数值、字符等类型。</p>\n<h4 id=\"指针：\"><a href=\"#指针：\" class=\"headerlink\" title=\"指针：\"></a>指针：</h4><p><strong>指针：</strong>是一种<u>变量</u>，它的值是一个<strong>内存地址</strong>。（从三个方面分析指针：指针的类型、指针所指向的类型、指针的值）</p>\n<p><strong>指针类型：</strong><code>数据类型 *</code>，int *：整形数据类型的指针； char *： 字符数据类型的指针； void *：无数据类型的指针；等等…</p>\n<p><strong>取地址运算：</strong><code>&amp;变量 </code> ，取得的结果是变量的<strong>首</strong>地址，是一个<strong>值</strong>（eg：x10db5640）。</p>\n<p><strong>取变量运算：</strong><code>*指针变量</code>，取得的结果是一个变量。</p>\n<p>1.整形数据类型指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testIntExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    //int类型变量a赋值为10</span><br><span class=\"line\">    int a = 10;</span><br><span class=\"line\">    //int*类型的指针变量b赋值为&amp;a</span><br><span class=\"line\">    int *b = &amp;a;</span><br><span class=\"line\">    //int类型变量c赋值为*b</span><br><span class=\"line\">    int c = *b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;变量b---值：%d 地址：%p&quot;,*b,b);</span><br><span class=\"line\">    printf(&quot;变量c---值：%d 地址：%p&quot;,c,&amp;c);</span><br><span class=\"line\">    </span><br><span class=\"line\">    打印结果：</span><br><span class=\"line\">    变量b---值：10 地址：0x10db5641c</span><br><span class=\"line\">    变量c---值：10 地址：0x10db5640c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：指针变量b的类型是：int *，指针变量b所指向的变量类型是int类型，b的值是一个地址：0x10db5641c。</p>\n<p>2.字符数据类型指针：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testCharExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    char *a = &quot;blog&quot;;</span><br><span class=\"line\">    char *b = a;</span><br><span class=\"line\">    char *c = b;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;变量b所指变量的值：%s 变量b所指变量的首地址：%p 变量b的地址：%p&quot;,b,b,&amp;b);</span><br><span class=\"line\">    printf(&quot;变量c所指变量的值：%s 变量c所指变量的首地址：%p 变量c的地址：%p&quot;,c,c,&amp;c);</span><br><span class=\"line\">    </span><br><span class=\"line\">    打印结果：</span><br><span class=\"line\">\t\t变量b所指变量的值：blog 变量b所指变量的首地址：0x10a951bfc 变量b的地址：0x10a76f410</span><br><span class=\"line\">\t\t变量c所指变量的值：blog 变量c所指变量的首地址：0x10a951bfc 变量c的地址：0x10a76f408</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：char*类型指针 变量a 指向char类型变量blog，a的值是 变量blog的首地址0x10a951bfc。</p>\n<p>3.指针与数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testArrayExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int arr[] = &#123;4,12,34,6,7,788&#125;;</span><br><span class=\"line\">    int *a = arr;//得到的是arr的首地址</span><br><span class=\"line\">    int *b = &amp;arr[0];//得到的是arr数组第一个元素的地址</span><br><span class=\"line\">    int *c = arr + 1;//得到的是arr数组第二个元素的地址</span><br><span class=\"line\">    int *d = &amp;arr[0] + 1;//得到的是arr数组第二个元素的地址</span><br><span class=\"line\"></span><br><span class=\"line\">    printf(&quot;a:%p---b:%p&quot;,a,b);//可以得出a和b是相等的</span><br><span class=\"line\">    printf(&quot;c:%p---d:%p&quot;,c,d);//可以得出c和d是相等的</span><br><span class=\"line\">    printf(&quot;num:%ld&quot;,c-a);//可以得出c和a之间有几个元素</span><br><span class=\"line\">    printf(&quot;数组中第一个元素的字节数：%ld&quot;,sizeof(arr[0]));//获取数组第一个元素的字节数</span><br><span class=\"line\">    </span><br><span class=\"line\">    *c = 99;</span><br><span class=\"line\">    printf(&quot;arr+1: %d---%p&quot;,*c,c);</span><br><span class=\"line\"></span><br><span class=\"line\">    //打印结果：</span><br><span class=\"line\">    a:0x106f54410---b:0x106f54410</span><br><span class=\"line\">    c:0x106f54414---d:0x106f54414</span><br><span class=\"line\">    num:1</span><br><span class=\"line\">    数组中第一个元素的字节数：4</span><br><span class=\"line\">    arr+1: 99---0x106f54414</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：</p>\n<p>1）arr 表示arr[]数组的首地址</p>\n<p>2）指针c - 指针a，能获取到两个指针之间有几个元素</p>\n<p>3）指针变量加减一个整数,p(指针)(+/-)n(整数)计算方式为：指针地址 (+/-) n * 变量占有的字节数</p>\n<p>4）sizeof的用法：</p>\n<ul>\n<li>每种类型的数据在内存单元中占有的字节数是固定的,因此sizeof(arr)/sizeof(arr[0]) = 数组的元素的个数</li>\n<li>sizeof(arr)：获取的是数组总共占有多少字节</li>\n<li>sizeof(arr[0])：获取的是数组中一个元素占有的字节数</li>\n</ul>\n<p>5）数组变量保存的是地址,但数组变量中保存的地址是不能改变的,注意说的是指针地址不能变,但是指针指向的值是可以变的,因此数组变量应称为指针常量，可以改变数组中地址中存储的值。</p>\n<h4 id=\"OC-应用场景示例：\"><a href=\"#OC-应用场景示例：\" class=\"headerlink\" title=\"OC 应用场景示例：\"></a>OC 应用场景示例：</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//采用这种方式传参，可以获取到error的值</span><br><span class=\"line\">- (void)testErrorExample &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    NSError *err = nil;</span><br><span class=\"line\">    [self handleResponseCode:400 error:&amp;err];</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSLog(@&quot;err---%p--%@&quot;,err,err);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //指针运算符&amp;和*是从右往左运算,他们的优先级相同。*&amp;err和err一样。</span><br><span class=\"line\">    NSLog(@&quot;*&amp;err---%p--%@&quot;,*&amp;err,*&amp;err);</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 &quot;(null)&quot; UserInfo=&#123;data=99&#125;</span><br><span class=\"line\">    *&amp;err---0x6000031d07e0--Error Domain=NSCocoaErrorDomain Code=100 &quot;(null)&quot; UserInfo=&#123;data=99&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (void)handleResponseCode:(NSInteger)code error:(NSError **)error&#123;</span><br><span class=\"line\">    if (code != 0) &#123;</span><br><span class=\"line\">        *error = [NSError errorWithDomain:NSCocoaErrorDomain code:100 userInfo:@&#123;@&quot;data&quot;:@&quot;99&quot;&#125;];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"三、扩展\"><a href=\"#三、扩展\" class=\"headerlink\" title=\"三、扩展\"></a>三、扩展</h3><ol>\n<li><p>操作系统分为32位和64位，32位的最多只能支持4GB的内存，因为计算机底层并不使用十进制，使用的是二进制，32位的二进制只能支持4G个编号，这意味着操作系统只能为4GB的内存单元编号，因此32位的操作系统最多只能支持4GB的内存，多余的内存不会有编号,因此无法将数据存入这些内存单元中。</p>\n</li>\n<li><p>指针存储于栈区，不同数据类型的指针大小都相等，因为他们的值都是一个地址，并且长度也相同。32位操作系统中，指针大小是4个字节，64位操作系统中指针大小是8个字节。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面代码是在64位操作系统演示</span><br><span class=\"line\">-(void)testGetPointerNum &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    char *a = &quot;myBlog&quot;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    int num1 = 1234325;</span><br><span class=\"line\">    int *b = &amp;num1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    double num2 = 3232.434;</span><br><span class=\"line\">    double *c = &amp;num2;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;char *类型指针变量a所占字节数：%ld&quot;,sizeof(a));</span><br><span class=\"line\">    printf(&quot;int *类型指针变量b所占字节数：%ld&quot;,sizeof(b));</span><br><span class=\"line\">    printf(&quot;double *类型指针变量c所占字节数：%ld&quot;,sizeof(c));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    char *类型指针变量a所占字节数：8</span><br><span class=\"line\">    int *类型指针变量b所占字节数：8</span><br><span class=\"line\">    double *类型指针变量c所占字节数：8</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>结构体数据类型变量的大小：<code>对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)testStructExample &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data1&#123;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        char b;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data2&#123;</span><br><span class=\"line\">        char c;</span><br><span class=\"line\">        int a;</span><br><span class=\"line\">        char b;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data1 p1;</span><br><span class=\"line\">    p1.a = 1;</span><br><span class=\"line\">    p1.b = &#x27;d&#x27;;</span><br><span class=\"line\">    p1.c = &#x27;f&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    struct Data2 p2;</span><br><span class=\"line\">    p2.a = 1;</span><br><span class=\"line\">    p2.b = &#x27;d&#x27;;</span><br><span class=\"line\">    p2.c = &#x27;f&#x27;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    printf(&quot;p1结构体占用的字节个数为：%ld&quot;,sizeof(p1));</span><br><span class=\"line\">    printf(&quot;p2结构体占用的字节个数为：%ld&quot;,sizeof(p2));</span><br><span class=\"line\">    </span><br><span class=\"line\">    //打印结果</span><br><span class=\"line\">    p1结构体占用的字节个数为：8</span><br><span class=\"line\">    p2结构体占用的字节个数为：12</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解读：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png\" alt=\"结构体内存结构示意图\"></p>\n<p>你可以看到，在 Data1 中，首先是 int 类型的 a 变量，占用了第一个存储单元，然后 b 和 c 占用了第二个存储单元的前两个字节。再看 Data2，由于 Data2 不同于 Data1 的字段顺序，b 占用了第一个存储单元的第一个字节，剩余的 3 个字节不够存放一个 int 类型变量的，所以按照上面我们讲的规则“当本存储单元不够安放的时候，就从下个存储单元的头部开始安放”， a 变量就单独占用了第二个存储单元，c 自己占用第三个存储单元的第一个字节。所以，虽然在数据表示上，Data1 和 Data2 是等价的，可 Data2 却占用了更多的存储空间，相比于 Data1 造成了 50% 的空间浪费。由此可见，在设计结构体的时候，不仅要设计新的结构体类型中所包含的数据字段，还需要关注各个字段之间的顺序排布。</p>\n</li>\n<li><p>32位操作系统内存与地址分布图：</p>\n</li>\n</ol>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80.png\" alt=\"内存空间布局\"></p>\n<ol start=\"5\">\n<li><p>64位操作系统常用数据类型占用的内存大小：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">常用数据类型</th>\n<th align=\"center\">占用内存大小（字节）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">char、unsigned char</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">bool</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">short、unsigned short</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">int、unsigned int</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">long、unsigned long</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">float</td>\n<td align=\"center\">4</td>\n</tr>\n<tr>\n<td align=\"center\">double</td>\n<td align=\"center\">8</td>\n</tr>\n<tr>\n<td align=\"center\">指针</td>\n<td align=\"center\">8</td>\n</tr>\n</tbody></table>\n</li>\n</ol>"},{"title":"内存管理一","date":"2022-06-22T06:18:11.000Z","_content":"\n\n\n> 一、iOS内存管理方式：\n>\n> ​\t1.Tagged Pointer：小对象的内存管理方式\n>\n> ​\t2.引用计数：普通对象的内存管理方式\n>\n> 二、MRC介绍，需要开发工程师做哪些工作\n>\n> 三、ARC介绍，编译器帮我们做了什么\n>\n> <!--more-->\n>\n> ​\t1.指针修饰符\n>\n> ​\t\t1. __strong\n>\n> ​\t\t2. __weak\n>\n> ​\t\t3. __unsafe_unretained\n>\n> ​\t\t4. __autoreease\n>\n> ​\t2.属性修饰符\n>\n> ​\t\t2.1 原子性：`atomic`、`nonatomic`\n>\n> ​\t\t2.2 读写权限：`readwrite`、`readonly`\n>\n> ​\t\t2.3 内存管理语义：`assign`、`retain`、`copy`、`strong`、`weak`、`unsafe_unretained`\n\n### 一、内存管理方式：\n\n#### 1.Tagged Pointer：小对象的内存管理方式\n\n64位操作系统后，iOS引入了Tagged Pointer，用来优化NSString、NSNumber、NSDate的内存管理。\n\n引入Tagged Pointer之前（32位操作系统时），小对象内存管理方式和普通对象一样，首先需要在堆区开辟一块内存，并把内存的地址赋值给栈区的指针变量，然后维护对象的引用计数和内存的释放。\n\n比如我们创建一个int类型的NSNumber对象：\n\n```objective-c\nNSNumber *number = @11;\n```\n\n系统需要开辟16个字节的内存来存储11这个值，同时需要开辟8个字节大小的内存来存储这个对象的地址，本来需要占用4个字节的内存的Int类型数据，占用了24个字节，同时还没考虑维护引用计数和内存释放等的内存开销。\n\n![使用Tagged pointer前的内存管理](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/nsnumber.png)\n\n在引入Tagged Pointer之后，**小对象就不需要像之前那样 在堆区开辟内存，维护引用计数，释放内存了。而是直接把值存到了number指针里，number里面存的不再是一个地址了，而是Tag + Data，Tag是用来标记小对象的类型（NSString、NSNumber、NSDate），Data就是小对象的值。指针什么时候创建，小对象就什么时候创建，指针什么时候销毁，小对象就什么时候销毁。只有在指针存不下小对象的值时，才会变为引用计数的方式管理内存。**这样，仅需要8个字节就可以存储小对象的类型和值，很大程度上节省了内存占用，同时也减少了维护引用计数、内存释放等带来的开销。\n\n![使用Tagged Pointer后的内存管理](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E4%BD%BF%E7%94%A8Tagged.png)\n\n用代码验证一下：\n\n```objective-c\n//  苹果对Tagged Pointer做了数据混淆，所以在分析Tagged Pointer之前，我们需要先关闭Tagged Pointer的数据混淆。通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为YES。否则无法分析打印出的结果\n- (void)testTaggedPointer {\n    \n    NSNumber *number1 = @1;\n    NSNumber *number2 = @2;\n    NSNumber *number3 = @10;\n    NSNumber *number4 = @(0xFFFFFFFFFFFFFFFF);\n\n    NSLog(@\"number1:%p\", number1);\n    NSLog(@\"number2:%p\", number2);\n    NSLog(@\"number3:%p\", number3);\n    NSLog(@\"number4:%p\", number4);\n}\n\nnumber1:0xb000000000000012\nnumber2:0xb000000000000022\nnumber3:0xb0000000000000a2\nnumber4:0x600001be2060\n```\n\nnumber1～number3指针是Tagged Pointer，number4由于值大到存储不下了，改为普通对象内存管理方式。对应的地址分布规律见下图（mac os系统的规律与iOS系统的规律不同 [详细](https://cloud.tencent.com/developer/article/1620346)），可发现规律**如果一个指针的最高位为1，那么他就是Tagged Pointer，否则就不是。**\n\n![ios-nsnumber](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623191932.png)\n\n如果是NSString的话，Tagged Pointer内存地址分布规律就是下面这样的：\n\n![ios-nsstring](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623195417.png)\n\n\n\n学习完上面内容，我们举个例子验证下，找不同：\n\n```objectivec\n// 开辟多个线程去修改name属性\n// 代码1\nfor (int i = 0; i < 1000; i++) {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        self.name = [[NSString alloc] initWithFormat:@\"abcdefghijk\"];\n    });\n}\n\n// 代码2\nfor (int i = 0; i < 1000; i++) {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        self.name = [[NSString alloc] initWithFormat:@\"abc\"];\n    });\n}\n```\n\n运行代码我们会发现 代码1 会crash，因为`abcdefghijk`已经大到指针存储不下，改为了普通对象内存管理方式，所以 代码1 就是正常的调用`setter`方法修改`name`属性,`setter`的实现是这样的：\n\n```objectivec\n- (void)setName:(NSString *)name {\n    if (_name != name) { // 新旧对象不一样时\n        [_name release]; // 释放旧对象\n        _name = [name copy]; // 复制新对象\n    }\n}\n```\n\n在不加锁的情况下，极容易发生多个线程同时调用`[_name release]`的情况，若`_name`已经销毁，再次调用`release`肯定会发生crash。\n\n代码2 正常运行，是因为`abc`并没有大到指针存储不下，`NSString`为`NSTaggedPointerString`类型，在`objc_release`函数中会判断指针是不是`TaggedPointer`类型，是的话就不对对象进行`release`操作，也就避免了因过度释放对象而导致的`Crash`，因为根本就没执行释放操作。\n\n\n\n#### 2.引用计数：普通对象的内存管理方式\n\n**2.1 引用计数是什么？**\n\n**iOS是通过引用计数来管理内存的。所谓的引用计数就是指每当我们创建一个对象，系统就会为该对象分配一个整数，用来表征当前有多少人想使用该对象。**那就引出两个问题：\n\n问题1：创建对象时，系统为对象分配的整数存在哪里？也就是引用计数存在哪里？因为我们知道OC对象内部只有一个`isa`，并没有引用计数的成员变量\n\n问题2：iOS具体是怎么通过引用计数来管理内存的？\n\n\n\n**2.2 引用计数存储在哪里？**\n\n64位操作系统以前，对象的`isa`指针还没进行内存优化，对象的引用计数存储在引用计数表里。\n\n当系统为64位操作系统后，对象的`isa`指针经过了内存优化，它不再直接是一个指针了，而是一个共用体，64位中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1），还有1位用来标记引用计数表里是否有当前对象的引用计数。具体地说：**对象的引用计数首先会存储在`isa`共用体里——`extra_rc`变量，但是`isa`共用体的引用计数存储范围是0～255，一旦引用计数超过了255，这个变量就会溢出，此时系统会把这个变量置为128，同时把引用计数表里是否有当前对象的引用计数的标记——`has_sidetable_rc`变量置为1，并把另外128个引用计数挪到引用计数表里进行存储。下一次对象的引用计数再次增加时，依旧增加`isa`共用体里的引用计数（因为它已被置为128，不再是溢出状态），直到再次溢出，系统再娜128个引用计数到引用计数表里，如此循环往复。**\n\n因此可以看出，系统是不会直接操作引用计数表里的引用计数的，而总是在操作`isa`共用体里的引用计数，直到溢出时才从`isa`共用体里挪128个引用计数到引用计数表里进行存储。\n\n- `isa`共用体\n\n  ```cpp\n  struct objc_object {\n      isa_t isa; // 一个isa_t类型的共用体\n  \n      // 自定义的成员变量，存储着该对象这些成员变量具体的值\n      NSSring *_name; // “张三”\n      NSSring *_sex; // “男”\n      int _age; // 33\n  }\n  \n  union isa_t {\n      Class cls;\n      \n      unsigned long bits; // 8个字节，64位\n      struct { // 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着谁的数据\n  # if __arm64__\n  #   define ISA_MASK        0x0000000ffffffff8ULL\n          unsigned long nonpointer        : 1; // isa是否经过内存优化\n          unsigned long has_assoc         : 1;\n          unsigned long has_cxx_dtor      : 1;\n          unsigned long shiftcls          : 33; // 对象所属类的地址信息\n          unsigned long magic             : 6;\n          unsigned long weakly_referenced : 1;\n          unsigned long deallocating      : 1;\n          unsigned long has_sidetable_rc  : 1; // 引用计数表里是否有当前对象的引用计数\n          unsigned long extra_rc          : 19; // 对象的引用计数 - 1\n  # endif\n      };\n  };\n  ```\n\n- `SideTables`-->`SideTable`-->引用计数表、若引用表\n\n![SideTables](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220627183629.png)\n\n```objective-c\nstatic StripedMap<SideTable>& SideTables() {\n    return *reinterpret_cast<StripedMap<SideTable>*>(SideTableBuf);\n}\n\nstruct SideTable {\n    spinlock_t slock; // 自旋锁\n    RefcountMap refcnts; // 引用计数表\n    weak_table_t weak_table;\n}\n\ntypedef objc::DenseMap<objc_object */*对象的内存地址*/, unsigned long/*对象的引用计数*/> RefcountMap;\n\nstruct weak_table_t {\n    weak_entry_t *weak_entries; // 这个其实才是弱引用表，表中元素为weak_entry_t结构体\n    size_t    num_entries;\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\nstruct weak_entry_t {\n    objc_object *obj; // 对象的内存地址\n    weak_referrer_t *referrers; // 指向该对象的弱指针数组——即所有指向该对象的弱指针（其实存储的是弱指针对应那块内存的地址，但是我们直接理解为弱指针是没有问题的）\n}\n// 例如：\nid obj = [[NSObject alloc] init];\n__weak id weakObj1 = obj;\n__weak id weakObj2 = obj;\n__weak id weakObj3 = obj;\n\n// NSObject对象的weak_entry为：\nstruct weak_entry_t {\n    objc_object *obj; // 对象的内存地址\n    weak_referrer_t *referrers; // 指向该对象的弱指针数组\n} NSObjectWeakEntry = {\n    obj;\n    [weakObj1, weakObj2, weakObj3]\n}\n```\n\n`SideTables`是一个全局的散列表，它里面存储着64个`SideTable`结构体，而每个`SideTable`结构体内部又存储着1个引用计数表和1个弱引用计数表，所以项目中一般会有64个引用计数表和64个弱引用计数表。引用计数表也是一个散列表，表中的元素是一个字典：`key`为对象的内存地址，`value`为对象的引用计数，引用计数表里存储着很多对象的引用计数。若引用计数表也是一个散列表，表中的元素是一个结构体：一个成员变量是对象的内存地址，另一个成员变量是指向该对象的弱指针数组。\n\n所以如果我们想要找到对象的引用计数和弱指针数组，就要首先把对象的内存地址通过某种散列算法得到一个`index`，就可以在`SideTables`里找到对象的引用计数和弱指针数组所在的`SideTable`结构体，也就是找到了引用计数和弱指针数组所在的引用计数表和弱引用计数表，然后再次把对象的内存地址通过某种散列算法得到一个`index`，就可以在引用计数表里找到对象的引用计数，弱引用计数表里找到对象的弱指针数组了。\n\n\n\n**2.3 iOS具体是怎么通过引用计数来进行对象的内存管理的**\n\n主要是通过`alloc`、`new`、`alloc`、`copy`、`mutableCopy`，`retain`，`release`、`autorelease`，`dealoc`这几个方法操作引用计数，来管理对象内存管理的，即：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628181747.png)\n\n```cpp\n// NSObject.mm\n- (void)release {\n    self->rootRelease();\n}\n\nbool objc_object::rootRelease()\n{\n    return rootRelease(true, false);\n}\n\nbool objc_object::rootRelease(bool performDealloc, bool handleUnderflow)\n{\n    if (isTaggedPointer()) return false;\n\n    isa_t newisa = LoadExclusive(&isa.bits);\n\n    if (!newisa.nonpointer) {\n        \n        // 去引用计数表里让它的引用计数-1\n        return sidetable_release(performDealloc);\n    }\n    \n\n    // 用来标识extra_rc是否下溢——即是否减为-1（因为extra_rc存储的是（引用计数 - 1），所以减为0的时候说明引用计数为1，还有人引用它，没事儿）\n    uintptr_t carry;\n    // 首先去isa共用体里，让对象的引用计数-1\n    newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);\n    if (carry) { // 所以如果extra_rc下溢了：\n    \n        goto underflow; // 跳转到underflow处执行\n    }\n\n    // 表明没有下溢，结束\n    return false;\n\n underflow: // extra_rc下溢了：\n\n    newisa = LoadExclusive(&isa.bits);\n\n    if (newisa.has_sidetable_rc) { // 如果引用计数表里有当前对象的引用计数，说明还有人使用该对象\n\n        // 尝试从引用计数表搬回来128个引用计数\n        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);\n        if (borrowed) { // 如果搬成功了\n            \n            // 存进去\n            newisa.extra_rc = borrowed - 1;\n            // 更新一下对象的isa共用体\n            isa = newisa;\n        } else { // 搬失败了，说明引用计数表里的引用计数也为0了（可能是被上一次搬完了）\n            \n            // 走dealloc方法销毁该对象\n            ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n        }\n    } else { // 引用计数表里没有当前对象的引用计数，说明没人使用该对象了\n        \n        // 走dealloc方法销毁该对象\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n    }\n    \n    return true;\n}\n\n// 尝试从引用计数表搬回来128个引用计数\nsize_t objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)\n{\n    SideTable& table = SideTables()[this];\n    RefcountMap::iterator it = table.refcnts.find(this);\n    \n    if (it == table.refcnts.end()  ||  it->second == 0) { // 引用计数表里的引用计数被上一次搬完了\n\n        return 0;\n    }\n    \n    // 引用计数表里的引用计数-128，搬出去\n    size_t oldRefcnt = it->second;\n    size_t newRefcnt = oldRefcnt - (delta_rc << SIDE_TABLE_RC_SHIFT);\n    it->second = newRefcnt;\n    \n    return delta_rc;\n}\n```\n\n>关于`autorelease`和`autoreleasepool`就暂时理解这么一点，更底层的东西有空再说：\n>\n>- `release`会立即使对象的引用计数-1，而`autorelease`则不会，它仅仅是把该对象注册到了`autoreleasepool`中，当`autoreleasepool`销毁时系统会自动让池中所有的对象都调用一下`release`，这时对象的引用计数才-1。\n>- 而`autoreleasepool`又是在RunLoop休眠或退出时销毁的，当然如果是我们自己创建的`@autoreleasepool{}`，出了大括号——即出了`@autoreleasepool{}`的生命周期，它就会销毁。\n>- 只要不是用`alloc`、`new`、`copy`、`mutableCopy`方法创建的对象，而是用类方法创建的对象，方法内部都调用了`autorelease`，都是`autorelease`对象。\n\n- 如果对象的引用计数减为0了，就代表没人想使用该对象了，系统就会调用`dealloc`方法销毁它，并释放它对应的内存，对象一经销毁就不能再访问了，因为他的内存随时会被移作它用。\n\n  ![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628182915.png)\n\n```cpp\n// NSObject.mm\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid _objc_rootDealloc(id obj)\n{\n    obj->rootDealloc();\n}\n\nvoid objc_object::rootDealloc()\n{\n    if (\n        !isa.has_cxx_dtor  && // 如果当前对象没使用过C++析构函数\n        !isa.has_assoc  && // 如果当前对象没有关联对象\n        !isa.weakly_referenced  && // 如果弱引用表里没有当前对象的弱指针数组\n        !isa.has_sidetable_rc // 如果引用计数表里没有当前对象的引用计数\n        )\n    {\n        // 就直接销毁对象，并释放它对应的内存，即我们之前说的对象销毁时会更快\n        free(this);\n    } else {\n        \n        // 否则就慢慢销毁\n        object_dispose(this);\n    }\n}\n\nid object_dispose(id obj)\n{\n    objc_destructInstance(obj);\n    // 销毁对象，并释放它对应的内存，\n    free(obj);\n\n    return nil;\n}\n\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        \n        // 如果当前对象使用过C++析构函数\n        bool cxx = obj->hasCxxDtor();\n        // 如果当前对象有关联对象\n        bool assoc = obj->hasAssociatedObjects();\n\n        // 要按顺序销毁哦\n        if (cxx) object_cxxDestruct(obj); // 销毁C++析构函数相关的东西\n        if (assoc) _object_remove_assocations(obj); // 移除关联对象\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n\nvoid objc_object::clearDeallocating()\n{\n    clearDeallocating_slow();\n}\n\nvoid objc_object::clearDeallocating_slow()\n{\n    // 获取SideTable\n    SideTable& table = SideTables()[this];\n\n    if (isa.weakly_referenced) { // 如果弱引用表里有当前对象的弱指针数组\n        \n        // 把弱引用表里所有指向该对象的弱指针都置为nil，并移除，从此弱引用表里就没有该对象的弱指针数组（关于弱指针（弱引用）更多详细的内容，见下面__weak指针的实现原理）\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    \n    if (isa.has_sidetable_rc) { // 如果引用计数表里有当前对象的引用计数\n        \n        // 从引用计数表里把该对象的引用计数给抹掉，从此引用计数表里就没有该对象的引用计数了\n        table.refcnts.erase(this);\n    }\n}\n```\n\n### 二、MRC介绍，需要开发工程师做哪些工作\n\nMRC（*Manual Reference Count*）：指手动管理引用计数，即需要程序员自己手动调用上面那几个`alloc`、`new`、`alloc`、`copy`、`mutableCopy`，`retain`，`release`、`autorelease`，`dealoc`方法来操作引用计数，从而完成对象的内存管理。具体地说，MRC下我们需要做到以下三点：\n\n- 调用了`alloc`、`new`、`alloc`、`copy`、`mutableCopy`创建对象的地方，在不想使用对象时，要调用\n\n`release`、`autorelease`；调用了`retain`使对象引用计数+1的地方，在不想使用对象时，要调用\n\n`release`、`autorelease`来使对象的引用计数-1。\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    // 调用了alloc、new、copy、mutableCopy创建对象\n    NSArray *arr = [[NSArray alloc] init];\n    NSArray *arr1 = [NSArray new];\n    NSArray *arr2 = [arr copy];\n    NSMutableArray *arr3 = [arr1 mutableCopy];\n    \n    // 调用release、autorelease来释放对象\n    [arr release];\n    [arr1 release];\n    [arr2 autorelease];\n    [arr3 autorelease];\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    NSArray *arr = [NSArray array];\n    // 调用了retain使对象引用计数+1\n    [arr retain];\n\n    // 要调用release、autorelease来使对象的引用计数-1\n    [arr release];\n  \n    //或者调用下面\n    //[arr autorelease];\n}\n```\n\n- 我们还需要处理好`setter`方法内部的内存管理，并在`dealloc`方法里释放当前类及其父类**所有对象类型**的成员变量。\n\n```objectivec\n@implementation INEPerson {\n    int _age;\n    NSString *_name;\n    INEDog *_dog;\n}\n\n- (void)setAge:(int)age {\n    \n    _age = age; // 直接赋值\n}\n\n- (void)setName:(NSString *)name {\n\n    if (_name != name) { // 新旧对象不一样时\n        \n        [_name release]; // 释放旧对象\n        _name = [name copy]; // 复制新对象\n    }\n}\n\n- (void)setDog:(INEDog *)dog {\n    \n    if (_dog != dog) { // 新旧对象不一样时\n        \n        [_dog release]; // 释放旧对象\n        _dog = [dog retain]; // 持有新对象\n    }\n}\n\n- (void)dealloc {\n    \n    // 释放当前类所有对象类型的成员变量\n    [self setName:nil];\n    [self setDog:nil];\n\n    // 释放父类所有对象类型的成员变量，放在最后\n    [super dealloc];\n}\n\n@end\n```\n\n- 我们还需要处理好循环引入问题。\n\n```objective-c\n//稍后补充\n```\n\n\n\n#### 三、ARC介绍，编译器帮我们做了什么\n\nARC（*Autal Reference Count*）：自动管理引用计数，让**编译器**进行内存管理，**在LVVM编译器中设置ARC为有效状态，就无需再次键入`retain`、`realeas`、`autorelease`代码，编译器会在合适的地方自动帮我们插入`retain`、`release`、`autorelease`等方法的调用，从而完成对象的内存管理。但实际上除了编译器之外，ARC还用到了Runtime，比如`weak`指针的清空。**这样就会在降低程序崩溃、内存泄漏风险的同时，很大程度程度减少了开发的工作量，使应用程序具有可预测性，且能流畅运行，速度也将大幅提升。具体来说，与MRC相对应，ARC帮我们做了如下三点：\n\n- 利用`__strong`指针修饰符，编译器会在合适的地方帮们插入`retain`、`release`、`autorelease`等方法的调用；\n\n- 利用属性修饰符，编译器为我们生成特定的`setter`方法并处理好内部的内存管理，还会自动在`dealloc`方法里释放当前类及其父类的成员变量；\n\n- 利用`__weak`指针修饰符和Runtime，来处理循环引入问题。\n\n#### 1.指针修饰符\n\n- `__strong`指针修饰符\n\n  凡是用`__strong`修饰的指针，在超出其作用域时，编译器会为我们插入一次`release`或`autorelease`的调用。\n\n  ```objectivec\n  // ARC下\n  {\n      __strong id obj = [[NSObject alloc] init];\n      __strong id arr = [NSArray array];\n  }\n  \n  等价于：\n  \n  // MRC下\n  {\n      id obj = [[NSObject alloc] init];\n      id arr = [[NSArray alloc] init];\n      \n      [obj release];\n      [arr autorelease];\n  }\n  ```\n\n而在指针赋值时，编译器会自动为我们插入一次`retain`的调用。\n\n```objectivec\n// ARC下\n{\n    __strong id obj = [[NSObject alloc] init];\n    __strong id obj1 = obj;\n}\n\n等价于：\n\n// MRC下\n{\n    id obj = [[NSObject alloc] init];\n    id obj1 = [obj retain];\n    \n    [obj release];\n    [obj1 release];\n}\n```\n\n所以正是因为使用`__strong`指针修饰符，编译器才会在合适的地方帮我们插入`retain`、`release`、`autorelease`等方法的调用，而ARC下所有指针默认都是用`__strong`修饰的。\n\n- `__weak`指针修饰符\n\n看起来有了`strong`,编译器就可以很好的管理内存了，但是很重要的一点是`__strong`无法解决引用计数式内存管理必然会导致的“循环引入”问题。\n\n```objective-c\n//稍后补充\n```\n\n#### 2.属性修饰符\n\n属性修饰符一共有三对儿：**原子性、读写权限和内存管理语意**，属性修饰符主要影响就是编译器为成员变量生成的`setter`、`getter`方法上。（这里除了讲解和内存相关的知识外，其他的也回顾一下）\n\n> 原子性：`atomic`（默认）、`nonatomic`\n\n- `atomic`：默认为`atomic`，使用`atomic`修饰的属性，编译器为该属性生成的`setter`、`getter`方法内部是加了锁的。\n\n  ```objectivec\n  @property (atomic, strong) NSMutableArray *array;\n  \n  - (void)setArray:(NSMutableArray *)array {\n      \n      // 加锁\n      _array = array;\n      // 解锁\n  }\n  \n  - (NSMutableArray *)array {\n      // 加锁\n      return _array;\n      // 解锁\n  }\n  ```\n\n但这仅仅是保证我们调用`setter`、`getter`方法访问属性这一步是线程安全的，它没发保证我们使用属性的线程是安全的，比如我们调用`[self.array addObject:xxx]`,`self.array`访问属性这一步是线程安全的，但`addObject:`使用属性这一步是线程不安全的。\n\n```objective-c\n// 线程1\n[self.array addObject:@\"11\"];\n// 线程2\n[self.array addObject:@\"12\"];\n\n等价于\n\n// 线程1\n[[self array] addObject:@\"11\"];\n// 线程2\n[[self array] addObject:@\"12\"];\n```\n\n所以为了保证使用属性的线程安全，我们还得在需要的地方自己加锁，这样一来使用使用`atomic`修饰属性就多此一举了，而且`stter`、`getter`方法的调用通常都是很频繁的，内部加锁的话会增加内存的开销，耗费性能。\n\n```php\n// 线程1\n// 加锁\n[self.array addObject:@\"11\"];\n// 解锁\n\n// 线程2\n// 加锁\n[self.array addObject:@\"12\"];\n// 解锁\n```\n\n- `nonatomic`：因此我们在实际开发中总是使用`nonatomic`。\n\n> 读写权限：`readwrite`(默认)、`readonly`\n\n- `readwrite`：默认为`readwrite`，代表该属性可读可写，编译器会为该属性生成`setter`\n\n`getter`方法的声明与实现。\n\n- `readonly`：代表该属性只能读取不能写入，编译器会为该属性生成`setter`、`getter`方法的声明与`getter`方法的实现。\n\n> 内存管理语意：\n>\n> - MRC下有：`assign`、`retain`、`copy`。\n> - ARC下新增了：`strong`、`weak`、`unsafe_unretained`。\n\n- `assign`：`assign`一般来修饰基本数据类型。使用`assign`修饰属性，编译器为属性生成的`setter`方法内部只是简单的赋值操作。\n\n```cpp\n- (void)setAge:(int)age {\n    \n    // 简单的赋值操作\n    _age = age;\n}\n```\n\n- `retain`：`retain`一般用来修饰对象类型。使用`retain`修饰的属性，编译器为该属性生成的`setter`方法内部会调用一下`retain`方法，是对象的引用计数+1。\n\n  ```objective-c\n  - (void)setDog:(Dog *)dog {\n      \n      if (_dog != dog) { // 新旧对象不一样时\n          \n          [_dog release]; // 释放旧对象\n          _dog = [dog retain]; // 持有新对象\n      }\n  }\n  ```\n\n- `copy`：`copy`一般用来修饰不可变属性和block。使用`copy`修饰的属性，编译器为该属性生成的`setter`方法内部会调用一下`copy`方法，生成一个新的对象，新对象的引用计数为1，而旧对象的引用计数不变。\n\n  ```objectivec\n  - (void)setName:(NSString *)name {\n  \n      if (_name != name) { // 新旧对象不一样时\n          \n          [_name release]; // 释放旧对象\n          _name = [name copy]; // 复制新对象\n      }\n  }\n  ```\n\n- `strong`：默认为`strong`，大多数情况下和`retain`的效果是一样的，修饰block和`copy`的效果是一样的，`strong`一般用来修饰对象类型。\n- `weak`：`weak`一般用来修饰代理对象和`NSTimer`，以免造成循环引入；还有用来修饰xib或sb拖出来的控件，因为这些界面已经被添加到界面上了，被subviews这个属性持有了，不必再用变量持有。\n\n- `unsafe_unretained`：和`assign`效果是一样的，如果用他们来修饰对象类型，和`weak`功能类似，但`weak`修饰的属性会在对象销毁时会被置为`nil`，比较安全，而`unsafe_unretained`和`assign`修饰的属性则不会，所以容易出现野指针。\n\n","source":"_posts/内存管理一.md","raw":"---\ntitle: 内存管理一\ndate: 2022-06-22 14:18:11\ntags:\n---\n\n\n\n> 一、iOS内存管理方式：\n>\n> ​\t1.Tagged Pointer：小对象的内存管理方式\n>\n> ​\t2.引用计数：普通对象的内存管理方式\n>\n> 二、MRC介绍，需要开发工程师做哪些工作\n>\n> 三、ARC介绍，编译器帮我们做了什么\n>\n> <!--more-->\n>\n> ​\t1.指针修饰符\n>\n> ​\t\t1. __strong\n>\n> ​\t\t2. __weak\n>\n> ​\t\t3. __unsafe_unretained\n>\n> ​\t\t4. __autoreease\n>\n> ​\t2.属性修饰符\n>\n> ​\t\t2.1 原子性：`atomic`、`nonatomic`\n>\n> ​\t\t2.2 读写权限：`readwrite`、`readonly`\n>\n> ​\t\t2.3 内存管理语义：`assign`、`retain`、`copy`、`strong`、`weak`、`unsafe_unretained`\n\n### 一、内存管理方式：\n\n#### 1.Tagged Pointer：小对象的内存管理方式\n\n64位操作系统后，iOS引入了Tagged Pointer，用来优化NSString、NSNumber、NSDate的内存管理。\n\n引入Tagged Pointer之前（32位操作系统时），小对象内存管理方式和普通对象一样，首先需要在堆区开辟一块内存，并把内存的地址赋值给栈区的指针变量，然后维护对象的引用计数和内存的释放。\n\n比如我们创建一个int类型的NSNumber对象：\n\n```objective-c\nNSNumber *number = @11;\n```\n\n系统需要开辟16个字节的内存来存储11这个值，同时需要开辟8个字节大小的内存来存储这个对象的地址，本来需要占用4个字节的内存的Int类型数据，占用了24个字节，同时还没考虑维护引用计数和内存释放等的内存开销。\n\n![使用Tagged pointer前的内存管理](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/nsnumber.png)\n\n在引入Tagged Pointer之后，**小对象就不需要像之前那样 在堆区开辟内存，维护引用计数，释放内存了。而是直接把值存到了number指针里，number里面存的不再是一个地址了，而是Tag + Data，Tag是用来标记小对象的类型（NSString、NSNumber、NSDate），Data就是小对象的值。指针什么时候创建，小对象就什么时候创建，指针什么时候销毁，小对象就什么时候销毁。只有在指针存不下小对象的值时，才会变为引用计数的方式管理内存。**这样，仅需要8个字节就可以存储小对象的类型和值，很大程度上节省了内存占用，同时也减少了维护引用计数、内存释放等带来的开销。\n\n![使用Tagged Pointer后的内存管理](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E4%BD%BF%E7%94%A8Tagged.png)\n\n用代码验证一下：\n\n```objective-c\n//  苹果对Tagged Pointer做了数据混淆，所以在分析Tagged Pointer之前，我们需要先关闭Tagged Pointer的数据混淆。通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为YES。否则无法分析打印出的结果\n- (void)testTaggedPointer {\n    \n    NSNumber *number1 = @1;\n    NSNumber *number2 = @2;\n    NSNumber *number3 = @10;\n    NSNumber *number4 = @(0xFFFFFFFFFFFFFFFF);\n\n    NSLog(@\"number1:%p\", number1);\n    NSLog(@\"number2:%p\", number2);\n    NSLog(@\"number3:%p\", number3);\n    NSLog(@\"number4:%p\", number4);\n}\n\nnumber1:0xb000000000000012\nnumber2:0xb000000000000022\nnumber3:0xb0000000000000a2\nnumber4:0x600001be2060\n```\n\nnumber1～number3指针是Tagged Pointer，number4由于值大到存储不下了，改为普通对象内存管理方式。对应的地址分布规律见下图（mac os系统的规律与iOS系统的规律不同 [详细](https://cloud.tencent.com/developer/article/1620346)），可发现规律**如果一个指针的最高位为1，那么他就是Tagged Pointer，否则就不是。**\n\n![ios-nsnumber](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623191932.png)\n\n如果是NSString的话，Tagged Pointer内存地址分布规律就是下面这样的：\n\n![ios-nsstring](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623195417.png)\n\n\n\n学习完上面内容，我们举个例子验证下，找不同：\n\n```objectivec\n// 开辟多个线程去修改name属性\n// 代码1\nfor (int i = 0; i < 1000; i++) {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        self.name = [[NSString alloc] initWithFormat:@\"abcdefghijk\"];\n    });\n}\n\n// 代码2\nfor (int i = 0; i < 1000; i++) {\n    dispatch_async(dispatch_get_global_queue(0, 0), ^{\n        self.name = [[NSString alloc] initWithFormat:@\"abc\"];\n    });\n}\n```\n\n运行代码我们会发现 代码1 会crash，因为`abcdefghijk`已经大到指针存储不下，改为了普通对象内存管理方式，所以 代码1 就是正常的调用`setter`方法修改`name`属性,`setter`的实现是这样的：\n\n```objectivec\n- (void)setName:(NSString *)name {\n    if (_name != name) { // 新旧对象不一样时\n        [_name release]; // 释放旧对象\n        _name = [name copy]; // 复制新对象\n    }\n}\n```\n\n在不加锁的情况下，极容易发生多个线程同时调用`[_name release]`的情况，若`_name`已经销毁，再次调用`release`肯定会发生crash。\n\n代码2 正常运行，是因为`abc`并没有大到指针存储不下，`NSString`为`NSTaggedPointerString`类型，在`objc_release`函数中会判断指针是不是`TaggedPointer`类型，是的话就不对对象进行`release`操作，也就避免了因过度释放对象而导致的`Crash`，因为根本就没执行释放操作。\n\n\n\n#### 2.引用计数：普通对象的内存管理方式\n\n**2.1 引用计数是什么？**\n\n**iOS是通过引用计数来管理内存的。所谓的引用计数就是指每当我们创建一个对象，系统就会为该对象分配一个整数，用来表征当前有多少人想使用该对象。**那就引出两个问题：\n\n问题1：创建对象时，系统为对象分配的整数存在哪里？也就是引用计数存在哪里？因为我们知道OC对象内部只有一个`isa`，并没有引用计数的成员变量\n\n问题2：iOS具体是怎么通过引用计数来管理内存的？\n\n\n\n**2.2 引用计数存储在哪里？**\n\n64位操作系统以前，对象的`isa`指针还没进行内存优化，对象的引用计数存储在引用计数表里。\n\n当系统为64位操作系统后，对象的`isa`指针经过了内存优化，它不再直接是一个指针了，而是一个共用体，64位中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1），还有1位用来标记引用计数表里是否有当前对象的引用计数。具体地说：**对象的引用计数首先会存储在`isa`共用体里——`extra_rc`变量，但是`isa`共用体的引用计数存储范围是0～255，一旦引用计数超过了255，这个变量就会溢出，此时系统会把这个变量置为128，同时把引用计数表里是否有当前对象的引用计数的标记——`has_sidetable_rc`变量置为1，并把另外128个引用计数挪到引用计数表里进行存储。下一次对象的引用计数再次增加时，依旧增加`isa`共用体里的引用计数（因为它已被置为128，不再是溢出状态），直到再次溢出，系统再娜128个引用计数到引用计数表里，如此循环往复。**\n\n因此可以看出，系统是不会直接操作引用计数表里的引用计数的，而总是在操作`isa`共用体里的引用计数，直到溢出时才从`isa`共用体里挪128个引用计数到引用计数表里进行存储。\n\n- `isa`共用体\n\n  ```cpp\n  struct objc_object {\n      isa_t isa; // 一个isa_t类型的共用体\n  \n      // 自定义的成员变量，存储着该对象这些成员变量具体的值\n      NSSring *_name; // “张三”\n      NSSring *_sex; // “男”\n      int _age; // 33\n  }\n  \n  union isa_t {\n      Class cls;\n      \n      unsigned long bits; // 8个字节，64位\n      struct { // 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着谁的数据\n  # if __arm64__\n  #   define ISA_MASK        0x0000000ffffffff8ULL\n          unsigned long nonpointer        : 1; // isa是否经过内存优化\n          unsigned long has_assoc         : 1;\n          unsigned long has_cxx_dtor      : 1;\n          unsigned long shiftcls          : 33; // 对象所属类的地址信息\n          unsigned long magic             : 6;\n          unsigned long weakly_referenced : 1;\n          unsigned long deallocating      : 1;\n          unsigned long has_sidetable_rc  : 1; // 引用计数表里是否有当前对象的引用计数\n          unsigned long extra_rc          : 19; // 对象的引用计数 - 1\n  # endif\n      };\n  };\n  ```\n\n- `SideTables`-->`SideTable`-->引用计数表、若引用表\n\n![SideTables](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220627183629.png)\n\n```objective-c\nstatic StripedMap<SideTable>& SideTables() {\n    return *reinterpret_cast<StripedMap<SideTable>*>(SideTableBuf);\n}\n\nstruct SideTable {\n    spinlock_t slock; // 自旋锁\n    RefcountMap refcnts; // 引用计数表\n    weak_table_t weak_table;\n}\n\ntypedef objc::DenseMap<objc_object */*对象的内存地址*/, unsigned long/*对象的引用计数*/> RefcountMap;\n\nstruct weak_table_t {\n    weak_entry_t *weak_entries; // 这个其实才是弱引用表，表中元素为weak_entry_t结构体\n    size_t    num_entries;\n    uintptr_t mask;\n    uintptr_t max_hash_displacement;\n};\nstruct weak_entry_t {\n    objc_object *obj; // 对象的内存地址\n    weak_referrer_t *referrers; // 指向该对象的弱指针数组——即所有指向该对象的弱指针（其实存储的是弱指针对应那块内存的地址，但是我们直接理解为弱指针是没有问题的）\n}\n// 例如：\nid obj = [[NSObject alloc] init];\n__weak id weakObj1 = obj;\n__weak id weakObj2 = obj;\n__weak id weakObj3 = obj;\n\n// NSObject对象的weak_entry为：\nstruct weak_entry_t {\n    objc_object *obj; // 对象的内存地址\n    weak_referrer_t *referrers; // 指向该对象的弱指针数组\n} NSObjectWeakEntry = {\n    obj;\n    [weakObj1, weakObj2, weakObj3]\n}\n```\n\n`SideTables`是一个全局的散列表，它里面存储着64个`SideTable`结构体，而每个`SideTable`结构体内部又存储着1个引用计数表和1个弱引用计数表，所以项目中一般会有64个引用计数表和64个弱引用计数表。引用计数表也是一个散列表，表中的元素是一个字典：`key`为对象的内存地址，`value`为对象的引用计数，引用计数表里存储着很多对象的引用计数。若引用计数表也是一个散列表，表中的元素是一个结构体：一个成员变量是对象的内存地址，另一个成员变量是指向该对象的弱指针数组。\n\n所以如果我们想要找到对象的引用计数和弱指针数组，就要首先把对象的内存地址通过某种散列算法得到一个`index`，就可以在`SideTables`里找到对象的引用计数和弱指针数组所在的`SideTable`结构体，也就是找到了引用计数和弱指针数组所在的引用计数表和弱引用计数表，然后再次把对象的内存地址通过某种散列算法得到一个`index`，就可以在引用计数表里找到对象的引用计数，弱引用计数表里找到对象的弱指针数组了。\n\n\n\n**2.3 iOS具体是怎么通过引用计数来进行对象的内存管理的**\n\n主要是通过`alloc`、`new`、`alloc`、`copy`、`mutableCopy`，`retain`，`release`、`autorelease`，`dealoc`这几个方法操作引用计数，来管理对象内存管理的，即：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628181747.png)\n\n```cpp\n// NSObject.mm\n- (void)release {\n    self->rootRelease();\n}\n\nbool objc_object::rootRelease()\n{\n    return rootRelease(true, false);\n}\n\nbool objc_object::rootRelease(bool performDealloc, bool handleUnderflow)\n{\n    if (isTaggedPointer()) return false;\n\n    isa_t newisa = LoadExclusive(&isa.bits);\n\n    if (!newisa.nonpointer) {\n        \n        // 去引用计数表里让它的引用计数-1\n        return sidetable_release(performDealloc);\n    }\n    \n\n    // 用来标识extra_rc是否下溢——即是否减为-1（因为extra_rc存储的是（引用计数 - 1），所以减为0的时候说明引用计数为1，还有人引用它，没事儿）\n    uintptr_t carry;\n    // 首先去isa共用体里，让对象的引用计数-1\n    newisa.bits = subc(newisa.bits, RC_ONE, 0, &carry);\n    if (carry) { // 所以如果extra_rc下溢了：\n    \n        goto underflow; // 跳转到underflow处执行\n    }\n\n    // 表明没有下溢，结束\n    return false;\n\n underflow: // extra_rc下溢了：\n\n    newisa = LoadExclusive(&isa.bits);\n\n    if (newisa.has_sidetable_rc) { // 如果引用计数表里有当前对象的引用计数，说明还有人使用该对象\n\n        // 尝试从引用计数表搬回来128个引用计数\n        size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF);\n        if (borrowed) { // 如果搬成功了\n            \n            // 存进去\n            newisa.extra_rc = borrowed - 1;\n            // 更新一下对象的isa共用体\n            isa = newisa;\n        } else { // 搬失败了，说明引用计数表里的引用计数也为0了（可能是被上一次搬完了）\n            \n            // 走dealloc方法销毁该对象\n            ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n        }\n    } else { // 引用计数表里没有当前对象的引用计数，说明没人使用该对象了\n        \n        // 走dealloc方法销毁该对象\n        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);\n    }\n    \n    return true;\n}\n\n// 尝试从引用计数表搬回来128个引用计数\nsize_t objc_object::sidetable_subExtraRC_nolock(size_t delta_rc)\n{\n    SideTable& table = SideTables()[this];\n    RefcountMap::iterator it = table.refcnts.find(this);\n    \n    if (it == table.refcnts.end()  ||  it->second == 0) { // 引用计数表里的引用计数被上一次搬完了\n\n        return 0;\n    }\n    \n    // 引用计数表里的引用计数-128，搬出去\n    size_t oldRefcnt = it->second;\n    size_t newRefcnt = oldRefcnt - (delta_rc << SIDE_TABLE_RC_SHIFT);\n    it->second = newRefcnt;\n    \n    return delta_rc;\n}\n```\n\n>关于`autorelease`和`autoreleasepool`就暂时理解这么一点，更底层的东西有空再说：\n>\n>- `release`会立即使对象的引用计数-1，而`autorelease`则不会，它仅仅是把该对象注册到了`autoreleasepool`中，当`autoreleasepool`销毁时系统会自动让池中所有的对象都调用一下`release`，这时对象的引用计数才-1。\n>- 而`autoreleasepool`又是在RunLoop休眠或退出时销毁的，当然如果是我们自己创建的`@autoreleasepool{}`，出了大括号——即出了`@autoreleasepool{}`的生命周期，它就会销毁。\n>- 只要不是用`alloc`、`new`、`copy`、`mutableCopy`方法创建的对象，而是用类方法创建的对象，方法内部都调用了`autorelease`，都是`autorelease`对象。\n\n- 如果对象的引用计数减为0了，就代表没人想使用该对象了，系统就会调用`dealloc`方法销毁它，并释放它对应的内存，对象一经销毁就不能再访问了，因为他的内存随时会被移作它用。\n\n  ![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628182915.png)\n\n```cpp\n// NSObject.mm\n- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid _objc_rootDealloc(id obj)\n{\n    obj->rootDealloc();\n}\n\nvoid objc_object::rootDealloc()\n{\n    if (\n        !isa.has_cxx_dtor  && // 如果当前对象没使用过C++析构函数\n        !isa.has_assoc  && // 如果当前对象没有关联对象\n        !isa.weakly_referenced  && // 如果弱引用表里没有当前对象的弱指针数组\n        !isa.has_sidetable_rc // 如果引用计数表里没有当前对象的引用计数\n        )\n    {\n        // 就直接销毁对象，并释放它对应的内存，即我们之前说的对象销毁时会更快\n        free(this);\n    } else {\n        \n        // 否则就慢慢销毁\n        object_dispose(this);\n    }\n}\n\nid object_dispose(id obj)\n{\n    objc_destructInstance(obj);\n    // 销毁对象，并释放它对应的内存，\n    free(obj);\n\n    return nil;\n}\n\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        \n        // 如果当前对象使用过C++析构函数\n        bool cxx = obj->hasCxxDtor();\n        // 如果当前对象有关联对象\n        bool assoc = obj->hasAssociatedObjects();\n\n        // 要按顺序销毁哦\n        if (cxx) object_cxxDestruct(obj); // 销毁C++析构函数相关的东西\n        if (assoc) _object_remove_assocations(obj); // 移除关联对象\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n\nvoid objc_object::clearDeallocating()\n{\n    clearDeallocating_slow();\n}\n\nvoid objc_object::clearDeallocating_slow()\n{\n    // 获取SideTable\n    SideTable& table = SideTables()[this];\n\n    if (isa.weakly_referenced) { // 如果弱引用表里有当前对象的弱指针数组\n        \n        // 把弱引用表里所有指向该对象的弱指针都置为nil，并移除，从此弱引用表里就没有该对象的弱指针数组（关于弱指针（弱引用）更多详细的内容，见下面__weak指针的实现原理）\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    \n    if (isa.has_sidetable_rc) { // 如果引用计数表里有当前对象的引用计数\n        \n        // 从引用计数表里把该对象的引用计数给抹掉，从此引用计数表里就没有该对象的引用计数了\n        table.refcnts.erase(this);\n    }\n}\n```\n\n### 二、MRC介绍，需要开发工程师做哪些工作\n\nMRC（*Manual Reference Count*）：指手动管理引用计数，即需要程序员自己手动调用上面那几个`alloc`、`new`、`alloc`、`copy`、`mutableCopy`，`retain`，`release`、`autorelease`，`dealoc`方法来操作引用计数，从而完成对象的内存管理。具体地说，MRC下我们需要做到以下三点：\n\n- 调用了`alloc`、`new`、`alloc`、`copy`、`mutableCopy`创建对象的地方，在不想使用对象时，要调用\n\n`release`、`autorelease`；调用了`retain`使对象引用计数+1的地方，在不想使用对象时，要调用\n\n`release`、`autorelease`来使对象的引用计数-1。\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    // 调用了alloc、new、copy、mutableCopy创建对象\n    NSArray *arr = [[NSArray alloc] init];\n    NSArray *arr1 = [NSArray new];\n    NSArray *arr2 = [arr copy];\n    NSMutableArray *arr3 = [arr1 mutableCopy];\n    \n    // 调用release、autorelease来释放对象\n    [arr release];\n    [arr1 release];\n    [arr2 autorelease];\n    [arr3 autorelease];\n}\n\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n  \n    NSArray *arr = [NSArray array];\n    // 调用了retain使对象引用计数+1\n    [arr retain];\n\n    // 要调用release、autorelease来使对象的引用计数-1\n    [arr release];\n  \n    //或者调用下面\n    //[arr autorelease];\n}\n```\n\n- 我们还需要处理好`setter`方法内部的内存管理，并在`dealloc`方法里释放当前类及其父类**所有对象类型**的成员变量。\n\n```objectivec\n@implementation INEPerson {\n    int _age;\n    NSString *_name;\n    INEDog *_dog;\n}\n\n- (void)setAge:(int)age {\n    \n    _age = age; // 直接赋值\n}\n\n- (void)setName:(NSString *)name {\n\n    if (_name != name) { // 新旧对象不一样时\n        \n        [_name release]; // 释放旧对象\n        _name = [name copy]; // 复制新对象\n    }\n}\n\n- (void)setDog:(INEDog *)dog {\n    \n    if (_dog != dog) { // 新旧对象不一样时\n        \n        [_dog release]; // 释放旧对象\n        _dog = [dog retain]; // 持有新对象\n    }\n}\n\n- (void)dealloc {\n    \n    // 释放当前类所有对象类型的成员变量\n    [self setName:nil];\n    [self setDog:nil];\n\n    // 释放父类所有对象类型的成员变量，放在最后\n    [super dealloc];\n}\n\n@end\n```\n\n- 我们还需要处理好循环引入问题。\n\n```objective-c\n//稍后补充\n```\n\n\n\n#### 三、ARC介绍，编译器帮我们做了什么\n\nARC（*Autal Reference Count*）：自动管理引用计数，让**编译器**进行内存管理，**在LVVM编译器中设置ARC为有效状态，就无需再次键入`retain`、`realeas`、`autorelease`代码，编译器会在合适的地方自动帮我们插入`retain`、`release`、`autorelease`等方法的调用，从而完成对象的内存管理。但实际上除了编译器之外，ARC还用到了Runtime，比如`weak`指针的清空。**这样就会在降低程序崩溃、内存泄漏风险的同时，很大程度程度减少了开发的工作量，使应用程序具有可预测性，且能流畅运行，速度也将大幅提升。具体来说，与MRC相对应，ARC帮我们做了如下三点：\n\n- 利用`__strong`指针修饰符，编译器会在合适的地方帮们插入`retain`、`release`、`autorelease`等方法的调用；\n\n- 利用属性修饰符，编译器为我们生成特定的`setter`方法并处理好内部的内存管理，还会自动在`dealloc`方法里释放当前类及其父类的成员变量；\n\n- 利用`__weak`指针修饰符和Runtime，来处理循环引入问题。\n\n#### 1.指针修饰符\n\n- `__strong`指针修饰符\n\n  凡是用`__strong`修饰的指针，在超出其作用域时，编译器会为我们插入一次`release`或`autorelease`的调用。\n\n  ```objectivec\n  // ARC下\n  {\n      __strong id obj = [[NSObject alloc] init];\n      __strong id arr = [NSArray array];\n  }\n  \n  等价于：\n  \n  // MRC下\n  {\n      id obj = [[NSObject alloc] init];\n      id arr = [[NSArray alloc] init];\n      \n      [obj release];\n      [arr autorelease];\n  }\n  ```\n\n而在指针赋值时，编译器会自动为我们插入一次`retain`的调用。\n\n```objectivec\n// ARC下\n{\n    __strong id obj = [[NSObject alloc] init];\n    __strong id obj1 = obj;\n}\n\n等价于：\n\n// MRC下\n{\n    id obj = [[NSObject alloc] init];\n    id obj1 = [obj retain];\n    \n    [obj release];\n    [obj1 release];\n}\n```\n\n所以正是因为使用`__strong`指针修饰符，编译器才会在合适的地方帮我们插入`retain`、`release`、`autorelease`等方法的调用，而ARC下所有指针默认都是用`__strong`修饰的。\n\n- `__weak`指针修饰符\n\n看起来有了`strong`,编译器就可以很好的管理内存了，但是很重要的一点是`__strong`无法解决引用计数式内存管理必然会导致的“循环引入”问题。\n\n```objective-c\n//稍后补充\n```\n\n#### 2.属性修饰符\n\n属性修饰符一共有三对儿：**原子性、读写权限和内存管理语意**，属性修饰符主要影响就是编译器为成员变量生成的`setter`、`getter`方法上。（这里除了讲解和内存相关的知识外，其他的也回顾一下）\n\n> 原子性：`atomic`（默认）、`nonatomic`\n\n- `atomic`：默认为`atomic`，使用`atomic`修饰的属性，编译器为该属性生成的`setter`、`getter`方法内部是加了锁的。\n\n  ```objectivec\n  @property (atomic, strong) NSMutableArray *array;\n  \n  - (void)setArray:(NSMutableArray *)array {\n      \n      // 加锁\n      _array = array;\n      // 解锁\n  }\n  \n  - (NSMutableArray *)array {\n      // 加锁\n      return _array;\n      // 解锁\n  }\n  ```\n\n但这仅仅是保证我们调用`setter`、`getter`方法访问属性这一步是线程安全的，它没发保证我们使用属性的线程是安全的，比如我们调用`[self.array addObject:xxx]`,`self.array`访问属性这一步是线程安全的，但`addObject:`使用属性这一步是线程不安全的。\n\n```objective-c\n// 线程1\n[self.array addObject:@\"11\"];\n// 线程2\n[self.array addObject:@\"12\"];\n\n等价于\n\n// 线程1\n[[self array] addObject:@\"11\"];\n// 线程2\n[[self array] addObject:@\"12\"];\n```\n\n所以为了保证使用属性的线程安全，我们还得在需要的地方自己加锁，这样一来使用使用`atomic`修饰属性就多此一举了，而且`stter`、`getter`方法的调用通常都是很频繁的，内部加锁的话会增加内存的开销，耗费性能。\n\n```php\n// 线程1\n// 加锁\n[self.array addObject:@\"11\"];\n// 解锁\n\n// 线程2\n// 加锁\n[self.array addObject:@\"12\"];\n// 解锁\n```\n\n- `nonatomic`：因此我们在实际开发中总是使用`nonatomic`。\n\n> 读写权限：`readwrite`(默认)、`readonly`\n\n- `readwrite`：默认为`readwrite`，代表该属性可读可写，编译器会为该属性生成`setter`\n\n`getter`方法的声明与实现。\n\n- `readonly`：代表该属性只能读取不能写入，编译器会为该属性生成`setter`、`getter`方法的声明与`getter`方法的实现。\n\n> 内存管理语意：\n>\n> - MRC下有：`assign`、`retain`、`copy`。\n> - ARC下新增了：`strong`、`weak`、`unsafe_unretained`。\n\n- `assign`：`assign`一般来修饰基本数据类型。使用`assign`修饰属性，编译器为属性生成的`setter`方法内部只是简单的赋值操作。\n\n```cpp\n- (void)setAge:(int)age {\n    \n    // 简单的赋值操作\n    _age = age;\n}\n```\n\n- `retain`：`retain`一般用来修饰对象类型。使用`retain`修饰的属性，编译器为该属性生成的`setter`方法内部会调用一下`retain`方法，是对象的引用计数+1。\n\n  ```objective-c\n  - (void)setDog:(Dog *)dog {\n      \n      if (_dog != dog) { // 新旧对象不一样时\n          \n          [_dog release]; // 释放旧对象\n          _dog = [dog retain]; // 持有新对象\n      }\n  }\n  ```\n\n- `copy`：`copy`一般用来修饰不可变属性和block。使用`copy`修饰的属性，编译器为该属性生成的`setter`方法内部会调用一下`copy`方法，生成一个新的对象，新对象的引用计数为1，而旧对象的引用计数不变。\n\n  ```objectivec\n  - (void)setName:(NSString *)name {\n  \n      if (_name != name) { // 新旧对象不一样时\n          \n          [_name release]; // 释放旧对象\n          _name = [name copy]; // 复制新对象\n      }\n  }\n  ```\n\n- `strong`：默认为`strong`，大多数情况下和`retain`的效果是一样的，修饰block和`copy`的效果是一样的，`strong`一般用来修饰对象类型。\n- `weak`：`weak`一般用来修饰代理对象和`NSTimer`，以免造成循环引入；还有用来修饰xib或sb拖出来的控件，因为这些界面已经被添加到界面上了，被subviews这个属性持有了，不必再用变量持有。\n\n- `unsafe_unretained`：和`assign`效果是一样的，如果用他们来修饰对象类型，和`weak`功能类似，但`weak`修饰的属性会在对象销毁时会被置为`nil`，比较安全，而`unsafe_unretained`和`assign`修饰的属性则不会，所以容易出现野指针。\n\n","slug":"内存管理一","published":1,"updated":"2022-07-06T06:02:40.732Z","_id":"cl4y1tfwm00002cfy9dri58wq","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>一、iOS内存管理方式：</p>\n<p>​    1.Tagged Pointer：小对象的内存管理方式</p>\n<p>​    2.引用计数：普通对象的内存管理方式</p>\n<p>二、MRC介绍，需要开发工程师做哪些工作</p>\n<p>三、ARC介绍，编译器帮我们做了什么</p>\n<span id=\"more\"></span>\n\n<p>​    1.指针修饰符</p>\n<p>​        1. __strong</p>\n<p>​        2. __weak</p>\n<p>​        3. __unsafe_unretained</p>\n<p>​        4. __autoreease</p>\n<p>​    2.属性修饰符</p>\n<p>​        2.1 原子性：<code>atomic</code>、<code>nonatomic</code></p>\n<p>​        2.2 读写权限：<code>readwrite</code>、<code>readonly</code></p>\n<p>​        2.3 内存管理语义：<code>assign</code>、<code>retain</code>、<code>copy</code>、<code>strong</code>、<code>weak</code>、<code>unsafe_unretained</code></p>\n</blockquote>\n<h3 id=\"一、内存管理方式：\"><a href=\"#一、内存管理方式：\" class=\"headerlink\" title=\"一、内存管理方式：\"></a>一、内存管理方式：</h3><h4 id=\"1-Tagged-Pointer：小对象的内存管理方式\"><a href=\"#1-Tagged-Pointer：小对象的内存管理方式\" class=\"headerlink\" title=\"1.Tagged Pointer：小对象的内存管理方式\"></a>1.Tagged Pointer：小对象的内存管理方式</h4><p>64位操作系统后，iOS引入了Tagged Pointer，用来优化NSString、NSNumber、NSDate的内存管理。</p>\n<p>引入Tagged Pointer之前（32位操作系统时），小对象内存管理方式和普通对象一样，首先需要在堆区开辟一块内存，并把内存的地址赋值给栈区的指针变量，然后维护对象的引用计数和内存的释放。</p>\n<p>比如我们创建一个int类型的NSNumber对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNumber *number = @11;</span><br></pre></td></tr></table></figure>\n\n<p>系统需要开辟16个字节的内存来存储11这个值，同时需要开辟8个字节大小的内存来存储这个对象的地址，本来需要占用4个字节的内存的Int类型数据，占用了24个字节，同时还没考虑维护引用计数和内存释放等的内存开销。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/nsnumber.png\" alt=\"使用Tagged pointer前的内存管理\"></p>\n<p>在引入Tagged Pointer之后，<strong>小对象就不需要像之前那样 在堆区开辟内存，维护引用计数，释放内存了。而是直接把值存到了number指针里，number里面存的不再是一个地址了，而是Tag + Data，Tag是用来标记小对象的类型（NSString、NSNumber、NSDate），Data就是小对象的值。指针什么时候创建，小对象就什么时候创建，指针什么时候销毁，小对象就什么时候销毁。只有在指针存不下小对象的值时，才会变为引用计数的方式管理内存。</strong>这样，仅需要8个字节就可以存储小对象的类型和值，很大程度上节省了内存占用，同时也减少了维护引用计数、内存释放等带来的开销。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E4%BD%BF%E7%94%A8Tagged.png\" alt=\"使用Tagged Pointer后的内存管理\"></p>\n<p>用代码验证一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  苹果对Tagged Pointer做了数据混淆，所以在分析Tagged Pointer之前，我们需要先关闭Tagged Pointer的数据混淆。通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为YES。否则无法分析打印出的结果</span><br><span class=\"line\">- (void)testTaggedPointer &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSNumber *number1 = @1;</span><br><span class=\"line\">    NSNumber *number2 = @2;</span><br><span class=\"line\">    NSNumber *number3 = @10;</span><br><span class=\"line\">    NSNumber *number4 = @(0xFFFFFFFFFFFFFFFF);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;number1:%p&quot;, number1);</span><br><span class=\"line\">    NSLog(@&quot;number2:%p&quot;, number2);</span><br><span class=\"line\">    NSLog(@&quot;number3:%p&quot;, number3);</span><br><span class=\"line\">    NSLog(@&quot;number4:%p&quot;, number4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">number1:0xb000000000000012</span><br><span class=\"line\">number2:0xb000000000000022</span><br><span class=\"line\">number3:0xb0000000000000a2</span><br><span class=\"line\">number4:0x600001be2060</span><br></pre></td></tr></table></figure>\n\n<p>number1～number3指针是Tagged Pointer，number4由于值大到存储不下了，改为普通对象内存管理方式。对应的地址分布规律见下图（mac os系统的规律与iOS系统的规律不同 <a href=\"https://cloud.tencent.com/developer/article/1620346\">详细</a>），可发现规律<strong>如果一个指针的最高位为1，那么他就是Tagged Pointer，否则就不是。</strong></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623191932.png\" alt=\"ios-nsnumber\"></p>\n<p>如果是NSString的话，Tagged Pointer内存地址分布规律就是下面这样的：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623195417.png\" alt=\"ios-nsstring\"></p>\n<p>学习完上面内容，我们举个例子验证下，找不同：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开辟多个线程去修改name属性</span></span><br><span class=\"line\"><span class=\"comment\">// 代码1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@&quot;abcdefghijk&quot;</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代码2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@&quot;abc&quot;</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行代码我们会发现 代码1 会crash，因为<code>abcdefghijk</code>已经大到指针存储不下，改为了普通对象内存管理方式，所以 代码1 就是正常的调用<code>setter</code>方法修改<code>name</code>属性,<code>setter</code>的实现是这样的：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不加锁的情况下，极容易发生多个线程同时调用<code>[_name release]</code>的情况，若<code>_name</code>已经销毁，再次调用<code>release</code>肯定会发生crash。</p>\n<p>代码2 正常运行，是因为<code>abc</code>并没有大到指针存储不下，<code>NSString</code>为<code>NSTaggedPointerString</code>类型，在<code>objc_release</code>函数中会判断指针是不是<code>TaggedPointer</code>类型，是的话就不对对象进行<code>release</code>操作，也就避免了因过度释放对象而导致的<code>Crash</code>，因为根本就没执行释放操作。</p>\n<h4 id=\"2-引用计数：普通对象的内存管理方式\"><a href=\"#2-引用计数：普通对象的内存管理方式\" class=\"headerlink\" title=\"2.引用计数：普通对象的内存管理方式\"></a>2.引用计数：普通对象的内存管理方式</h4><p><strong>2.1 引用计数是什么？</strong></p>\n<p><strong>iOS是通过引用计数来管理内存的。所谓的引用计数就是指每当我们创建一个对象，系统就会为该对象分配一个整数，用来表征当前有多少人想使用该对象。</strong>那就引出两个问题：</p>\n<p>问题1：创建对象时，系统为对象分配的整数存在哪里？也就是引用计数存在哪里？因为我们知道OC对象内部只有一个<code>isa</code>，并没有引用计数的成员变量</p>\n<p>问题2：iOS具体是怎么通过引用计数来管理内存的？</p>\n<p><strong>2.2 引用计数存储在哪里？</strong></p>\n<p>64位操作系统以前，对象的<code>isa</code>指针还没进行内存优化，对象的引用计数存储在引用计数表里。</p>\n<p>当系统为64位操作系统后，对象的<code>isa</code>指针经过了内存优化，它不再直接是一个指针了，而是一个共用体，64位中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1），还有1位用来标记引用计数表里是否有当前对象的引用计数。具体地说：<strong>对象的引用计数首先会存储在<code>isa</code>共用体里——<code>extra_rc</code>变量，但是<code>isa</code>共用体的引用计数存储范围是0～255，一旦引用计数超过了255，这个变量就会溢出，此时系统会把这个变量置为128，同时把引用计数表里是否有当前对象的引用计数的标记——<code>has_sidetable_rc</code>变量置为1，并把另外128个引用计数挪到引用计数表里进行存储。下一次对象的引用计数再次增加时，依旧增加<code>isa</code>共用体里的引用计数（因为它已被置为128，不再是溢出状态），直到再次溢出，系统再娜128个引用计数到引用计数表里，如此循环往复。</strong></p>\n<p>因此可以看出，系统是不会直接操作引用计数表里的引用计数的，而总是在操作<code>isa</code>共用体里的引用计数，直到溢出时才从<code>isa</code>共用体里挪128个引用计数到引用计数表里进行存储。</p>\n<ul>\n<li><p><code>isa</code>共用体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">objc_object</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">isa_t</span> isa; <span class=\"comment\">// 一个isa_t类型的共用体</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义的成员变量，存储着该对象这些成员变量具体的值</span></span><br><span class=\"line\">    NSSring *_name; <span class=\"comment\">// “张三”</span></span><br><span class=\"line\">    NSSring *_sex; <span class=\"comment\">// “男”</span></span><br><span class=\"line\">    <span class=\"type\">int</span> _age; <span class=\"comment\">// 33</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">isa_t</span> &#123;</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> bits; <span class=\"comment\">// 8个字节，64位</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">// 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着谁的数据</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">if</span> __arm64__</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"keyword\">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> nonpointer        : <span class=\"number\">1</span>; <span class=\"comment\">// isa是否经过内存优化</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_assoc         : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_cxx_dtor      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> shiftcls          : <span class=\"number\">33</span>; <span class=\"comment\">// 对象所属类的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> magic             : <span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> weakly_referenced : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> deallocating      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_sidetable_rc  : <span class=\"number\">1</span>; <span class=\"comment\">// 引用计数表里是否有当前对象的引用计数</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> extra_rc          : <span class=\"number\">19</span>; <span class=\"comment\">// 对象的引用计数 - 1</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>SideTables</code>–&gt;<code>SideTable</code>–&gt;引用计数表、若引用表</p>\n</li>\n</ul>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220627183629.png\" alt=\"SideTables\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class=\"line\">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct SideTable &#123;</span><br><span class=\"line\">    spinlock_t slock; // 自旋锁</span><br><span class=\"line\">    RefcountMap refcnts; // 引用计数表</span><br><span class=\"line\">    weak_table_t weak_table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef objc::DenseMap&lt;objc_object */*对象的内存地址*/, unsigned long/*对象的引用计数*/&gt; RefcountMap;</span><br><span class=\"line\"></span><br><span class=\"line\">struct weak_table_t &#123;</span><br><span class=\"line\">    weak_entry_t *weak_entries; // 这个其实才是弱引用表，表中元素为weak_entry_t结构体</span><br><span class=\"line\">    size_t    num_entries;</span><br><span class=\"line\">    uintptr_t mask;</span><br><span class=\"line\">    uintptr_t max_hash_displacement;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    objc_object *obj; // 对象的内存地址</span><br><span class=\"line\">    weak_referrer_t *referrers; // 指向该对象的弱指针数组——即所有指向该对象的弱指针（其实存储的是弱指针对应那块内存的地址，但是我们直接理解为弱指针是没有问题的）</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 例如：</span><br><span class=\"line\">id obj = [[NSObject alloc] init];</span><br><span class=\"line\">__weak id weakObj1 = obj;</span><br><span class=\"line\">__weak id weakObj2 = obj;</span><br><span class=\"line\">__weak id weakObj3 = obj;</span><br><span class=\"line\"></span><br><span class=\"line\">// NSObject对象的weak_entry为：</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    objc_object *obj; // 对象的内存地址</span><br><span class=\"line\">    weak_referrer_t *referrers; // 指向该对象的弱指针数组</span><br><span class=\"line\">&#125; NSObjectWeakEntry = &#123;</span><br><span class=\"line\">    obj;</span><br><span class=\"line\">    [weakObj1, weakObj2, weakObj3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>SideTables</code>是一个全局的散列表，它里面存储着64个<code>SideTable</code>结构体，而每个<code>SideTable</code>结构体内部又存储着1个引用计数表和1个弱引用计数表，所以项目中一般会有64个引用计数表和64个弱引用计数表。引用计数表也是一个散列表，表中的元素是一个字典：<code>key</code>为对象的内存地址，<code>value</code>为对象的引用计数，引用计数表里存储着很多对象的引用计数。若引用计数表也是一个散列表，表中的元素是一个结构体：一个成员变量是对象的内存地址，另一个成员变量是指向该对象的弱指针数组。</p>\n<p>所以如果我们想要找到对象的引用计数和弱指针数组，就要首先把对象的内存地址通过某种散列算法得到一个<code>index</code>，就可以在<code>SideTables</code>里找到对象的引用计数和弱指针数组所在的<code>SideTable</code>结构体，也就是找到了引用计数和弱指针数组所在的引用计数表和弱引用计数表，然后再次把对象的内存地址通过某种散列算法得到一个<code>index</code>，就可以在引用计数表里找到对象的引用计数，弱引用计数表里找到对象的弱指针数组了。</p>\n<p><strong>2.3 iOS具体是怎么通过引用计数来进行对象的内存管理的</strong></p>\n<p>主要是通过<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>，<code>retain</code>，<code>release</code>、<code>autorelease</code>，<code>dealoc</code>这几个方法操作引用计数，来管理对象内存管理的，即：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628181747.png\" alt=\"img\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NSObject.mm</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)release &#123;</span><br><span class=\"line\">    self-&gt;<span class=\"built_in\">rootRelease</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">objc_object::rootRelease</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">rootRelease</span>(<span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">objc_object::rootRelease</span><span class=\"params\">(<span class=\"type\">bool</span> performDealloc, <span class=\"type\">bool</span> handleUnderflow)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isTaggedPointer</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">isa_t</span> newisa = <span class=\"built_in\">LoadExclusive</span>(&amp;isa.bits);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newisa.nonpointer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 去引用计数表里让它的引用计数-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">sidetable_release</span>(performDealloc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用来标识extra_rc是否下溢——即是否减为-1（因为extra_rc存储的是（引用计数 - 1），所以减为0的时候说明引用计数为1，还有人引用它，没事儿）</span></span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> carry;</span><br><span class=\"line\">    <span class=\"comment\">// 首先去isa共用体里，让对象的引用计数-1</span></span><br><span class=\"line\">    newisa.bits = <span class=\"built_in\">subc</span>(newisa.bits, RC_ONE, <span class=\"number\">0</span>, &amp;carry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (carry) &#123; <span class=\"comment\">// 所以如果extra_rc下溢了：</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> underflow; <span class=\"comment\">// 跳转到underflow处执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表明没有下溢，结束</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> underflow: <span class=\"comment\">// extra_rc下溢了：</span></span><br><span class=\"line\"></span><br><span class=\"line\">    newisa = <span class=\"built_in\">LoadExclusive</span>(&amp;isa.bits);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newisa.has_sidetable_rc) &#123; <span class=\"comment\">// 如果引用计数表里有当前对象的引用计数，说明还有人使用该对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 尝试从引用计数表搬回来128个引用计数</span></span><br><span class=\"line\">        <span class=\"type\">size_t</span> borrowed = <span class=\"built_in\">sidetable_subExtraRC_nolock</span>(RC_HALF);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (borrowed) &#123; <span class=\"comment\">// 如果搬成功了</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 存进去</span></span><br><span class=\"line\">            newisa.extra_rc = borrowed - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 更新一下对象的isa共用体</span></span><br><span class=\"line\">            isa = newisa;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 搬失败了，说明引用计数表里的引用计数也为0了（可能是被上一次搬完了）</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 走dealloc方法销毁该对象</span></span><br><span class=\"line\">            ((<span class=\"built_in\">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class=\"keyword\">this</span>, SEL_dealloc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 引用计数表里没有当前对象的引用计数，说明没人使用该对象了</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 走dealloc方法销毁该对象</span></span><br><span class=\"line\">        ((<span class=\"built_in\">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class=\"keyword\">this</span>, SEL_dealloc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试从引用计数表搬回来128个引用计数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">objc_object::sidetable_subExtraRC_nolock</span><span class=\"params\">(<span class=\"type\">size_t</span> delta_rc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SideTable&amp; table = <span class=\"built_in\">SideTables</span>()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\">    RefcountMap::iterator it = table.refcnts.<span class=\"built_in\">find</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == table.refcnts.<span class=\"built_in\">end</span>()  ||  it-&gt;second == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 引用计数表里的引用计数被上一次搬完了</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 引用计数表里的引用计数-128，搬出去</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> oldRefcnt = it-&gt;second;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT);</span><br><span class=\"line\">    it-&gt;second = newRefcnt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> delta_rc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于<code>autorelease</code>和<code>autoreleasepool</code>就暂时理解这么一点，更底层的东西有空再说：</p>\n<ul>\n<li><code>release</code>会立即使对象的引用计数-1，而<code>autorelease</code>则不会，它仅仅是把该对象注册到了<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时系统会自动让池中所有的对象都调用一下<code>release</code>，这时对象的引用计数才-1。</li>\n<li>而<code>autoreleasepool</code>又是在RunLoop休眠或退出时销毁的，当然如果是我们自己创建的<code>@autoreleasepool&#123;&#125;</code>，出了大括号——即出了<code>@autoreleasepool&#123;&#125;</code>的生命周期，它就会销毁。</li>\n<li>只要不是用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法创建的对象，而是用类方法创建的对象，方法内部都调用了<code>autorelease</code>，都是<code>autorelease</code>对象。</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>如果对象的引用计数减为0了，就代表没人想使用该对象了，系统就会调用<code>dealloc</code>方法销毁它，并释放它对应的内存，对象一经销毁就不能再访问了，因为他的内存随时会被移作它用。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628182915.png\" alt=\"img\"></p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NSObject.mm</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    _objc_rootDealloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> _objc_rootDealloc(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    obj-&gt;<span class=\"built_in\">rootDealloc</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::rootDealloc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !isa.has_cxx_dtor  &amp;&amp; <span class=\"comment\">// 如果当前对象没使用过C++析构函数</span></span><br><span class=\"line\">        !isa.has_assoc  &amp;&amp; <span class=\"comment\">// 如果当前对象没有关联对象</span></span><br><span class=\"line\">        !isa.weakly_referenced  &amp;&amp; <span class=\"comment\">// 如果弱引用表里没有当前对象的弱指针数组</span></span><br><span class=\"line\">        !isa.has_sidetable_rc <span class=\"comment\">// 如果引用计数表里没有当前对象的引用计数</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 就直接销毁对象，并释放它对应的内存，即我们之前说的对象销毁时会更快</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 否则就慢慢销毁</span></span><br><span class=\"line\">        <span class=\"built_in\">object_dispose</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">id <span class=\"title\">object_dispose</span><span class=\"params\">(id obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">objc_destructInstance</span>(obj);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁对象，并释放它对应的内存，</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">objc_destructInstance</span><span class=\"params\">(id obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果当前对象使用过C++析构函数</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> cxx = obj-&gt;<span class=\"built_in\">hasCxxDtor</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前对象有关联对象</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> assoc = obj-&gt;<span class=\"built_in\">hasAssociatedObjects</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 要按顺序销毁哦</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cxx) <span class=\"built_in\">object_cxxDestruct</span>(obj); <span class=\"comment\">// 销毁C++析构函数相关的东西</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (assoc) _object_remove_assocations(obj); <span class=\"comment\">// 移除关联对象</span></span><br><span class=\"line\">        obj-&gt;<span class=\"built_in\">clearDeallocating</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::clearDeallocating</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearDeallocating_slow</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::clearDeallocating_slow</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取SideTable</span></span><br><span class=\"line\">    SideTable&amp; table = <span class=\"built_in\">SideTables</span>()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.weakly_referenced) &#123; <span class=\"comment\">// 如果弱引用表里有当前对象的弱指针数组</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 把弱引用表里所有指向该对象的弱指针都置为nil，并移除，从此弱引用表里就没有该对象的弱指针数组（关于弱指针（弱引用）更多详细的内容，见下面__weak指针的实现原理）</span></span><br><span class=\"line\">        <span class=\"built_in\">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.has_sidetable_rc) &#123; <span class=\"comment\">// 如果引用计数表里有当前对象的引用计数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 从引用计数表里把该对象的引用计数给抹掉，从此引用计数表里就没有该对象的引用计数了</span></span><br><span class=\"line\">        table.refcnts.<span class=\"built_in\">erase</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、MRC介绍，需要开发工程师做哪些工作\"><a href=\"#二、MRC介绍，需要开发工程师做哪些工作\" class=\"headerlink\" title=\"二、MRC介绍，需要开发工程师做哪些工作\"></a>二、MRC介绍，需要开发工程师做哪些工作</h3><p>MRC（<em>Manual Reference Count</em>）：指手动管理引用计数，即需要程序员自己手动调用上面那几个<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>，<code>retain</code>，<code>release</code>、<code>autorelease</code>，<code>dealoc</code>方法来操作引用计数，从而完成对象的内存管理。具体地说，MRC下我们需要做到以下三点：</p>\n<ul>\n<li>调用了<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>创建对象的地方，在不想使用对象时，要调用</li>\n</ul>\n<p><code>release</code>、<code>autorelease</code>；调用了<code>retain</code>使对象引用计数+1的地方，在不想使用对象时，要调用</p>\n<p><code>release</code>、<code>autorelease</code>来使对象的引用计数-1。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 调用了alloc、new、copy、mutableCopy创建对象</span></span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr1 = [<span class=\"built_in\">NSArray</span> new];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr2 = [arr <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *arr3 = [arr1 mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 调用release、autorelease来释放对象</span></span><br><span class=\"line\">    [arr release];</span><br><span class=\"line\">    [arr1 release];</span><br><span class=\"line\">    [arr2 autorelease];</span><br><span class=\"line\">    [arr3 autorelease];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">    <span class=\"comment\">// 调用了retain使对象引用计数+1</span></span><br><span class=\"line\">    [arr <span class=\"keyword\">retain</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 要调用release、autorelease来使对象的引用计数-1</span></span><br><span class=\"line\">    [arr release];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//或者调用下面</span></span><br><span class=\"line\">    <span class=\"comment\">//[arr autorelease];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们还需要处理好<code>setter</code>方法内部的内存管理，并在<code>dealloc</code>方法里释放当前类及其父类<strong>所有对象类型</strong>的成员变量。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> _age;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_name;</span><br><span class=\"line\">    INEDog *_dog;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setAge:(<span class=\"type\">int</span>)age &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _age = age; <span class=\"comment\">// 直接赋值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setDog:(INEDog *)dog &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_dog != dog) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_dog release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _dog = [dog <span class=\"keyword\">retain</span>]; <span class=\"comment\">// 持有新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 释放当前类所有对象类型的成员变量</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setName:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setDog:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放父类所有对象类型的成员变量，放在最后</span></span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们还需要处理好循环引入问题。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//稍后补充</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"三、ARC介绍，编译器帮我们做了什么\"><a href=\"#三、ARC介绍，编译器帮我们做了什么\" class=\"headerlink\" title=\"三、ARC介绍，编译器帮我们做了什么\"></a>三、ARC介绍，编译器帮我们做了什么</h4><p>ARC（<em>Autal Reference Count</em>）：自动管理引用计数，让<strong>编译器</strong>进行内存管理，<strong>在LVVM编译器中设置ARC为有效状态，就无需再次键入<code>retain</code>、<code>realeas</code>、<code>autorelease</code>代码，编译器会在合适的地方自动帮我们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用，从而完成对象的内存管理。但实际上除了编译器之外，ARC还用到了Runtime，比如<code>weak</code>指针的清空。</strong>这样就会在降低程序崩溃、内存泄漏风险的同时，很大程度程度减少了开发的工作量，使应用程序具有可预测性，且能流畅运行，速度也将大幅提升。具体来说，与MRC相对应，ARC帮我们做了如下三点：</p>\n<ul>\n<li><p>利用<code>__strong</code>指针修饰符，编译器会在合适的地方帮们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用；</p>\n</li>\n<li><p>利用属性修饰符，编译器为我们生成特定的<code>setter</code>方法并处理好内部的内存管理，还会自动在<code>dealloc</code>方法里释放当前类及其父类的成员变量；</p>\n</li>\n<li><p>利用<code>__weak</code>指针修饰符和Runtime，来处理循环引入问题。</p>\n</li>\n</ul>\n<h4 id=\"1-指针修饰符\"><a href=\"#1-指针修饰符\" class=\"headerlink\" title=\"1.指针修饰符\"></a>1.指针修饰符</h4><ul>\n<li><p><code>__strong</code>指针修饰符</p>\n<p>凡是用<code>__strong</code>修饰的指针，在超出其作用域时，编译器会为我们插入一次<code>release</code>或<code>autorelease</code>的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">等价于：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MRC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"type\">id</span> arr = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    [arr autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>而在指针赋值时，编译器会自动为我们插入一次<code>retain</code>的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj1 = obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">等价于：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MRC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"type\">id</span> obj1 = [obj <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    [obj1 release];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以正是因为使用<code>__strong</code>指针修饰符，编译器才会在合适的地方帮我们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用，而ARC下所有指针默认都是用<code>__strong</code>修饰的。</p>\n<ul>\n<li><code>__weak</code>指针修饰符</li>\n</ul>\n<p>看起来有了<code>strong</code>,编译器就可以很好的管理内存了，但是很重要的一点是<code>__strong</code>无法解决引用计数式内存管理必然会导致的“循环引入”问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//稍后补充</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-属性修饰符\"><a href=\"#2-属性修饰符\" class=\"headerlink\" title=\"2.属性修饰符\"></a>2.属性修饰符</h4><p>属性修饰符一共有三对儿：<strong>原子性、读写权限和内存管理语意</strong>，属性修饰符主要影响就是编译器为成员变量生成的<code>setter</code>、<code>getter</code>方法上。（这里除了讲解和内存相关的知识外，其他的也回顾一下）</p>\n<blockquote>\n<p>原子性：<code>atomic</code>（默认）、<code>nonatomic</code></p>\n</blockquote>\n<ul>\n<li><p><code>atomic</code>：默认为<code>atomic</code>，使用<code>atomic</code>修饰的属性，编译器为该属性生成的<code>setter</code>、<code>getter</code>方法内部是加了锁的。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (atomic, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableArray</span> *array;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setArray:(<span class=\"built_in\">NSMutableArray</span> *)array &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    _array = array;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableArray</span> *)array &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _array;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>但这仅仅是保证我们调用<code>setter</code>、<code>getter</code>方法访问属性这一步是线程安全的，它没发保证我们使用属性的线程是安全的，比如我们调用<code>[self.array addObject:xxx]</code>,<code>self.array</code>访问属性这一步是线程安全的，但<code>addObject:</code>使用属性这一步是线程不安全的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程1</span><br><span class=\"line\">[self.array addObject:@&quot;11&quot;];</span><br><span class=\"line\">// 线程2</span><br><span class=\"line\">[self.array addObject:@&quot;12&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">等价于</span><br><span class=\"line\"></span><br><span class=\"line\">// 线程1</span><br><span class=\"line\">[[self array] addObject:@&quot;11&quot;];</span><br><span class=\"line\">// 线程2</span><br><span class=\"line\">[[self array] addObject:@&quot;12&quot;];</span><br></pre></td></tr></table></figure>\n\n<p>所以为了保证使用属性的线程安全，我们还得在需要的地方自己加锁，这样一来使用使用<code>atomic</code>修饰属性就多此一举了，而且<code>stter</code>、<code>getter</code>方法的调用通常都是很频繁的，内部加锁的话会增加内存的开销，耗费性能。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">[<span class=\"built_in\">self</span>.<span class=\"keyword\">array</span> addObject:@<span class=\"string\">&quot;11&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">[<span class=\"built_in\">self</span>.<span class=\"keyword\">array</span> addObject:@<span class=\"string\">&quot;12&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>nonatomic</code>：因此我们在实际开发中总是使用<code>nonatomic</code>。</li>\n</ul>\n<blockquote>\n<p>读写权限：<code>readwrite</code>(默认)、<code>readonly</code></p>\n</blockquote>\n<ul>\n<li><code>readwrite</code>：默认为<code>readwrite</code>，代表该属性可读可写，编译器会为该属性生成<code>setter</code></li>\n</ul>\n<p><code>getter</code>方法的声明与实现。</p>\n<ul>\n<li><code>readonly</code>：代表该属性只能读取不能写入，编译器会为该属性生成<code>setter</code>、<code>getter</code>方法的声明与<code>getter</code>方法的实现。</li>\n</ul>\n<blockquote>\n<p>内存管理语意：</p>\n<ul>\n<li>MRC下有：<code>assign</code>、<code>retain</code>、<code>copy</code>。</li>\n<li>ARC下新增了：<code>strong</code>、<code>weak</code>、<code>unsafe_unretained</code>。</li>\n</ul>\n</blockquote>\n<ul>\n<li><code>assign</code>：<code>assign</code>一般来修饰基本数据类型。使用<code>assign</code>修饰属性，编译器为属性生成的<code>setter</code>方法内部只是简单的赋值操作。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setAge:(<span class=\"type\">int</span>)age &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 简单的赋值操作</span></span><br><span class=\"line\">    _age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>retain</code>：<code>retain</code>一般用来修饰对象类型。使用<code>retain</code>修饰的属性，编译器为该属性生成的<code>setter</code>方法内部会调用一下<code>retain</code>方法，是对象的引用计数+1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setDog:(Dog *)dog &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (_dog != dog) &#123; // 新旧对象不一样时</span><br><span class=\"line\">        </span><br><span class=\"line\">        [_dog release]; // 释放旧对象</span><br><span class=\"line\">        _dog = [dog retain]; // 持有新对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>copy</code>：<code>copy</code>一般用来修饰不可变属性和block。使用<code>copy</code>修饰的属性，编译器为该属性生成的<code>setter</code>方法内部会调用一下<code>copy</code>方法，生成一个新的对象，新对象的引用计数为1，而旧对象的引用计数不变。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>strong</code>：默认为<code>strong</code>，大多数情况下和<code>retain</code>的效果是一样的，修饰block和<code>copy</code>的效果是一样的，<code>strong</code>一般用来修饰对象类型。</p>\n</li>\n<li><p><code>weak</code>：<code>weak</code>一般用来修饰代理对象和<code>NSTimer</code>，以免造成循环引入；还有用来修饰xib或sb拖出来的控件，因为这些界面已经被添加到界面上了，被subviews这个属性持有了，不必再用变量持有。</p>\n</li>\n<li><p><code>unsafe_unretained</code>：和<code>assign</code>效果是一样的，如果用他们来修饰对象类型，和<code>weak</code>功能类似，但<code>weak</code>修饰的属性会在对象销毁时会被置为<code>nil</code>，比较安全，而<code>unsafe_unretained</code>和<code>assign</code>修饰的属性则不会，所以容易出现野指针。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一、iOS内存管理方式：</p>\n<p>​    1.Tagged Pointer：小对象的内存管理方式</p>\n<p>​    2.引用计数：普通对象的内存管理方式</p>\n<p>二、MRC介绍，需要开发工程师做哪些工作</p>\n<p>三、ARC介绍，编译器帮我们做了什么</p>","more":"<p>​    1.指针修饰符</p>\n<p>​        1. __strong</p>\n<p>​        2. __weak</p>\n<p>​        3. __unsafe_unretained</p>\n<p>​        4. __autoreease</p>\n<p>​    2.属性修饰符</p>\n<p>​        2.1 原子性：<code>atomic</code>、<code>nonatomic</code></p>\n<p>​        2.2 读写权限：<code>readwrite</code>、<code>readonly</code></p>\n<p>​        2.3 内存管理语义：<code>assign</code>、<code>retain</code>、<code>copy</code>、<code>strong</code>、<code>weak</code>、<code>unsafe_unretained</code></p>\n</blockquote>\n<h3 id=\"一、内存管理方式：\"><a href=\"#一、内存管理方式：\" class=\"headerlink\" title=\"一、内存管理方式：\"></a>一、内存管理方式：</h3><h4 id=\"1-Tagged-Pointer：小对象的内存管理方式\"><a href=\"#1-Tagged-Pointer：小对象的内存管理方式\" class=\"headerlink\" title=\"1.Tagged Pointer：小对象的内存管理方式\"></a>1.Tagged Pointer：小对象的内存管理方式</h4><p>64位操作系统后，iOS引入了Tagged Pointer，用来优化NSString、NSNumber、NSDate的内存管理。</p>\n<p>引入Tagged Pointer之前（32位操作系统时），小对象内存管理方式和普通对象一样，首先需要在堆区开辟一块内存，并把内存的地址赋值给栈区的指针变量，然后维护对象的引用计数和内存的释放。</p>\n<p>比如我们创建一个int类型的NSNumber对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNumber *number = @11;</span><br></pre></td></tr></table></figure>\n\n<p>系统需要开辟16个字节的内存来存储11这个值，同时需要开辟8个字节大小的内存来存储这个对象的地址，本来需要占用4个字节的内存的Int类型数据，占用了24个字节，同时还没考虑维护引用计数和内存释放等的内存开销。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/nsnumber.png\" alt=\"使用Tagged pointer前的内存管理\"></p>\n<p>在引入Tagged Pointer之后，<strong>小对象就不需要像之前那样 在堆区开辟内存，维护引用计数，释放内存了。而是直接把值存到了number指针里，number里面存的不再是一个地址了，而是Tag + Data，Tag是用来标记小对象的类型（NSString、NSNumber、NSDate），Data就是小对象的值。指针什么时候创建，小对象就什么时候创建，指针什么时候销毁，小对象就什么时候销毁。只有在指针存不下小对象的值时，才会变为引用计数的方式管理内存。</strong>这样，仅需要8个字节就可以存储小对象的类型和值，很大程度上节省了内存占用，同时也减少了维护引用计数、内存释放等带来的开销。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/%E4%BD%BF%E7%94%A8Tagged.png\" alt=\"使用Tagged Pointer后的内存管理\"></p>\n<p>用代码验证一下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  苹果对Tagged Pointer做了数据混淆，所以在分析Tagged Pointer之前，我们需要先关闭Tagged Pointer的数据混淆。通过设置环境变量OBJC_DISABLE_TAG_OBFUSCATION为YES。否则无法分析打印出的结果</span><br><span class=\"line\">- (void)testTaggedPointer &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    NSNumber *number1 = @1;</span><br><span class=\"line\">    NSNumber *number2 = @2;</span><br><span class=\"line\">    NSNumber *number3 = @10;</span><br><span class=\"line\">    NSNumber *number4 = @(0xFFFFFFFFFFFFFFFF);</span><br><span class=\"line\"></span><br><span class=\"line\">    NSLog(@&quot;number1:%p&quot;, number1);</span><br><span class=\"line\">    NSLog(@&quot;number2:%p&quot;, number2);</span><br><span class=\"line\">    NSLog(@&quot;number3:%p&quot;, number3);</span><br><span class=\"line\">    NSLog(@&quot;number4:%p&quot;, number4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">number1:0xb000000000000012</span><br><span class=\"line\">number2:0xb000000000000022</span><br><span class=\"line\">number3:0xb0000000000000a2</span><br><span class=\"line\">number4:0x600001be2060</span><br></pre></td></tr></table></figure>\n\n<p>number1～number3指针是Tagged Pointer，number4由于值大到存储不下了，改为普通对象内存管理方式。对应的地址分布规律见下图（mac os系统的规律与iOS系统的规律不同 <a href=\"https://cloud.tencent.com/developer/article/1620346\">详细</a>），可发现规律<strong>如果一个指针的最高位为1，那么他就是Tagged Pointer，否则就不是。</strong></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623191932.png\" alt=\"ios-nsnumber\"></p>\n<p>如果是NSString的话，Tagged Pointer内存地址分布规律就是下面这样的：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220623195417.png\" alt=\"ios-nsstring\"></p>\n<p>学习完上面内容，我们举个例子验证下，找不同：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 开辟多个线程去修改name属性</span></span><br><span class=\"line\"><span class=\"comment\">// 代码1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@&quot;abcdefghijk&quot;</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 代码2</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">dispatch_async</span>(dispatch_get_global_queue(<span class=\"number\">0</span>, <span class=\"number\">0</span>), ^&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = [[<span class=\"built_in\">NSString</span> alloc] initWithFormat:<span class=\"string\">@&quot;abc&quot;</span>];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行代码我们会发现 代码1 会crash，因为<code>abcdefghijk</code>已经大到指针存储不下，改为了普通对象内存管理方式，所以 代码1 就是正常的调用<code>setter</code>方法修改<code>name</code>属性,<code>setter</code>的实现是这样的：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在不加锁的情况下，极容易发生多个线程同时调用<code>[_name release]</code>的情况，若<code>_name</code>已经销毁，再次调用<code>release</code>肯定会发生crash。</p>\n<p>代码2 正常运行，是因为<code>abc</code>并没有大到指针存储不下，<code>NSString</code>为<code>NSTaggedPointerString</code>类型，在<code>objc_release</code>函数中会判断指针是不是<code>TaggedPointer</code>类型，是的话就不对对象进行<code>release</code>操作，也就避免了因过度释放对象而导致的<code>Crash</code>，因为根本就没执行释放操作。</p>\n<h4 id=\"2-引用计数：普通对象的内存管理方式\"><a href=\"#2-引用计数：普通对象的内存管理方式\" class=\"headerlink\" title=\"2.引用计数：普通对象的内存管理方式\"></a>2.引用计数：普通对象的内存管理方式</h4><p><strong>2.1 引用计数是什么？</strong></p>\n<p><strong>iOS是通过引用计数来管理内存的。所谓的引用计数就是指每当我们创建一个对象，系统就会为该对象分配一个整数，用来表征当前有多少人想使用该对象。</strong>那就引出两个问题：</p>\n<p>问题1：创建对象时，系统为对象分配的整数存在哪里？也就是引用计数存在哪里？因为我们知道OC对象内部只有一个<code>isa</code>，并没有引用计数的成员变量</p>\n<p>问题2：iOS具体是怎么通过引用计数来管理内存的？</p>\n<p><strong>2.2 引用计数存储在哪里？</strong></p>\n<p>64位操作系统以前，对象的<code>isa</code>指针还没进行内存优化，对象的引用计数存储在引用计数表里。</p>\n<p>当系统为64位操作系统后，对象的<code>isa</code>指针经过了内存优化，它不再直接是一个指针了，而是一个共用体，64位中只有33位用来存储对象所属类的地址信息，还有19位用来存储（对象的引用计数 -1），还有1位用来标记引用计数表里是否有当前对象的引用计数。具体地说：<strong>对象的引用计数首先会存储在<code>isa</code>共用体里——<code>extra_rc</code>变量，但是<code>isa</code>共用体的引用计数存储范围是0～255，一旦引用计数超过了255，这个变量就会溢出，此时系统会把这个变量置为128，同时把引用计数表里是否有当前对象的引用计数的标记——<code>has_sidetable_rc</code>变量置为1，并把另外128个引用计数挪到引用计数表里进行存储。下一次对象的引用计数再次增加时，依旧增加<code>isa</code>共用体里的引用计数（因为它已被置为128，不再是溢出状态），直到再次溢出，系统再娜128个引用计数到引用计数表里，如此循环往复。</strong></p>\n<p>因此可以看出，系统是不会直接操作引用计数表里的引用计数的，而总是在操作<code>isa</code>共用体里的引用计数，直到溢出时才从<code>isa</code>共用体里挪128个引用计数到引用计数表里进行存储。</p>\n<ul>\n<li><p><code>isa</code>共用体</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">objc_object</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">isa_t</span> isa; <span class=\"comment\">// 一个isa_t类型的共用体</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义的成员变量，存储着该对象这些成员变量具体的值</span></span><br><span class=\"line\">    NSSring *_name; <span class=\"comment\">// “张三”</span></span><br><span class=\"line\">    NSSring *_sex; <span class=\"comment\">// “男”</span></span><br><span class=\"line\">    <span class=\"type\">int</span> _age; <span class=\"comment\">// 33</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">union</span> <span class=\"title class_\">isa_t</span> &#123;</span><br><span class=\"line\">    Class cls;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> bits; <span class=\"comment\">// 8个字节，64位</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> &#123; <span class=\"comment\">// 其实所有的数据都存储在成员变量bits里面，因为外界只访问它，而这个结构体则仅仅是用位域来增加代码的可读性，让我们看到bits里面相应的位上存储着谁的数据</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">if</span> __arm64__</span></span><br><span class=\"line\"><span class=\"meta\">#   <span class=\"keyword\">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> nonpointer        : <span class=\"number\">1</span>; <span class=\"comment\">// isa是否经过内存优化</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_assoc         : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_cxx_dtor      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> shiftcls          : <span class=\"number\">33</span>; <span class=\"comment\">// 对象所属类的地址信息</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> magic             : <span class=\"number\">6</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> weakly_referenced : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> deallocating      : <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> has_sidetable_rc  : <span class=\"number\">1</span>; <span class=\"comment\">// 引用计数表里是否有当前对象的引用计数</span></span><br><span class=\"line\">        <span class=\"type\">unsigned</span> <span class=\"type\">long</span> extra_rc          : <span class=\"number\">19</span>; <span class=\"comment\">// 对象的引用计数 - 1</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>SideTables</code>–&gt;<code>SideTable</code>–&gt;引用计数表、若引用表</p>\n</li>\n</ul>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220627183629.png\" alt=\"SideTables\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class=\"line\">    return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">struct SideTable &#123;</span><br><span class=\"line\">    spinlock_t slock; // 自旋锁</span><br><span class=\"line\">    RefcountMap refcnts; // 引用计数表</span><br><span class=\"line\">    weak_table_t weak_table;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typedef objc::DenseMap&lt;objc_object */*对象的内存地址*/, unsigned long/*对象的引用计数*/&gt; RefcountMap;</span><br><span class=\"line\"></span><br><span class=\"line\">struct weak_table_t &#123;</span><br><span class=\"line\">    weak_entry_t *weak_entries; // 这个其实才是弱引用表，表中元素为weak_entry_t结构体</span><br><span class=\"line\">    size_t    num_entries;</span><br><span class=\"line\">    uintptr_t mask;</span><br><span class=\"line\">    uintptr_t max_hash_displacement;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    objc_object *obj; // 对象的内存地址</span><br><span class=\"line\">    weak_referrer_t *referrers; // 指向该对象的弱指针数组——即所有指向该对象的弱指针（其实存储的是弱指针对应那块内存的地址，但是我们直接理解为弱指针是没有问题的）</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 例如：</span><br><span class=\"line\">id obj = [[NSObject alloc] init];</span><br><span class=\"line\">__weak id weakObj1 = obj;</span><br><span class=\"line\">__weak id weakObj2 = obj;</span><br><span class=\"line\">__weak id weakObj3 = obj;</span><br><span class=\"line\"></span><br><span class=\"line\">// NSObject对象的weak_entry为：</span><br><span class=\"line\">struct weak_entry_t &#123;</span><br><span class=\"line\">    objc_object *obj; // 对象的内存地址</span><br><span class=\"line\">    weak_referrer_t *referrers; // 指向该对象的弱指针数组</span><br><span class=\"line\">&#125; NSObjectWeakEntry = &#123;</span><br><span class=\"line\">    obj;</span><br><span class=\"line\">    [weakObj1, weakObj2, weakObj3]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>SideTables</code>是一个全局的散列表，它里面存储着64个<code>SideTable</code>结构体，而每个<code>SideTable</code>结构体内部又存储着1个引用计数表和1个弱引用计数表，所以项目中一般会有64个引用计数表和64个弱引用计数表。引用计数表也是一个散列表，表中的元素是一个字典：<code>key</code>为对象的内存地址，<code>value</code>为对象的引用计数，引用计数表里存储着很多对象的引用计数。若引用计数表也是一个散列表，表中的元素是一个结构体：一个成员变量是对象的内存地址，另一个成员变量是指向该对象的弱指针数组。</p>\n<p>所以如果我们想要找到对象的引用计数和弱指针数组，就要首先把对象的内存地址通过某种散列算法得到一个<code>index</code>，就可以在<code>SideTables</code>里找到对象的引用计数和弱指针数组所在的<code>SideTable</code>结构体，也就是找到了引用计数和弱指针数组所在的引用计数表和弱引用计数表，然后再次把对象的内存地址通过某种散列算法得到一个<code>index</code>，就可以在引用计数表里找到对象的引用计数，弱引用计数表里找到对象的弱指针数组了。</p>\n<p><strong>2.3 iOS具体是怎么通过引用计数来进行对象的内存管理的</strong></p>\n<p>主要是通过<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>，<code>retain</code>，<code>release</code>、<code>autorelease</code>，<code>dealoc</code>这几个方法操作引用计数，来管理对象内存管理的，即：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628181747.png\" alt=\"img\"></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NSObject.mm</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)release &#123;</span><br><span class=\"line\">    self-&gt;<span class=\"built_in\">rootRelease</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">objc_object::rootRelease</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">rootRelease</span>(<span class=\"literal\">true</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">objc_object::rootRelease</span><span class=\"params\">(<span class=\"type\">bool</span> performDealloc, <span class=\"type\">bool</span> handleUnderflow)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">isTaggedPointer</span>()) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">isa_t</span> newisa = <span class=\"built_in\">LoadExclusive</span>(&amp;isa.bits);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newisa.nonpointer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 去引用计数表里让它的引用计数-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">sidetable_release</span>(performDealloc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 用来标识extra_rc是否下溢——即是否减为-1（因为extra_rc存储的是（引用计数 - 1），所以减为0的时候说明引用计数为1，还有人引用它，没事儿）</span></span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> carry;</span><br><span class=\"line\">    <span class=\"comment\">// 首先去isa共用体里，让对象的引用计数-1</span></span><br><span class=\"line\">    newisa.bits = <span class=\"built_in\">subc</span>(newisa.bits, RC_ONE, <span class=\"number\">0</span>, &amp;carry);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (carry) &#123; <span class=\"comment\">// 所以如果extra_rc下溢了：</span></span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">goto</span> underflow; <span class=\"comment\">// 跳转到underflow处执行</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 表明没有下溢，结束</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> underflow: <span class=\"comment\">// extra_rc下溢了：</span></span><br><span class=\"line\"></span><br><span class=\"line\">    newisa = <span class=\"built_in\">LoadExclusive</span>(&amp;isa.bits);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newisa.has_sidetable_rc) &#123; <span class=\"comment\">// 如果引用计数表里有当前对象的引用计数，说明还有人使用该对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 尝试从引用计数表搬回来128个引用计数</span></span><br><span class=\"line\">        <span class=\"type\">size_t</span> borrowed = <span class=\"built_in\">sidetable_subExtraRC_nolock</span>(RC_HALF);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (borrowed) &#123; <span class=\"comment\">// 如果搬成功了</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 存进去</span></span><br><span class=\"line\">            newisa.extra_rc = borrowed - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 更新一下对象的isa共用体</span></span><br><span class=\"line\">            isa = newisa;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 搬失败了，说明引用计数表里的引用计数也为0了（可能是被上一次搬完了）</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">// 走dealloc方法销毁该对象</span></span><br><span class=\"line\">            ((<span class=\"built_in\">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class=\"keyword\">this</span>, SEL_dealloc);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 引用计数表里没有当前对象的引用计数，说明没人使用该对象了</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 走dealloc方法销毁该对象</span></span><br><span class=\"line\">        ((<span class=\"built_in\">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class=\"keyword\">this</span>, SEL_dealloc);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试从引用计数表搬回来128个引用计数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">size_t</span> <span class=\"title\">objc_object::sidetable_subExtraRC_nolock</span><span class=\"params\">(<span class=\"type\">size_t</span> delta_rc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    SideTable&amp; table = <span class=\"built_in\">SideTables</span>()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\">    RefcountMap::iterator it = table.refcnts.<span class=\"built_in\">find</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it == table.refcnts.<span class=\"built_in\">end</span>()  ||  it-&gt;second == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 引用计数表里的引用计数被上一次搬完了</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 引用计数表里的引用计数-128，搬出去</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> oldRefcnt = it-&gt;second;</span><br><span class=\"line\">    <span class=\"type\">size_t</span> newRefcnt = oldRefcnt - (delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT);</span><br><span class=\"line\">    it-&gt;second = newRefcnt;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> delta_rc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于<code>autorelease</code>和<code>autoreleasepool</code>就暂时理解这么一点，更底层的东西有空再说：</p>\n<ul>\n<li><code>release</code>会立即使对象的引用计数-1，而<code>autorelease</code>则不会，它仅仅是把该对象注册到了<code>autoreleasepool</code>中，当<code>autoreleasepool</code>销毁时系统会自动让池中所有的对象都调用一下<code>release</code>，这时对象的引用计数才-1。</li>\n<li>而<code>autoreleasepool</code>又是在RunLoop休眠或退出时销毁的，当然如果是我们自己创建的<code>@autoreleasepool&#123;&#125;</code>，出了大括号——即出了<code>@autoreleasepool&#123;&#125;</code>的生命周期，它就会销毁。</li>\n<li>只要不是用<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>方法创建的对象，而是用类方法创建的对象，方法内部都调用了<code>autorelease</code>，都是<code>autorelease</code>对象。</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>如果对象的引用计数减为0了，就代表没人想使用该对象了，系统就会调用<code>dealloc</code>方法销毁它，并释放它对应的内存，对象一经销毁就不能再访问了，因为他的内存随时会被移作它用。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220628182915.png\" alt=\"img\"></p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// NSObject.mm</span></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    _objc_rootDealloc(self);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> _objc_rootDealloc(id obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    obj-&gt;<span class=\"built_in\">rootDealloc</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::rootDealloc</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">        !isa.has_cxx_dtor  &amp;&amp; <span class=\"comment\">// 如果当前对象没使用过C++析构函数</span></span><br><span class=\"line\">        !isa.has_assoc  &amp;&amp; <span class=\"comment\">// 如果当前对象没有关联对象</span></span><br><span class=\"line\">        !isa.weakly_referenced  &amp;&amp; <span class=\"comment\">// 如果弱引用表里没有当前对象的弱指针数组</span></span><br><span class=\"line\">        !isa.has_sidetable_rc <span class=\"comment\">// 如果引用计数表里没有当前对象的引用计数</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 就直接销毁对象，并释放它对应的内存，即我们之前说的对象销毁时会更快</span></span><br><span class=\"line\">        <span class=\"built_in\">free</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 否则就慢慢销毁</span></span><br><span class=\"line\">        <span class=\"built_in\">object_dispose</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">id <span class=\"title\">object_dispose</span><span class=\"params\">(id obj)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">objc_destructInstance</span>(obj);</span><br><span class=\"line\">    <span class=\"comment\">// 销毁对象，并释放它对应的内存，</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> nil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> *<span class=\"title\">objc_destructInstance</span><span class=\"params\">(id obj)</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 如果当前对象使用过C++析构函数</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> cxx = obj-&gt;<span class=\"built_in\">hasCxxDtor</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 如果当前对象有关联对象</span></span><br><span class=\"line\">        <span class=\"type\">bool</span> assoc = obj-&gt;<span class=\"built_in\">hasAssociatedObjects</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 要按顺序销毁哦</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cxx) <span class=\"built_in\">object_cxxDestruct</span>(obj); <span class=\"comment\">// 销毁C++析构函数相关的东西</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (assoc) _object_remove_assocations(obj); <span class=\"comment\">// 移除关联对象</span></span><br><span class=\"line\">        obj-&gt;<span class=\"built_in\">clearDeallocating</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::clearDeallocating</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearDeallocating_slow</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">objc_object::clearDeallocating_slow</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取SideTable</span></span><br><span class=\"line\">    SideTable&amp; table = <span class=\"built_in\">SideTables</span>()[<span class=\"keyword\">this</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.weakly_referenced) &#123; <span class=\"comment\">// 如果弱引用表里有当前对象的弱指针数组</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 把弱引用表里所有指向该对象的弱指针都置为nil，并移除，从此弱引用表里就没有该对象的弱指针数组（关于弱指针（弱引用）更多详细的内容，见下面__weak指针的实现原理）</span></span><br><span class=\"line\">        <span class=\"built_in\">weak_clear_no_lock</span>(&amp;table.weak_table, (id)<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isa.has_sidetable_rc) &#123; <span class=\"comment\">// 如果引用计数表里有当前对象的引用计数</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 从引用计数表里把该对象的引用计数给抹掉，从此引用计数表里就没有该对象的引用计数了</span></span><br><span class=\"line\">        table.refcnts.<span class=\"built_in\">erase</span>(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"二、MRC介绍，需要开发工程师做哪些工作\"><a href=\"#二、MRC介绍，需要开发工程师做哪些工作\" class=\"headerlink\" title=\"二、MRC介绍，需要开发工程师做哪些工作\"></a>二、MRC介绍，需要开发工程师做哪些工作</h3><p>MRC（<em>Manual Reference Count</em>）：指手动管理引用计数，即需要程序员自己手动调用上面那几个<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>，<code>retain</code>，<code>release</code>、<code>autorelease</code>，<code>dealoc</code>方法来操作引用计数，从而完成对象的内存管理。具体地说，MRC下我们需要做到以下三点：</p>\n<ul>\n<li>调用了<code>alloc</code>、<code>new</code>、<code>alloc</code>、<code>copy</code>、<code>mutableCopy</code>创建对象的地方，在不想使用对象时，要调用</li>\n</ul>\n<p><code>release</code>、<code>autorelease</code>；调用了<code>retain</code>使对象引用计数+1的地方，在不想使用对象时，要调用</p>\n<p><code>release</code>、<code>autorelease</code>来使对象的引用计数-1。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 调用了alloc、new、copy、mutableCopy创建对象</span></span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr1 = [<span class=\"built_in\">NSArray</span> new];</span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr2 = [arr <span class=\"keyword\">copy</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableArray</span> *arr3 = [arr1 mutableCopy];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 调用release、autorelease来释放对象</span></span><br><span class=\"line\">    [arr release];</span><br><span class=\"line\">    [arr1 release];</span><br><span class=\"line\">    [arr2 autorelease];</span><br><span class=\"line\">    [arr3 autorelease];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"built_in\">NSArray</span> *arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">    <span class=\"comment\">// 调用了retain使对象引用计数+1</span></span><br><span class=\"line\">    [arr <span class=\"keyword\">retain</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 要调用release、autorelease来使对象的引用计数-1</span></span><br><span class=\"line\">    [arr release];</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">//或者调用下面</span></span><br><span class=\"line\">    <span class=\"comment\">//[arr autorelease];</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们还需要处理好<code>setter</code>方法内部的内存管理，并在<code>dealloc</code>方法里释放当前类及其父类<strong>所有对象类型</strong>的成员变量。</li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">INEPerson</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> _age;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> *_name;</span><br><span class=\"line\">    INEDog *_dog;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setAge:(<span class=\"type\">int</span>)age &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    _age = age; <span class=\"comment\">// 直接赋值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setDog:(INEDog *)dog &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_dog != dog) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_dog release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _dog = [dog <span class=\"keyword\">retain</span>]; <span class=\"comment\">// 持有新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 释放当前类所有对象类型的成员变量</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setName:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span> setDog:<span class=\"literal\">nil</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 释放父类所有对象类型的成员变量，放在最后</span></span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> dealloc];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们还需要处理好循环引入问题。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//稍后补充</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"三、ARC介绍，编译器帮我们做了什么\"><a href=\"#三、ARC介绍，编译器帮我们做了什么\" class=\"headerlink\" title=\"三、ARC介绍，编译器帮我们做了什么\"></a>三、ARC介绍，编译器帮我们做了什么</h4><p>ARC（<em>Autal Reference Count</em>）：自动管理引用计数，让<strong>编译器</strong>进行内存管理，<strong>在LVVM编译器中设置ARC为有效状态，就无需再次键入<code>retain</code>、<code>realeas</code>、<code>autorelease</code>代码，编译器会在合适的地方自动帮我们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用，从而完成对象的内存管理。但实际上除了编译器之外，ARC还用到了Runtime，比如<code>weak</code>指针的清空。</strong>这样就会在降低程序崩溃、内存泄漏风险的同时，很大程度程度减少了开发的工作量，使应用程序具有可预测性，且能流畅运行，速度也将大幅提升。具体来说，与MRC相对应，ARC帮我们做了如下三点：</p>\n<ul>\n<li><p>利用<code>__strong</code>指针修饰符，编译器会在合适的地方帮们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用；</p>\n</li>\n<li><p>利用属性修饰符，编译器为我们生成特定的<code>setter</code>方法并处理好内部的内存管理，还会自动在<code>dealloc</code>方法里释放当前类及其父类的成员变量；</p>\n</li>\n<li><p>利用<code>__weak</code>指针修饰符和Runtime，来处理循环引入问题。</p>\n</li>\n</ul>\n<h4 id=\"1-指针修饰符\"><a href=\"#1-指针修饰符\" class=\"headerlink\" title=\"1.指针修饰符\"></a>1.指针修饰符</h4><ul>\n<li><p><code>__strong</code>指针修饰符</p>\n<p>凡是用<code>__strong</code>修饰的指针，在超出其作用域时，编译器会为我们插入一次<code>release</code>或<code>autorelease</code>的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> arr = [<span class=\"built_in\">NSArray</span> array];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">等价于：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MRC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"type\">id</span> arr = [[<span class=\"built_in\">NSArray</span> alloc] init];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    [arr autorelease];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>而在指针赋值时，编译器会自动为我们插入一次<code>retain</code>的调用。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ARC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    __<span class=\"keyword\">strong</span> <span class=\"type\">id</span> obj1 = obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">等价于：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MRC下</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">id</span> obj = [[<span class=\"built_in\">NSObject</span> alloc] init];</span><br><span class=\"line\">    <span class=\"type\">id</span> obj1 = [obj <span class=\"keyword\">retain</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    [obj1 release];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以正是因为使用<code>__strong</code>指针修饰符，编译器才会在合适的地方帮我们插入<code>retain</code>、<code>release</code>、<code>autorelease</code>等方法的调用，而ARC下所有指针默认都是用<code>__strong</code>修饰的。</p>\n<ul>\n<li><code>__weak</code>指针修饰符</li>\n</ul>\n<p>看起来有了<code>strong</code>,编译器就可以很好的管理内存了，但是很重要的一点是<code>__strong</code>无法解决引用计数式内存管理必然会导致的“循环引入”问题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//稍后补充</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-属性修饰符\"><a href=\"#2-属性修饰符\" class=\"headerlink\" title=\"2.属性修饰符\"></a>2.属性修饰符</h4><p>属性修饰符一共有三对儿：<strong>原子性、读写权限和内存管理语意</strong>，属性修饰符主要影响就是编译器为成员变量生成的<code>setter</code>、<code>getter</code>方法上。（这里除了讲解和内存相关的知识外，其他的也回顾一下）</p>\n<blockquote>\n<p>原子性：<code>atomic</code>（默认）、<code>nonatomic</code></p>\n</blockquote>\n<ul>\n<li><p><code>atomic</code>：默认为<code>atomic</code>，使用<code>atomic</code>修饰的属性，编译器为该属性生成的<code>setter</code>、<code>getter</code>方法内部是加了锁的。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (atomic, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSMutableArray</span> *array;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)setArray:(<span class=\"built_in\">NSMutableArray</span> *)array &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    _array = array;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSMutableArray</span> *)array &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 加锁</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> _array;</span><br><span class=\"line\">    <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>但这仅仅是保证我们调用<code>setter</code>、<code>getter</code>方法访问属性这一步是线程安全的，它没发保证我们使用属性的线程是安全的，比如我们调用<code>[self.array addObject:xxx]</code>,<code>self.array</code>访问属性这一步是线程安全的，但<code>addObject:</code>使用属性这一步是线程不安全的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 线程1</span><br><span class=\"line\">[self.array addObject:@&quot;11&quot;];</span><br><span class=\"line\">// 线程2</span><br><span class=\"line\">[self.array addObject:@&quot;12&quot;];</span><br><span class=\"line\"></span><br><span class=\"line\">等价于</span><br><span class=\"line\"></span><br><span class=\"line\">// 线程1</span><br><span class=\"line\">[[self array] addObject:@&quot;11&quot;];</span><br><span class=\"line\">// 线程2</span><br><span class=\"line\">[[self array] addObject:@&quot;12&quot;];</span><br></pre></td></tr></table></figure>\n\n<p>所以为了保证使用属性的线程安全，我们还得在需要的地方自己加锁，这样一来使用使用<code>atomic</code>修饰属性就多此一举了，而且<code>stter</code>、<code>getter</code>方法的调用通常都是很频繁的，内部加锁的话会增加内存的开销，耗费性能。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程1</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">[<span class=\"built_in\">self</span>.<span class=\"keyword\">array</span> addObject:@<span class=\"string\">&quot;11&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 线程2</span></span><br><span class=\"line\"><span class=\"comment\">// 加锁</span></span><br><span class=\"line\">[<span class=\"built_in\">self</span>.<span class=\"keyword\">array</span> addObject:@<span class=\"string\">&quot;12&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// 解锁</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>nonatomic</code>：因此我们在实际开发中总是使用<code>nonatomic</code>。</li>\n</ul>\n<blockquote>\n<p>读写权限：<code>readwrite</code>(默认)、<code>readonly</code></p>\n</blockquote>\n<ul>\n<li><code>readwrite</code>：默认为<code>readwrite</code>，代表该属性可读可写，编译器会为该属性生成<code>setter</code></li>\n</ul>\n<p><code>getter</code>方法的声明与实现。</p>\n<ul>\n<li><code>readonly</code>：代表该属性只能读取不能写入，编译器会为该属性生成<code>setter</code>、<code>getter</code>方法的声明与<code>getter</code>方法的实现。</li>\n</ul>\n<blockquote>\n<p>内存管理语意：</p>\n<ul>\n<li>MRC下有：<code>assign</code>、<code>retain</code>、<code>copy</code>。</li>\n<li>ARC下新增了：<code>strong</code>、<code>weak</code>、<code>unsafe_unretained</code>。</li>\n</ul>\n</blockquote>\n<ul>\n<li><code>assign</code>：<code>assign</code>一般来修饰基本数据类型。使用<code>assign</code>修饰属性，编译器为属性生成的<code>setter</code>方法内部只是简单的赋值操作。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setAge:(<span class=\"type\">int</span>)age &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 简单的赋值操作</span></span><br><span class=\"line\">    _age = age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><code>retain</code>：<code>retain</code>一般用来修饰对象类型。使用<code>retain</code>修饰的属性，编译器为该属性生成的<code>setter</code>方法内部会调用一下<code>retain</code>方法，是对象的引用计数+1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)setDog:(Dog *)dog &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    if (_dog != dog) &#123; // 新旧对象不一样时</span><br><span class=\"line\">        </span><br><span class=\"line\">        [_dog release]; // 释放旧对象</span><br><span class=\"line\">        _dog = [dog retain]; // 持有新对象</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>copy</code>：<code>copy</code>一般用来修饰不可变属性和block。使用<code>copy</code>修饰的属性，编译器为该属性生成的<code>setter</code>方法内部会调用一下<code>copy</code>方法，生成一个新的对象，新对象的引用计数为1，而旧对象的引用计数不变。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)setName:(<span class=\"built_in\">NSString</span> *)name &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_name != name) &#123; <span class=\"comment\">// 新旧对象不一样时</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        [_name release]; <span class=\"comment\">// 释放旧对象</span></span><br><span class=\"line\">        _name = [name <span class=\"keyword\">copy</span>]; <span class=\"comment\">// 复制新对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>strong</code>：默认为<code>strong</code>，大多数情况下和<code>retain</code>的效果是一样的，修饰block和<code>copy</code>的效果是一样的，<code>strong</code>一般用来修饰对象类型。</p>\n</li>\n<li><p><code>weak</code>：<code>weak</code>一般用来修饰代理对象和<code>NSTimer</code>，以免造成循环引入；还有用来修饰xib或sb拖出来的控件，因为这些界面已经被添加到界面上了，被subviews这个属性持有了，不必再用变量持有。</p>\n</li>\n<li><p><code>unsafe_unretained</code>：和<code>assign</code>效果是一样的，如果用他们来修饰对象类型，和<code>weak</code>功能类似，但<code>weak</code>修饰的属性会在对象销毁时会被置为<code>nil</code>，比较安全，而<code>unsafe_unretained</code>和<code>assign</code>修饰的属性则不会，所以容易出现野指针。</p>\n</li>\n</ul>"},{"title":"内存管理二","date":"2022-07-05T09:32:38.000Z","_content":"\n> 一、定时器的循环引入\n>\n> 二、copy、mutableCopy\n>\n> 三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}\n>\n> 四、其他注意事项\n\n<!--more-->\n\n### 一、定时器的循环引入\n\n我们以`NSTimer`举例，`CADisplayLink`遇到同样的问题，解决方案也一样。\n\n#### 1.`NSTimer`的循环引入\n\n使用`NSTimer`，写法通常如下：\n\n```objectivec\n#import \"ViewController.h\"\n#import \"ViewController1.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    \n    ViewController1 *vc = [[ViewController1 alloc] init];\n    [self.navigationController pushViewController:vc animated:YES];\n}\n\n@end\n```\n\n```objectivec\n#import \"ViewController1.h\"\n\n@interface ViewController1 ()\n\n@property (nonatomic, strong) NSTimer *timer;\n\n@end\n\n@implementation ViewController1\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 创建timer\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(test) userInfo:nil repeats:YES];\n}\n\n- (void)test {\n    \n    NSLog(@\"11\");\n}\n\n- (void)dealloc {\n    \n    NSLog(@\"%s\", __func__);\n    \n    // 退出界面时，使timer失效从而销毁\n    [self.timer invalidate];\n}\n\n@end\n```\n\n运行代码，点击`ViewController`进入`ViewController1`，此时`timer`跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回`ViewController`，正常情况下`ViewController1`应该会销毁，并触发`dealloc`方法，`timer`也跟着失效并且销毁。但实际情况却是`ViewController1`没有销毁，也没有触发`dealloc`方法，`timer`还一直跑着，这是因为`timer`和`ViewController1`形成了循环引用，导致内存泄漏。\n\n查看`timer`的创建方法，可以知道：**`timer`会强引用`target`，**也就是说`timer`确实强引用着`ViewController1`。\n\n![creatTimer](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png)\n\n而`ViewController`又强引用着`timer`。\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png)\n\n那怎么打破`NSTimer`的循环引用呢？我们知道`__weak`是专门用来打破循环引用的，那它是不是也能打破`NSTimer`的循环引用？\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 尝试用__weak打破NSTimer的循环引用\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(test) userInfo:nil repeats:YES];\n}\n```\n\n运行，发现没有效果，那为什么`__weak`不能打破`NSTimer`的循环引用？毫无疑问`__weak`的确是把`self`搞成了弱指针，但因为`NSTimer`内部有一个强指针类型的`target`变量\n\n```objectivec\n@property (nonatomic, strong) id target;\n```\n\n来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用`target`，所以用`__weak`不能打破`NSTimer`的循环引用。\n\n那再试试另一条引用线吧，让`ViewController1`弱引用`timer`。\n\n```objectivec\n@interface ViewController1 ()\n\n// 尝试用weak修饰timer来打破NSTimer的循环引用\n@property (nonatomic, weak) NSTimer *timer;\n\n@end\n```\n\n运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对`NSTimer`的说明，可以知道：**把`timer`添加到RunLoop之后，RunLoop会强引用`timer`，并且建议我们不必自己强引用`timer`，而解除RunLoop对`timer`强引用的唯一方式就是调用`timer`的`invalidate`方法使`timer`失效从而销毁。**\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png)\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png)\n\n也就是说，实际的引用关系如下：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png)\n\n所以我们**使用`weak`修饰`timer`是正确的，**但这还是不能打破`NSTimer`的循环引用——更准确地说，这可以解决`NSTimer`的循环引用，但还是没有解决`NSTimer`内存泄漏的问题。因为`[self.timer invalidate]`的调用——即`timer`的销毁——最好就是发生在`ViewController1`销毁时，而`ViewController1`要想销毁就必须得`timer`先销毁，还是内存泄漏。\n\n倒腾来倒腾去，还是得**从`timer`强引用`target`这条引用线下手，把它搞成弱引用，`__weak`不起作用，那我们想想别的方案呗。**\n\n#### 2、打破`NSTimer`的循环引用\n\n- 方案一：使用block的方式创建`timer`\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        [weakSelf test];\n    }];\n}\n```\n\n为什么能解决呢？因为此时`timer`是强引用block的，而`__weak`可以打破block的循环引用，所以block是弱引用`self`的，所以最终的效果就类似于`timer`弱引用`self`。解决是能解决，但用这种方式创建`timer`要iOS10.0以后才能使用。","source":"_posts/内存管理二.md","raw":"---\ntitle: 内存管理二\ndate: 2022-07-05 17:32:38\ntags:\n---\n\n> 一、定时器的循环引入\n>\n> 二、copy、mutableCopy\n>\n> 三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}\n>\n> 四、其他注意事项\n\n<!--more-->\n\n### 一、定时器的循环引入\n\n我们以`NSTimer`举例，`CADisplayLink`遇到同样的问题，解决方案也一样。\n\n#### 1.`NSTimer`的循环引入\n\n使用`NSTimer`，写法通常如下：\n\n```objectivec\n#import \"ViewController.h\"\n#import \"ViewController1.h\"\n\n@interface ViewController ()\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n}\n\n- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {\n    \n    ViewController1 *vc = [[ViewController1 alloc] init];\n    [self.navigationController pushViewController:vc animated:YES];\n}\n\n@end\n```\n\n```objectivec\n#import \"ViewController1.h\"\n\n@interface ViewController1 ()\n\n@property (nonatomic, strong) NSTimer *timer;\n\n@end\n\n@implementation ViewController1\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 创建timer\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(test) userInfo:nil repeats:YES];\n}\n\n- (void)test {\n    \n    NSLog(@\"11\");\n}\n\n- (void)dealloc {\n    \n    NSLog(@\"%s\", __func__);\n    \n    // 退出界面时，使timer失效从而销毁\n    [self.timer invalidate];\n}\n\n@end\n```\n\n运行代码，点击`ViewController`进入`ViewController1`，此时`timer`跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回`ViewController`，正常情况下`ViewController1`应该会销毁，并触发`dealloc`方法，`timer`也跟着失效并且销毁。但实际情况却是`ViewController1`没有销毁，也没有触发`dealloc`方法，`timer`还一直跑着，这是因为`timer`和`ViewController1`形成了循环引用，导致内存泄漏。\n\n查看`timer`的创建方法，可以知道：**`timer`会强引用`target`，**也就是说`timer`确实强引用着`ViewController1`。\n\n![creatTimer](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png)\n\n而`ViewController`又强引用着`timer`。\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png)\n\n那怎么打破`NSTimer`的循环引用呢？我们知道`__weak`是专门用来打破循环引用的，那它是不是也能打破`NSTimer`的循环引用？\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    // 尝试用__weak打破NSTimer的循环引用\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:weakSelf selector:@selector(test) userInfo:nil repeats:YES];\n}\n```\n\n运行，发现没有效果，那为什么`__weak`不能打破`NSTimer`的循环引用？毫无疑问`__weak`的确是把`self`搞成了弱指针，但因为`NSTimer`内部有一个强指针类型的`target`变量\n\n```objectivec\n@property (nonatomic, strong) id target;\n```\n\n来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用`target`，所以用`__weak`不能打破`NSTimer`的循环引用。\n\n那再试试另一条引用线吧，让`ViewController1`弱引用`timer`。\n\n```objectivec\n@interface ViewController1 ()\n\n// 尝试用weak修饰timer来打破NSTimer的循环引用\n@property (nonatomic, weak) NSTimer *timer;\n\n@end\n```\n\n运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对`NSTimer`的说明，可以知道：**把`timer`添加到RunLoop之后，RunLoop会强引用`timer`，并且建议我们不必自己强引用`timer`，而解除RunLoop对`timer`强引用的唯一方式就是调用`timer`的`invalidate`方法使`timer`失效从而销毁。**\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png)\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png)\n\n也就是说，实际的引用关系如下：\n\n![img](https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png)\n\n所以我们**使用`weak`修饰`timer`是正确的，**但这还是不能打破`NSTimer`的循环引用——更准确地说，这可以解决`NSTimer`的循环引用，但还是没有解决`NSTimer`内存泄漏的问题。因为`[self.timer invalidate]`的调用——即`timer`的销毁——最好就是发生在`ViewController1`销毁时，而`ViewController1`要想销毁就必须得`timer`先销毁，还是内存泄漏。\n\n倒腾来倒腾去，还是得**从`timer`强引用`target`这条引用线下手，把它搞成弱引用，`__weak`不起作用，那我们想想别的方案呗。**\n\n#### 2、打破`NSTimer`的循环引用\n\n- 方案一：使用block的方式创建`timer`\n\n```objectivec\n- (void)viewDidLoad {\n    [super viewDidLoad];\n\n    __weak typeof(self) weakSelf = self;\n    self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {\n        \n        [weakSelf test];\n    }];\n}\n```\n\n为什么能解决呢？因为此时`timer`是强引用block的，而`__weak`可以打破block的循环引用，所以block是弱引用`self`的，所以最终的效果就类似于`timer`弱引用`self`。解决是能解决，但用这种方式创建`timer`要iOS10.0以后才能使用。","slug":"内存管理二","published":1,"updated":"2022-07-06T06:02:40.732Z","_id":"cl582bsyi00007pfy2r7df1gg","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>一、定时器的循环引入</p>\n<p>二、copy、mutableCopy</p>\n<p>三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}</p>\n<p>四、其他注意事项</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h3 id=\"一、定时器的循环引入\"><a href=\"#一、定时器的循环引入\" class=\"headerlink\" title=\"一、定时器的循环引入\"></a>一、定时器的循环引入</h3><p>我们以<code>NSTimer</code>举例，<code>CADisplayLink</code>遇到同样的问题，解决方案也一样。</p>\n<h4 id=\"1-NSTimer的循环引入\"><a href=\"#1-NSTimer的循环引入\" class=\"headerlink\" title=\"1.NSTimer的循环引入\"></a>1.<code>NSTimer</code>的循环引入</h4><p>使用<code>NSTimer</code>，写法通常如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController1.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ViewController1 *vc = [[ViewController1 alloc] init];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController pushViewController:vc animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController1.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController1</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController1</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建timer</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)test &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 退出界面时，使timer失效从而销毁</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.timer invalidate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行代码，点击<code>ViewController</code>进入<code>ViewController1</code>，此时<code>timer</code>跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回<code>ViewController</code>，正常情况下<code>ViewController1</code>应该会销毁，并触发<code>dealloc</code>方法，<code>timer</code>也跟着失效并且销毁。但实际情况却是<code>ViewController1</code>没有销毁，也没有触发<code>dealloc</code>方法，<code>timer</code>还一直跑着，这是因为<code>timer</code>和<code>ViewController1</code>形成了循环引用，导致内存泄漏。</p>\n<p>查看<code>timer</code>的创建方法，可以知道：**<code>timer</code>会强引用<code>target</code>，**也就是说<code>timer</code>确实强引用着<code>ViewController1</code>。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png\" alt=\"creatTimer\"></p>\n<p>而<code>ViewController</code>又强引用着<code>timer</code>。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png\" alt=\"img\"></p>\n<p>那怎么打破<code>NSTimer</code>的循环引用呢？我们知道<code>__weak</code>是专门用来打破循环引用的，那它是不是也能打破<code>NSTimer</code>的循环引用？</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 尝试用__weak打破NSTimer的循环引用</span></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:weakSelf selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行，发现没有效果，那为什么<code>__weak</code>不能打破<code>NSTimer</code>的循环引用？毫无疑问<code>__weak</code>的确是把<code>self</code>搞成了弱指针，但因为<code>NSTimer</code>内部有一个强指针类型的<code>target</code>变量</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"type\">id</span> target;</span><br></pre></td></tr></table></figure>\n\n<p>来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用<code>target</code>，所以用<code>__weak</code>不能打破<code>NSTimer</code>的循环引用。</p>\n<p>那再试试另一条引用线吧，让<code>ViewController1</code>弱引用<code>timer</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController1</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试用weak修饰timer来打破NSTimer的循环引用</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对<code>NSTimer</code>的说明，可以知道：<strong>把<code>timer</code>添加到RunLoop之后，RunLoop会强引用<code>timer</code>，并且建议我们不必自己强引用<code>timer</code>，而解除RunLoop对<code>timer</code>强引用的唯一方式就是调用<code>timer</code>的<code>invalidate</code>方法使<code>timer</code>失效从而销毁。</strong></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png\" alt=\"img\"></p>\n<p>也就是说，实际的引用关系如下：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png\" alt=\"img\"></p>\n<p>所以我们<strong>使用<code>weak</code>修饰<code>timer</code>是正确的，</strong>但这还是不能打破<code>NSTimer</code>的循环引用——更准确地说，这可以解决<code>NSTimer</code>的循环引用，但还是没有解决<code>NSTimer</code>内存泄漏的问题。因为<code>[self.timer invalidate]</code>的调用——即<code>timer</code>的销毁——最好就是发生在<code>ViewController1</code>销毁时，而<code>ViewController1</code>要想销毁就必须得<code>timer</code>先销毁，还是内存泄漏。</p>\n<p>倒腾来倒腾去，还是得<strong>从<code>timer</code>强引用<code>target</code>这条引用线下手，把它搞成弱引用，<code>__weak</code>不起作用，那我们想想别的方案呗。</strong></p>\n<h4 id=\"2、打破NSTimer的循环引用\"><a href=\"#2、打破NSTimer的循环引用\" class=\"headerlink\" title=\"2、打破NSTimer的循环引用\"></a>2、打破<code>NSTimer</code>的循环引用</h4><ul>\n<li>方案一：使用block的方式创建<code>timer</code></li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [weakSelf test];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么能解决呢？因为此时<code>timer</code>是强引用block的，而<code>__weak</code>可以打破block的循环引用，所以block是弱引用<code>self</code>的，所以最终的效果就类似于<code>timer</code>弱引用<code>self</code>。解决是能解决，但用这种方式创建<code>timer</code>要iOS10.0以后才能使用。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>一、定时器的循环引入</p>\n<p>二、copy、mutableCopy</p>\n<p>三、创建大量autorelease对象时，最好自己创建一个@autoreleasepool {}</p>\n<p>四、其他注意事项</p>\n</blockquote>","more":"<h3 id=\"一、定时器的循环引入\"><a href=\"#一、定时器的循环引入\" class=\"headerlink\" title=\"一、定时器的循环引入\"></a>一、定时器的循环引入</h3><p>我们以<code>NSTimer</code>举例，<code>CADisplayLink</code>遇到同样的问题，解决方案也一样。</p>\n<h4 id=\"1-NSTimer的循环引入\"><a href=\"#1-NSTimer的循环引入\" class=\"headerlink\" title=\"1.NSTimer的循环引入\"></a>1.<code>NSTimer</code>的循环引入</h4><p>使用<code>NSTimer</code>，写法通常如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController1.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)touchesBegan:(<span class=\"built_in\">NSSet</span>&lt;<span class=\"built_in\">UITouch</span> *&gt; *)touches withEvent:(<span class=\"built_in\">UIEvent</span> *)event &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    ViewController1 *vc = [[ViewController1 alloc] init];</span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.navigationController pushViewController:vc animated:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"string\">&quot;ViewController1.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController1</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@implementation</span> <span class=\"title\">ViewController1</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 创建timer</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:<span class=\"keyword\">self</span> selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)test &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;11&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"type\">void</span>)dealloc &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSLog</span>(<span class=\"string\">@&quot;%s&quot;</span>, __func__);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 退出界面时，使timer失效从而销毁</span></span><br><span class=\"line\">    [<span class=\"keyword\">self</span>.timer invalidate];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行代码，点击<code>ViewController</code>进入<code>ViewController1</code>，此时<code>timer</code>跑起来了，每隔1秒打印一次“11”。此时点击返回按钮，返回<code>ViewController</code>，正常情况下<code>ViewController1</code>应该会销毁，并触发<code>dealloc</code>方法，<code>timer</code>也跟着失效并且销毁。但实际情况却是<code>ViewController1</code>没有销毁，也没有触发<code>dealloc</code>方法，<code>timer</code>还一直跑着，这是因为<code>timer</code>和<code>ViewController1</code>形成了循环引用，导致内存泄漏。</p>\n<p>查看<code>timer</code>的创建方法，可以知道：**<code>timer</code>会强引用<code>target</code>，**也就是说<code>timer</code>确实强引用着<code>ViewController1</code>。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111435.png\" alt=\"creatTimer\"></p>\n<p>而<code>ViewController</code>又强引用着<code>timer</code>。</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706111630.png\" alt=\"img\"></p>\n<p>那怎么打破<code>NSTimer</code>的循环引用呢？我们知道<code>__weak</code>是专门用来打破循环引用的，那它是不是也能打破<code>NSTimer</code>的循环引用？</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 尝试用__weak打破NSTimer的循环引用</span></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> target:weakSelf selector:<span class=\"keyword\">@selector</span>(test) userInfo:<span class=\"literal\">nil</span> repeats:<span class=\"literal\">YES</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行，发现没有效果，那为什么<code>__weak</code>不能打破<code>NSTimer</code>的循环引用？毫无疑问<code>__weak</code>的确是把<code>self</code>搞成了弱指针，但因为<code>NSTimer</code>内部有一个强指针类型的<code>target</code>变量</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">strong</span>) <span class=\"type\">id</span> target;</span><br></pre></td></tr></table></figure>\n\n<p>来接收这个传进来的地址值，所以无论你外界是传进来强指针还是弱指针，它内部都是一个强指针接收，就总是会强引用<code>target</code>，所以用<code>__weak</code>不能打破<code>NSTimer</code>的循环引用。</p>\n<p>那再试试另一条引用线吧，让<code>ViewController1</code>弱引用<code>timer</code>。</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">@interface</span> <span class=\"title\">ViewController1</span> ()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试用weak修饰timer来打破NSTimer的循环引用</span></span><br><span class=\"line\"><span class=\"keyword\">@property</span> (<span class=\"keyword\">nonatomic</span>, <span class=\"keyword\">weak</span>) <span class=\"built_in\">NSTimer</span> *timer;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@end</span></span><br></pre></td></tr></table></figure>\n\n<p>运行，发现没有效果，奇了怪了，怎么回事呢？查看官方对<code>NSTimer</code>的说明，可以知道：<strong>把<code>timer</code>添加到RunLoop之后，RunLoop会强引用<code>timer</code>，并且建议我们不必自己强引用<code>timer</code>，而解除RunLoop对<code>timer</code>强引用的唯一方式就是调用<code>timer</code>的<code>invalidate</code>方法使<code>timer</code>失效从而销毁。</strong></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112314.png\" alt=\"img\"></p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112417.png\" alt=\"img\"></p>\n<p>也就是说，实际的引用关系如下：</p>\n<p><img src=\"https://blog-1311875715.cos.ap-beijing.myqcloud.com/blog/20220706112543.png\" alt=\"img\"></p>\n<p>所以我们<strong>使用<code>weak</code>修饰<code>timer</code>是正确的，</strong>但这还是不能打破<code>NSTimer</code>的循环引用——更准确地说，这可以解决<code>NSTimer</code>的循环引用，但还是没有解决<code>NSTimer</code>内存泄漏的问题。因为<code>[self.timer invalidate]</code>的调用——即<code>timer</code>的销毁——最好就是发生在<code>ViewController1</code>销毁时，而<code>ViewController1</code>要想销毁就必须得<code>timer</code>先销毁，还是内存泄漏。</p>\n<p>倒腾来倒腾去，还是得<strong>从<code>timer</code>强引用<code>target</code>这条引用线下手，把它搞成弱引用，<code>__weak</code>不起作用，那我们想想别的方案呗。</strong></p>\n<h4 id=\"2、打破NSTimer的循环引用\"><a href=\"#2、打破NSTimer的循环引用\" class=\"headerlink\" title=\"2、打破NSTimer的循环引用\"></a>2、打破<code>NSTimer</code>的循环引用</h4><ul>\n<li>方案一：使用block的方式创建<code>timer</code></li>\n</ul>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"type\">void</span>)viewDidLoad &#123;</span><br><span class=\"line\">    [<span class=\"variable language_\">super</span> viewDidLoad];</span><br><span class=\"line\"></span><br><span class=\"line\">    __<span class=\"keyword\">weak</span> <span class=\"keyword\">typeof</span>(<span class=\"keyword\">self</span>) weakSelf = <span class=\"keyword\">self</span>;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.timer = [<span class=\"built_in\">NSTimer</span> scheduledTimerWithTimeInterval:<span class=\"number\">1</span> repeats:<span class=\"literal\">YES</span> block:^(<span class=\"built_in\">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        [weakSelf test];</span><br><span class=\"line\">    &#125;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么能解决呢？因为此时<code>timer</code>是强引用block的，而<code>__weak</code>可以打破block的循环引用，所以block是弱引用<code>self</code>的，所以最终的效果就类似于<code>timer</code>弱引用<code>self</code>。解决是能解决，但用这种方式创建<code>timer</code>要iOS10.0以后才能使用。</p>"},{"title":"【Runtime系列】一、Runtime是什么？","date":"2022-07-06T06:30:48.000Z","_content":"","source":"_posts/【Runtime系列】Runtime是什么？.md","raw":"---\ntitle: 【Runtime系列】一、Runtime是什么？\ndate: 2022-07-06 14:30:48\ntags:\n---\n","slug":"【Runtime系列】Runtime是什么？","published":1,"updated":"2022-07-06T06:30:48.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl5983w1r0000wmfyex5x2qqb","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl481yqwv000136fy4lk172zm","tag_id":"cl481yqx0000436fy4yl1hvfi","_id":"cl481yqx3000636fydv5410zb"},{"post_id":"cl481yqwy000336fy52h5hp7d","tag_id":"cl481yqx0000436fy4yl1hvfi","_id":"cl481yqx3000736fy2noi2zvf"}],"Tag":[{"name":"技术","_id":"cl481yqx0000436fy4yl1hvfi"}]}}